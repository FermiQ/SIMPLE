!> \brief \b DAXPY                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION DA                                             
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*),DY(*)                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    DAXPY constant times a vector plus a vector.                      
!>    uses unrolled loops for increments equal to one.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DA                                                        
!> \verbatim                                                            
!>          DA is DOUBLE PRECISION                                      
!>           On entry, DA specifies the scalar alpha.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DX                                                        
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DY                                                    
!> \verbatim                                                            
!>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of DY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION DA 
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*),DY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (DA.EQ.0.0d0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
      M = MOD(N,4) 
      IF (M.NE.0) THEN 
            DO I = 1,M 
            DY(I) = DY(I) + DA*DX(I) 
            END DO 
      END IF 
      IF (N.LT.4) RETURN 
      MP1 = M + 1 
      DO I = MP1,N,4 
            DY(I) = DY(I) + DA*DX(I) 
            DY(I+1) = DY(I+1) + DA*DX(I+1) 
            DY(I+2) = DY(I+2) + DA*DX(I+2) 
            DY(I+3) = DY(I+3) + DA*DX(I+3) 
      END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
      IX = 1 
      IY = 1 
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
      DO I = 1,N 
      DY(IY) = DY(IY) + DA*DX(IX) 
      IX = IX + INCX 
      IY = IY + INCY 
      END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b DCOMBSSQ adds two scaled sum of squares quantities.        
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DCOMBSSQ( V1, V2 )                                   
!                                                                       
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   V1( 2 ), V2( 2 )                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DCOMBSSQ adds two scaled sum of squares quantities, V1 := V1 + V2.   
!> That is,                                                             
!>                                                                      
!>    V1_scale**2 * V1_sumsq := V1_scale**2 * V1_sumsq                  
!>                            + V2_scale**2 * V2_sumsq                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in,out] V1                                                    
!> \verbatim                                                            
!>          V1 is DOUBLE PRECISION array, dimension (2).                
!>          The first scaled sum.                                       
!>          V1(1) = V1_scale, V1(2) = V1_sumsq.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V2                                                        
!> \verbatim                                                            
!>          V2 is DOUBLE PRECISION array, dimension (2).                
!>          The second scaled sum.                                      
!>          V2(1) = V2_scale, V2(2) = V2_sumsq.                         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2018                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DCOMBSSQ( V1, V2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2018                                                     
!                                                                       
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   V1( 2 ), V2( 2 ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( V1( 1 ).GE.V2( 1 ) ) THEN 
      IF( V1( 1 ).NE.ZERO ) THEN 
            V1( 2 ) = V1( 2 ) + ( V2( 1 ) / V1( 1 ) )**2 * V2( 2 ) 
      ELSE 
            V1( 2 ) = V1( 2 ) + V2( 2 ) 
      END IF 
      ELSE 
      V1( 2 ) = V2( 2 ) + ( V1( 1 ) / V2( 1 ) )**2 * V1( 2 ) 
      V1( 1 ) = V2( 1 ) 
      END IF 
      RETURN 
!                                                                       
!     End of DCOMBSSQ                                                   
!                                                                       
      END                                           
!> \brief \b DCOPY                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*),DY(*)                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    DCOPY copies a vector, x, to a vector, y.                         
!>    uses unrolled loops for increments equal to 1.                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DX                                                        
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DY                                                       
!> \verbatim                                                            
!>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of DY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DCOPY(N,DX,INCX,DY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*),DY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
      M = MOD(N,7) 
      IF (M.NE.0) THEN 
            DO I = 1,M 
            DY(I) = DX(I) 
            END DO 
            IF (N.LT.7) RETURN 
      END IF 
      MP1 = M + 1 
      DO I = MP1,N,7 
            DY(I) = DX(I) 
            DY(I+1) = DX(I+1) 
            DY(I+2) = DX(I+2) 
            DY(I+3) = DX(I+3) 
            DY(I+4) = DX(I+4) 
            DY(I+5) = DX(I+5) 
            DY(I+6) = DX(I+6) 
      END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
      IX = 1 
      IY = 1 
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
      DO I = 1,N 
            DY(IY) = DX(IX) 
            IX = IX + INCX 
            IY = IY + INCY 
      END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b DDOT                                                       
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)               
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*),DY(*)                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    DDOT forms the dot product of two vectors.                        
!>    uses unrolled loops for increments equal to one.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DX                                                        
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DY                                                        
!> \verbatim                                                            
!>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of DY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*),DY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLE PRECISION DTEMP 
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      DDOT = 0.0d0 
      DTEMP = 0.0d0 
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
      M = MOD(N,5) 
      IF (M.NE.0) THEN 
            DO I = 1,M 
            DTEMP = DTEMP + DX(I)*DY(I) 
            END DO 
            IF (N.LT.5) THEN 
            DDOT=DTEMP 
            RETURN 
            END IF 
      END IF 
      MP1 = M + 1 
      DO I = MP1,N,5 
      DTEMP = DTEMP + DX(I)*DY(I) + DX(I+1)*DY(I+1) +               &
&            DX(I+2)*DY(I+2) + DX(I+3)*DY(I+3) + DX(I+4)*DY(I+4)   
      END DO 
      ELSE 
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
      IX = 1 
      IY = 1 
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
      DO I = 1,N 
            DTEMP = DTEMP + DX(IX)*DY(IY) 
            IX = IX + INCX 
            IY = IY + INCY 
      END DO 
      END IF 
      DDOT = DTEMP 
      RETURN 
      END                                           
!> \brief \b DGEMM                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LD
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA,BETA                                     
!       INTEGER K,LDA,LDB,LDC,M,N                                       
!       CHARACTER TRANSA,TRANSB                                         
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)                     
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DGEMM  performs one of the matrix-matrix operations                  
!>                                                                      
!>    C := alpha*op( A )*op( B ) + beta*C,                              
!>                                                                      
!> where  op( X ) is one of                                             
!>                                                                      
!>    op( X ) = X   or   op( X ) = X**T,                                
!>                                                                      
!> alpha and beta are scalars, and A, B and C are matrices, with op( A )
!> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TRANSA                                                    
!> \verbatim                                                            
!>          TRANSA is CHARACTER*1                                       
!>           On entry, TRANSA specifies the form of op( A ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSA = 'N' or 'n',  op( A ) = A.                      
!>                                                                      
!>              TRANSA = 'T' or 't',  op( A ) = A**T.                   
!>                                                                      
!>              TRANSA = 'C' or 'c',  op( A ) = A**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANSB                                                    
!> \verbatim                                                            
!>          TRANSB is CHARACTER*1                                       
!>           On entry, TRANSB specifies the form of op( B ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSB = 'N' or 'n',  op( B ) = B.                      
!>                                                                      
!>              TRANSB = 'T' or 't',  op( B ) = B**T.                   
!>                                                                      
!>              TRANSB = 'C' or 'c',  op( B ) = B**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry,  M  specifies  the number  of rows  of the  matri
!>           op( A )  and of the  matrix  C.  M  must  be at least  zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry,  N  specifies the number  of columns of the matri
!>           op( B ) and the number of columns of the matrix C. N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>           On entry,  K  specifies  the number of columns of the matri
!>           op( A ) and the number of rows of the matrix op( B ). K mus
!>           be at least  zero.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka
!>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.       
!>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by 
!>           part of the array  A  must contain the matrix  A,  otherwis
!>           the leading  k by m  part of the array  A  must contain  th
!>           matrix A.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. When  TRANSA = 'N' or 'n' the
!>           LDA must be at least  max( 1, m ), otherwise  LDA must be a
!>           least  max( 1, k ).                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb
!>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.       
!>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by 
!>           part of the array  B  must contain the matrix  B,  otherwis
!>           the leading  n by k  part of the array  B  must contain  th
!>           matrix B.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in the calling (sub) program. When  TRANSB = 'N' or 'n' the
!>           LDB must be at least  max( 1, k ), otherwise  LDB must be a
!>           least  max( 1, n ).                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is DOUBLE PRECISION.                                   
!>           On entry,  BETA  specifies the scalar  beta.  When  BETA  i
!>           supplied as zero then C need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension ( LDC, N )           
!>           Before entry, the leading  m by n  part of the array  C mus
!>           contain the matrix  C,  except when  beta  is zero, in whic
!>           case C need not be set on entry.                           
!>           On exit, the array  C  is overwritten by the  m by n  matri
!>           ( alpha*op( A )*op( B ) + beta*C ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>           On entry, LDC specifies the first dimension of C as declare
!>           in  the  calling  (sub)  program.   LDC  must  be  at  leas
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA,BETA 
      INTEGER K,LDA,LDB,LDC,M,N 
      CHARACTER TRANSA,TRANSB 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP 
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB 
      LOGICAL NOTA,NOTB 
!     ..                                                                
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!                                                                       
!     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
!     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
!     and  columns of  A  and the  number of  rows  of  B  respectively.
!                                                                       
      NOTA = LSAME(TRANSA,'N') 
      NOTB = LSAME(TRANSB,'N') 
      IF (NOTA) THEN 
      NROWA = M 
      NCOLA = K 
      ELSE 
      NROWA = K 
      NCOLA = M 
      END IF 
      IF (NOTB) THEN 
      NROWB = K 
      ELSE 
      NROWB = N 
      END IF 
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.              &
&    (.NOT.LSAME(TRANSA,'T'))) THEN                                
      INFO = 1 
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.         &
&         (.NOT.LSAME(TRANSB,'T'))) THEN                           
      INFO = 2 
      ELSE IF (M.LT.0) THEN 
      INFO = 3 
      ELSE IF (N.LT.0) THEN 
      INFO = 4 
      ELSE IF (K.LT.0) THEN 
      INFO = 5 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
      INFO = 8 
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN 
      INFO = 10 
      ELSE IF (LDC.LT.MAX(1,M)) THEN 
      INFO = 13 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DGEMM ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.                                   &
&    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN   
!                                                                       
!     And if  alpha.eq.zero.                                            
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
      IF (BETA.EQ.ZERO) THEN 
            DO 20 J = 1,N 
                  DO 10 I = 1,M 
                  C(I,J) = ZERO 
10             CONTINUE 
20         CONTINUE 
      ELSE 
            DO 40 J = 1,N 
                  DO 30 I = 1,M 
                  C(I,J) = BETA*C(I,J) 
30             CONTINUE 
40         CONTINUE 
      END IF 
      RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (NOTB) THEN 
      IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B + beta*C.                              
!                                                                       
            DO 90 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                  DO 50 I = 1,M 
                        C(I,J) = ZERO 
50                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                  DO 60 I = 1,M 
                        C(I,J) = BETA*C(I,J) 
60                 CONTINUE 
                  END IF 
                  DO 80 L = 1,K 
                  TEMP = ALPHA*B(L,J) 
                  DO 70 I = 1,M 
                        C(I,J) = C(I,J) + TEMP*A(I,L) 
70                 CONTINUE 
80             CONTINUE 
90         CONTINUE 
      ELSE 
!                                                                       
!           Form  C := alpha*A**T*B + beta*C                            
!                                                                       
            DO 120 J = 1,N 
                  DO 110 I = 1,M 
                  TEMP = ZERO 
                  DO 100 L = 1,K 
                        TEMP = TEMP + A(L,I)*B(L,J) 
100                 CONTINUE 
                  IF (BETA.EQ.ZERO) THEN 
                        C(I,J) = ALPHA*TEMP 
                  ELSE 
                        C(I,J) = ALPHA*TEMP + BETA*C(I,J) 
                  END IF 
110             CONTINUE 
120         CONTINUE 
      END IF 
      ELSE 
      IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B**T + beta*C                            
!                                                                       
            DO 170 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                  DO 130 I = 1,M 
                        C(I,J) = ZERO 
130                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                  DO 140 I = 1,M 
                        C(I,J) = BETA*C(I,J) 
140                 CONTINUE 
                  END IF 
                  DO 160 L = 1,K 
                  TEMP = ALPHA*B(J,L) 
                  DO 150 I = 1,M 
                        C(I,J) = C(I,J) + TEMP*A(I,L) 
150                 CONTINUE 
160             CONTINUE 
170         CONTINUE 
      ELSE 
!                                                                       
!           Form  C := alpha*A**T*B**T + beta*C                         
!                                                                       
            DO 200 J = 1,N 
                  DO 190 I = 1,M 
                  TEMP = ZERO 
                  DO 180 L = 1,K 
                        TEMP = TEMP + A(L,I)*B(J,L) 
180                 CONTINUE 
                  IF (BETA.EQ.ZERO) THEN 
                        C(I,J) = ALPHA*TEMP 
                  ELSE 
                        C(I,J) = ALPHA*TEMP + BETA*C(I,J) 
                  END IF 
190             CONTINUE 
200         CONTINUE 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DGEMM .                                                    
!                                                                       
      END                                           
!> \brief \b DGEMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)      
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA,BETA                                     
!       INTEGER INCX,INCY,LDA,M,N                                       
!       CHARACTER TRANS                                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),X(*),Y(*)                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DGEMV  performs one of the matrix-vector operations                  
!>                                                                      
!>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,       
!>                                                                      
!> where alpha and beta are scalars, x and y are vectors and A is an    
!> m by n matrix.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry, TRANS specifies the operation to be performed as 
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.           
!>                                                                      
!>              TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y.        
!>                                                                      
!>              TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of the matrix A.  
!>           M must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of the matrix A
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, N )           
!>           Before entry, the leading m by n part of the array A must  
!>           contain the matrix of coefficients.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'      
!>           and at least                                               
!>           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.                   
!>           Before entry, the incremented array X must contain the     
!>           vector x.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is DOUBLE PRECISION.                                   
!>           On entry, BETA specifies the scalar beta. When BETA is     
!>           supplied as zero then Y need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'      
!>           and at least                                               
!>           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.                   
!>           Before entry with BETA non-zero, the incremented array Y   
!>           must contain the vector y. On exit, Y is overwritten by the
!>           updated vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA,BETA 
      INTEGER INCX,INCY,LDA,M,N 
      CHARACTER TRANS 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY,LENX,LENY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.       &
&    .NOT.LSAME(TRANS,'C')) THEN                                   
      INFO = 1 
      ELSE IF (M.LT.0) THEN 
      INFO = 2 
      ELSE IF (N.LT.0) THEN 
      INFO = 3 
      ELSE IF (LDA.LT.MAX(1,M)) THEN 
      INFO = 6 
      ELSE IF (INCX.EQ.0) THEN 
      INFO = 8 
      ELSE IF (INCY.EQ.0) THEN 
      INFO = 11 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DGEMV ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.                                   &
&    ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN                  
!                                                                       
!     Set  LENX  and  LENY, the lengths of the vectors x and y, and set 
!     up the start points in  X  and  Y.                                
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
      LENX = N 
      LENY = M 
      ELSE 
      LENX = M 
      LENY = N 
      END IF 
      IF (INCX.GT.0) THEN 
      KX = 1 
      ELSE 
      KX = 1 - (LENX-1)*INCX 
      END IF 
      IF (INCY.GT.0) THEN 
      KY = 1 
      ELSE 
      KY = 1 - (LENY-1)*INCY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF (BETA.NE.ONE) THEN 
      IF (INCY.EQ.1) THEN 
            IF (BETA.EQ.ZERO) THEN 
                  DO 10 I = 1,LENY 
                  Y(I) = ZERO 
10             CONTINUE 
            ELSE 
                  DO 20 I = 1,LENY 
                  Y(I) = BETA*Y(I) 
20             CONTINUE 
            END IF 
      ELSE 
            IY = KY 
            IF (BETA.EQ.ZERO) THEN 
                  DO 30 I = 1,LENY 
                  Y(IY) = ZERO 
                  IY = IY + INCY 
30             CONTINUE 
            ELSE 
                  DO 40 I = 1,LENY 
                  Y(IY) = BETA*Y(IY) 
                  IY = IY + INCY 
40             CONTINUE 
            END IF 
      END IF 
      END IF 
      IF (ALPHA.EQ.ZERO) RETURN 
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  y := alpha*A*x + y.                                      
!                                                                       
      JX = KX 
      IF (INCY.EQ.1) THEN 
            DO 60 J = 1,N 
                  TEMP = ALPHA*X(JX) 
                  DO 50 I = 1,M 
                  Y(I) = Y(I) + TEMP*A(I,J) 
50             CONTINUE 
                  JX = JX + INCX 
60         CONTINUE 
      ELSE 
            DO 80 J = 1,N 
                  TEMP = ALPHA*X(JX) 
                  IY = KY 
                  DO 70 I = 1,M 
                  Y(IY) = Y(IY) + TEMP*A(I,J) 
                  IY = IY + INCY 
70             CONTINUE 
                  JX = JX + INCX 
80         CONTINUE 
      END IF 
      ELSE 
!                                                                       
!        Form  y := alpha*A**T*x + y.                                   
!                                                                       
      JY = KY 
      IF (INCX.EQ.1) THEN 
            DO 100 J = 1,N 
                  TEMP = ZERO 
                  DO 90 I = 1,M 
                  TEMP = TEMP + A(I,J)*X(I) 
90             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP 
                  JY = JY + INCY 
100         CONTINUE 
      ELSE 
            DO 120 J = 1,N 
                  TEMP = ZERO 
                  IX = KX 
                  DO 110 I = 1,M 
                  TEMP = TEMP + A(I,J)*X(IX) 
                  IX = IX + INCX 
110             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP 
                  JY = JY + INCY 
120         CONTINUE 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DGEMV .                                                    
!                                                                       
      END                                           
!> \brief \b DGER                                                       
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA                                          
!       INTEGER INCX,INCY,LDA,M,N                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),X(*),Y(*)                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DGER   performs the rank 1 operation                                 
!>                                                                      
!>    A := alpha*x*y**T + A,                                            
!>                                                                      
!> where alpha is a scalar, x is an m element vector, y is an n element 
!> vector and A is an m by n matrix.                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of the matrix A.  
!>           M must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of the matrix A
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( m - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the m   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, N )           
!>           Before entry, the leading m by n part of the array A must  
!>           contain the matrix of coefficients. On exit, A is          
!>           overwritten by the updated matrix.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA 
      INTEGER INCX,INCY,LDA,M,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ZERO 
      PARAMETER (ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP 
      INTEGER I,INFO,IX,J,JY,KX 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
      INFO = 1 
      ELSE IF (N.LT.0) THEN 
      INFO = 2 
      ELSE IF (INCX.EQ.0) THEN 
      INFO = 5 
      ELSE IF (INCY.EQ.0) THEN 
      INFO = 7 
      ELSE IF (LDA.LT.MAX(1,M)) THEN 
      INFO = 9 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DGER  ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF (INCY.GT.0) THEN 
      JY = 1 
      ELSE 
      JY = 1 - (N-1)*INCY 
      END IF 
      IF (INCX.EQ.1) THEN 
      DO 20 J = 1,N 
            IF (Y(JY).NE.ZERO) THEN 
                  TEMP = ALPHA*Y(JY) 
                  DO 10 I = 1,M 
                  A(I,J) = A(I,J) + X(I)*TEMP 
10             CONTINUE 
            END IF 
            JY = JY + INCY 
20     CONTINUE 
      ELSE 
      IF (INCX.GT.0) THEN 
            KX = 1 
      ELSE 
            KX = 1 - (M-1)*INCX 
      END IF 
      DO 40 J = 1,N 
            IF (Y(JY).NE.ZERO) THEN 
                  TEMP = ALPHA*Y(JY) 
                  IX = KX 
                  DO 30 I = 1,M 
                  A(I,J) = A(I,J) + X(IX)*TEMP 
                  IX = IX + INCX 
30             CONTINUE 
            END IF 
            JY = JY + INCY 
40     CONTINUE 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DGER  .                                                    
!                                                                       
      END                                           
!> \brief \b DISNAN tests input for NaN.                                
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DISNAN + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION DISNAN( DIN )                                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION, INTENT(IN) :: DIN                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DISNAN returns .TRUE. if its argument is NaN, and .FALSE.            
!> otherwise.  To be replaced by the Fortran 2003 intrinsic in the      
!> future.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] DIN                                                       
!> \verbatim                                                            
!>          DIN is DOUBLE PRECISION                                     
!>          Input to test for NaN.                                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION DISNAN( DIN ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION, INTENT(IN) :: DIN 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!  .. External Functions ..                                             
      LOGICAL DLAISNAN 
      EXTERNAL DLAISNAN 
!  ..                                                                   
!  .. Executable Statements ..                                          
      DISNAN = DLAISNAN(DIN,DIN) 
      RETURN 
      END                                           
!> \brief \b DLAE2 computes the eigenvalues of a 2-by-2 symmetric matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAE2 + dependencies                                        
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAE2( A, B, C, RT1, RT2 )                           
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION   A, B, C, RT1, RT2                            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix         
!>    [  A   B  ]                                                       
!>    [  B   C  ].                                                      
!> On return, RT1 is the eigenvalue of larger absolute value, and RT2   
!> is the eigenvalue of smaller absolute value.                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION                                       
!>          The (1,1) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is DOUBLE PRECISION                                       
!>          The (1,2) and (2,1) elements of the 2-by-2 matrix.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is DOUBLE PRECISION                                       
!>          The (2,2) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT1                                                      
!> \verbatim                                                            
!>          RT1 is DOUBLE PRECISION                                     
!>          The eigenvalue of larger absolute value.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT2                                                      
!> \verbatim                                                            
!>          RT2 is DOUBLE PRECISION                                     
!>          The eigenvalue of smaller absolute value.                   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  RT1 is accurate to a few ulps barring over/underflow.               
!>                                                                      
!>  RT2 may be inaccurate if there is massive cancellation in the       
!>  determinant A*C-B*B; higher precision or correctly rounded or       
!>  correctly truncated arithmetic would be needed to compute RT2       
!>  accurately in all cases.                                            
!>                                                                      
!>  Overflow is possible only if RT1 is within a factor of 5 of overflow
!>  Underflow is harmless if the input data is 0 or exceeds             
!>     underflow_threshold / macheps.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLAE2( A, B, C, RT1, RT2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION   A, B, C, RT1, RT2 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D0 ) 
      DOUBLE PRECISION   TWO 
      PARAMETER          ( TWO = 2.0D0 ) 
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
      DOUBLE PRECISION   HALF 
      PARAMETER          ( HALF = 0.5D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION   AB, ACMN, ACMX, ADF, DF, RT, SM, TB 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Compute the eigenvalues                                           
!                                                                       
      SM = A + C 
      DF = A - C 
      ADF = ABS( DF ) 
      TB = B + B 
      AB = ABS( TB ) 
      IF( ABS( A ).GT.ABS( C ) ) THEN 
      ACMX = A 
      ACMN = C 
      ELSE 
      ACMX = C 
      ACMN = A 
      END IF 
      IF( ADF.GT.AB ) THEN 
      RT = ADF*SQRT( ONE+( AB / ADF )**2 ) 
      ELSE IF( ADF.LT.AB ) THEN 
      RT = AB*SQRT( ONE+( ADF / AB )**2 ) 
      ELSE 
!                                                                       
!        Includes case AB=ADF=0                                         
!                                                                       
      RT = AB*SQRT( TWO ) 
      END IF 
      IF( SM.LT.ZERO ) THEN 
      RT1 = HALF*( SM-RT ) 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
      RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE IF( SM.GT.ZERO ) THEN 
      RT1 = HALF*( SM+RT ) 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
      RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE 
!                                                                       
!        Includes case RT1 = RT2 = 0                                    
!                                                                       
      RT1 = HALF*RT 
      RT2 = -HALF*RT 
      END IF 
      RETURN 
!                                                                       
!     End of DLAE2                                                      
!                                                                       
!> \brief \b DLAEBZ computes the number of eigenvalues of a real symmetr
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAEBZ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,  
!                          RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT, 
!                          NAB, WORK, IWORK, INFO )                     
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMA
!       DOUBLE PRECISION   ABSTOL, PIVMIN, RELTOL                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * )        
!       DOUBLE PRECISION   AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * 
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAEBZ contains the iteration loops which compute and use the        
!> function N(w), which is the count of eigenvalues of a symmetric      
!> tridiagonal matrix T less than or equal to its argument  w.  It      
!> performs a choice of two types of loops:                             
!>                                                                      
!> IJOB=1, followed by                                                  
!> IJOB=2: It takes as input a list of intervals and returns a list of  
!>         sufficiently small intervals whose union contains the same   
!>         eigenvalues as the union of the original intervals.          
!>         The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.     
!>         The output interval (AB(j,1),AB(j,2)] will contain           
!>         eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.   
!>                                                                      
!> IJOB=3: It performs a binary search in each input interval           
!>         (AB(j,1),AB(j,2)] for a point  w(j)  such that               
!>         N(w(j))=NVAL(j), and uses  C(j)  as the starting point of    
!>         the search.  If such a w(j) is found, then on output         
!>         AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output 
!>         (AB(j,1),AB(j,2)] will be a small interval containing the    
!>         point where N(w) jumps through NVAL(j), unless that point    
!>         lies outside the initial interval.                           
!>                                                                      
!> Note that the intervals are in all cases half-open intervals,        
!> i.e., of the form  (a,b] , which includes  b  but not  a .           
!>                                                                      
!> To avoid underflow, the matrix should be scaled so that its largest  
!> element is no greater than  overflow**(1/2) * underflow**(1/4)       
!> in absolute value.  To assure the most accurate computation          
!> of small eigenvalues, the matrix should be scaled to be              
!> not much smaller than that, either.                                  
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966                                            
!>                                                                      
!> Note: the arguments are, in general, *not* checked for unreasonable  
!> values.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] IJOB                                                      
!> \verbatim                                                            
!>          IJOB is INTEGER                                             
!>          Specifies what is to be done:                               
!>          = 1:  Compute NAB for the initial intervals.                
!>          = 2:  Perform bisection iteration to find eigenvalues of T. 
!>          = 3:  Perform bisection iteration to invert N(w), i.e.,     
!>                to find a point which has a specified number of       
!>                eigenvalues of T to its left.                         
!>          Other values will cause DLAEBZ to return with INFO=-1.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NITMAX                                                    
!> \verbatim                                                            
!>          NITMAX is INTEGER                                           
!>          The maximum number of "levels" of bisection to be           
!>          performed, i.e., an interval of width W will not be made    
!>          smaller than 2^(-NITMAX) * W.  If not all intervals         
!>          have converged after NITMAX iterations, then INFO is set    
!>          to the number of non-converged intervals.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The dimension n of the tridiagonal matrix T.  It must be at 
!>          least 1.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MMAX                                                      
!> \verbatim                                                            
!>          MMAX is INTEGER                                             
!>          The maximum number of intervals.  If more than MMAX interval
!>          are generated, then DLAEBZ will quit with INFO=MMAX+1.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MINP                                                      
!> \verbatim                                                            
!>          MINP is INTEGER                                             
!>          The initial number of intervals.  It may not be greater than
!>          MMAX.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NBMIN                                                     
!> \verbatim                                                            
!>          NBMIN is INTEGER                                            
!>          The smallest number of intervals that should be processed   
!>          using a vector loop.  If zero, then only the scalar loop    
!>          will be used.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is DOUBLE PRECISION                                  
!>          The minimum (absolute) width of an interval.  When an       
!>          interval is narrower than ABSTOL, or than RELTOL times the  
!>          larger (in magnitude) endpoint, then it is considered to be 
!>          sufficiently small, i.e., converged.  This must be at least 
!>          zero.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is DOUBLE PRECISION                                  
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than ABSTOL, or than RELTOL times the larger (in
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum absolute value of a "pivot" in the Sturm        
!>          sequence loop.                                              
!>          This must be at least  max |e(j)**2|*safe_min  and at       
!>          least safe_min, where safe_min is at least                  
!>          the smallest number that can divide one without overflow.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The diagonal elements of the tridiagonal matrix T.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          The offdiagonal elements of the tridiagonal matrix T in     
!>          positions 1 through N-1.  E(N) is arbitrary.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N)                 
!>          The squares of the offdiagonal elements of the tridiagonal  
!>          matrix T.  E2(N) is ignored.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NVAL                                                  
!> \verbatim                                                            
!>          NVAL is INTEGER array, dimension (MINP)                     
!>          If IJOB=1 or 2, not referenced.                             
!>          If IJOB=3, the desired values of N(w).  The elements of NVAL
!>          will be reordered to correspond with the intervals in AB.   
!>          Thus, NVAL(j) on output will not, in general be the same as 
!>          NVAL(j) on input, but it will correspond with the interval  
!>          (AB(j,1),AB(j,2)] on output.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] AB                                                    
!> \verbatim                                                            
!>          AB is DOUBLE PRECISION array, dimension (MMAX,2)            
!>          The endpoints of the intervals.  AB(j,1) is  a(j), the left 
!>          endpoint of the j-th interval, and AB(j,2) is b(j), the     
!>          right endpoint of the j-th interval.  The input intervals   
!>          will, in general, be modified, split, and reordered by the  
      END                                           
!>          calculation.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (MMAX)               
!>          If IJOB=1, ignored.                                         
!>          If IJOB=2, workspace.                                       
!>          If IJOB=3, then on input C(j) should be initialized to the  
!>          first search point in the binary search.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] MOUT                                                     
!> \verbatim                                                            
!>          MOUT is INTEGER                                             
!>          If IJOB=1, the number of eigenvalues in the intervals.      
!>          If IJOB=2 or 3, the number of intervals output.             
!>          If IJOB=3, MOUT will equal MINP.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NAB                                                   
!> \verbatim                                                            
!>          NAB is INTEGER array, dimension (MMAX,2)                    
!>          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j))
!>          If IJOB=2, then on input, NAB(i,j) should be set.  It must  
!>             satisfy the condition:                                   
!>             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)),        
!>             which means that in interval i only eigenvalues          
!>             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,    
!>             NAB(i,j)=N(AB(i,j)), from a previous call to DLAEBZ with 
!>             IJOB=1.                                                  
!>             On output, NAB(i,j) will contain                         
!>             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
!>             the input interval that the output interval              
!>             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the 
!>             the input values of NAB(k,1) and NAB(k,2).               
!>          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),    
!>             unless N(w) > NVAL(i) for all search points  w , in which
!>             case NAB(i,1) will not be modified, i.e., the output     
!>             value will be the same as the input value (modulo        
!>             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
!>             for all search points  w , in which case NAB(i,2) will   
!>             not be modified.  Normally, NAB should be set to some    
!>             distinctive value(s) before DLAEBZ is called.            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MMAX)            
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (MMAX)                    
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:       All intervals converged.                         
!>          = 1--MMAX: The last INFO intervals did not converge.        
!>          = MMAX+1:  More than MMAX intervals were generated.         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>      This routine is intended to be called only by other LAPACK      
!>  routines, thus the interface is less user-friendly.  It is intended 
!>  for two purposes:                                                   
!>                                                                      
!>  (a) finding eigenvalues.  In this case, DLAEBZ should have one or   
!>      more initial intervals set up in AB, and DLAEBZ should be called
!>      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
!>      Intervals with no eigenvalues would usually be thrown out at    
!>      this point.  Also, if not all the eigenvalues in an interval i  
!>      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.   
!>      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest         
!>      eigenvalue.  DLAEBZ is then called with IJOB=2 and MMAX         
!>      no smaller than the value of MOUT returned by the call with     
!>      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1       
!>      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the  
!>      tolerance specified by ABSTOL and RELTOL.                       
!>                                                                      
!>  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l)
!>      In this case, start with a Gershgorin interval  (a,b).  Set up  
!>      AB to contain 2 search intervals, both initially (a,b).  One    
!>      NVAL element should contain  f-1  and the other should contain  
!>      , while C should contain a and b, resp.  NAB(i,1) should be -1  
!>      and NAB(i,2) should be N+1, to flag an error if the desired     
!>      interval does not lie in (a,b).  DLAEBZ is then called with     
!>      IJOB=3.  On exit, if w(f-1) < w(f), then one of the intervals --
!>      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while 
!>      if, to the specified tolerance, w(f-k)=...=w(f+r), k > 0 and r  
!>      >= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and  
!>      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) < w(l+1) and           
!>      w(l-r)=...=w(l+k) are handled similarly.                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,    &
&                   RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT,   &
&                   NAB, WORK, IWORK, INFO )                       
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMAX 
      DOUBLE PRECISION   ABSTOL, PIVMIN, RELTOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * ) 
      DOUBLE PRECISION   AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * ),&
&                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, TWO, HALF 
      PARAMETER          ( ZERO = 0.0D0, TWO = 2.0D0,                   &
&                   HALF = 1.0D0 / TWO )                           
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            ITMP1, ITMP2, J, JI, JIT, JP, KF, KFNEW, KL,   &
&                   KLNEW                                          
      DOUBLE PRECISION   TMP1, TMP2 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Check for Errors                                                  
!                                                                       
      INFO = 0 
      IF( IJOB.LT.1 .OR. IJOB.GT.3 ) THEN 
      INFO = -1 
      RETURN 
      END IF 
!                                                                       
!     Initialize NAB                                                    
!                                                                       
      IF( IJOB.EQ.1 ) THEN 
!                                                                       
!        Compute the number of eigenvalues in the initial intervals.    
!                                                                       
      MOUT = 0 
      DO 30 JI = 1, MINP 
            DO 20 JP = 1, 2 
            TMP1 = D( 1 ) - AB( JI, JP ) 
            IF( ABS( TMP1 ).LT.PIVMIN )                              &
&            TMP1 = -PIVMIN                                        
            NAB( JI, JP ) = 0 
            IF( TMP1.LE.ZERO )                                       &
&            NAB( JI, JP ) = 1                                     
!                                                                       
            DO 10 J = 2, N 
                  TMP1 = D( J ) - E2( J-1 ) / TMP1 - AB( JI, JP ) 
                  IF( ABS( TMP1 ).LT.PIVMIN )                           &
&               TMP1 = -PIVMIN                                     
                  IF( TMP1.LE.ZERO )                                    &
&               NAB( JI, JP ) = NAB( JI, JP ) + 1                  
10          CONTINUE 
20       CONTINUE 
            MOUT = MOUT + NAB( JI, 2 ) - NAB( JI, 1 ) 
30    CONTINUE 
      RETURN 
      END IF 
!                                                                       
!     Initialize for loop                                               
!                                                                       
!     KF and KL have the following meaning:                             
!        Intervals 1,...,KF-1 have converged.                           
!        Intervals KF,...,KL  still need to be refined.                 
!                                                                       
      KF = 1 
      KL = MINP 
!                                                                       
!     If IJOB=2, initialize C.                                          
!     If IJOB=3, use the user-supplied starting point.                  
!                                                                       
      IF( IJOB.EQ.2 ) THEN 
      DO 40 JI = 1, MINP 
            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) ) 
40    CONTINUE 
      END IF 
!                                                                       
!     Iteration loop                                                    
!                                                                       
      DO 130 JIT = 1, NITMAX 
!                                                                       
!        Loop over intervals                                            
!                                                                       
      IF( KL-KF+1.GE.NBMIN .AND. NBMIN.GT.0 ) THEN 
!                                                                       
!           Begin of Parallel Version of the loop                       
!                                                                       
            DO 60 JI = KF, KL 
!                                                                       
!              Compute N(c), the number of eigenvalues less than c      
!                                                                       
            WORK( JI ) = D( 1 ) - C( JI ) 
            IWORK( JI ) = 0 
            IF( WORK( JI ).LE.PIVMIN ) THEN 
                  IWORK( JI ) = 1 
                  WORK( JI ) = MIN( WORK( JI ), -PIVMIN ) 
            END IF 
!                                                                       
            DO 50 J = 2, N 
                  WORK( JI ) = D( J ) - E2( J-1 ) / WORK( JI ) - C( JI ) 
                  IF( WORK( JI ).LE.PIVMIN ) THEN 
                  IWORK( JI ) = IWORK( JI ) + 1 
                  WORK( JI ) = MIN( WORK( JI ), -PIVMIN ) 
                  END IF 
50          CONTINUE 
60       CONTINUE 
!                                                                       
            IF( IJOB.LE.2 ) THEN 
!                                                                       
!              IJOB=2: Choose all intervals containing eigenvalues.     
!                                                                       
            KLNEW = KL 
            DO 70 JI = KF, KL 
!                                                                       
!                 Insure that N(w) is monotone                          
!                                                                       
                  IWORK( JI ) = MIN( NAB( JI, 2 ),                      &
&                          MAX( NAB( JI, 1 ), IWORK( JI ) ) )      
!                                                                       
!                 Update the Queue -- add intervals if both halves      
!                 contain eigenvalues.                                  
!                                                                       
                  IF( IWORK( JI ).EQ.NAB( JI, 2 ) ) THEN 
!                                                                       
!                    No eigenvalue in the upper interval:               
!                    just use the lower interval.                       
!                                                                       
                  AB( JI, 2 ) = C( JI ) 
!                                                                       
                  ELSE IF( IWORK( JI ).EQ.NAB( JI, 1 ) ) THEN 
!                                                                       
!                    No eigenvalue in the lower interval:               
!                    just use the upper interval.                       
!                                                                       
                  AB( JI, 1 ) = C( JI ) 
                  ELSE 
                  KLNEW = KLNEW + 1 
                  IF( KLNEW.LE.MMAX ) THEN 
!                                                                       
!                       Eigenvalue in both intervals -- add upper to    
!                       queue.                                          
!                                                                       
                        AB( KLNEW, 2 ) = AB( JI, 2 ) 
                        NAB( KLNEW, 2 ) = NAB( JI, 2 ) 
                        AB( KLNEW, 1 ) = C( JI ) 
                        NAB( KLNEW, 1 ) = IWORK( JI ) 
                        AB( JI, 2 ) = C( JI ) 
                        NAB( JI, 2 ) = IWORK( JI ) 
                  ELSE 
                        INFO = MMAX + 1 
                  END IF 
                  END IF 
70          CONTINUE 
            IF( INFO.NE.0 )                                          &
&            RETURN                                                
            KL = KLNEW 
            ELSE 
!                                                                       
!              IJOB=3: Binary search.  Keep only the interval containing
!                      w   s.t. N(w) = NVAL                             
!                                                                       
            DO 80 JI = KF, KL 
                  IF( IWORK( JI ).LE.NVAL( JI ) ) THEN 
                  AB( JI, 1 ) = C( JI ) 
                  NAB( JI, 1 ) = IWORK( JI ) 
                  END IF 
                  IF( IWORK( JI ).GE.NVAL( JI ) ) THEN 
                  AB( JI, 2 ) = C( JI ) 
                  NAB( JI, 2 ) = IWORK( JI ) 
                  END IF 
80          CONTINUE 
            END IF 
!                                                                       
      ELSE 
!                                                                       
!           End of Parallel Version of the loop                         
!                                                                       
!           Begin of Serial Version of the loop                         
!                                                                       
            KLNEW = KL 
            DO 100 JI = KF, KL 
!                                                                       
!              Compute N(w), the number of eigenvalues less than w      
!                                                                       
            TMP1 = C( JI ) 
            TMP2 = D( 1 ) - TMP1 
            ITMP1 = 0 
            IF( TMP2.LE.PIVMIN ) THEN 
                  ITMP1 = 1 
                  TMP2 = MIN( TMP2, -PIVMIN ) 
            END IF 
!                                                                       
            DO 90 J = 2, N 
                  TMP2 = D( J ) - E2( J-1 ) / TMP2 - TMP1 
                  IF( TMP2.LE.PIVMIN ) THEN 
                  ITMP1 = ITMP1 + 1 
                  TMP2 = MIN( TMP2, -PIVMIN ) 
                  END IF 
90          CONTINUE 
!                                                                       
            IF( IJOB.LE.2 ) THEN 
!                                                                       
!                 IJOB=2: Choose all intervals containing eigenvalues.  
!                                                                       
!                 Insure that N(w) is monotone                          
!                                                                       
                  ITMP1 = MIN( NAB( JI, 2 ),                            &
&                    MAX( NAB( JI, 1 ), ITMP1 ) )                  
!                                                                       
!                 Update the Queue -- add intervals if both halves      
!                 contain eigenvalues.                                  
!                                                                       
                  IF( ITMP1.EQ.NAB( JI, 2 ) ) THEN 
!                                                                       
!                    No eigenvalue in the upper interval:               
!                    just use the lower interval.                       
!                                                                       
                  AB( JI, 2 ) = TMP1 
!                                                                       
                  ELSE IF( ITMP1.EQ.NAB( JI, 1 ) ) THEN 
!                                                                       
!                    No eigenvalue in the lower interval:               
!                    just use the upper interval.                       
!                                                                       
                  AB( JI, 1 ) = TMP1 
                  ELSE IF( KLNEW.LT.MMAX ) THEN 
!                                                                       
!                    Eigenvalue in both intervals -- add upper to queue.
!                                                                       
                  KLNEW = KLNEW + 1 
                  AB( KLNEW, 2 ) = AB( JI, 2 ) 
                  NAB( KLNEW, 2 ) = NAB( JI, 2 ) 
                  AB( KLNEW, 1 ) = TMP1 
                  NAB( KLNEW, 1 ) = ITMP1 
                  AB( JI, 2 ) = TMP1 
                  NAB( JI, 2 ) = ITMP1 
                  ELSE 
                  INFO = MMAX + 1 
                  RETURN 
                  END IF 
            ELSE 
!                                                                       
!                 IJOB=3: Binary search.  Keep only the interval        
!                         containing  w  s.t. N(w) = NVAL               
!                                                                       
                  IF( ITMP1.LE.NVAL( JI ) ) THEN 
                  AB( JI, 1 ) = TMP1 
                  NAB( JI, 1 ) = ITMP1 
                  END IF 
                  IF( ITMP1.GE.NVAL( JI ) ) THEN 
                  AB( JI, 2 ) = TMP1 
                  NAB( JI, 2 ) = ITMP1 
                  END IF 
            END IF 
100       CONTINUE 
            KL = KLNEW 
!                                                                       
      END IF 
!                                                                       
!        Check for convergence                                          
!                                                                       
      KFNEW = KF 
      DO 110 JI = KF, KL 
            TMP1 = ABS( AB( JI, 2 )-AB( JI, 1 ) ) 
            TMP2 = MAX( ABS( AB( JI, 2 ) ), ABS( AB( JI, 1 ) ) ) 
            IF( TMP1.LT.MAX( ABSTOL, PIVMIN, RELTOL*TMP2 ) .OR.         &
&          NAB( JI, 1 ).GE.NAB( JI, 2 ) ) THEN                     
!                                                                       
!              Converged -- Swap with position KFNEW,                   
!                           then increment KFNEW                        
!                                                                       
            IF( JI.GT.KFNEW ) THEN 
                  TMP1 = AB( JI, 1 ) 
                  TMP2 = AB( JI, 2 ) 
                  ITMP1 = NAB( JI, 1 ) 
                  ITMP2 = NAB( JI, 2 ) 
                  AB( JI, 1 ) = AB( KFNEW, 1 ) 
                  AB( JI, 2 ) = AB( KFNEW, 2 ) 
                  NAB( JI, 1 ) = NAB( KFNEW, 1 ) 
                  NAB( JI, 2 ) = NAB( KFNEW, 2 ) 
                  AB( KFNEW, 1 ) = TMP1 
                  AB( KFNEW, 2 ) = TMP2 
                  NAB( KFNEW, 1 ) = ITMP1 
                  NAB( KFNEW, 2 ) = ITMP2 
                  IF( IJOB.EQ.3 ) THEN 
                  ITMP1 = NVAL( JI ) 
                  NVAL( JI ) = NVAL( KFNEW ) 
                  NVAL( KFNEW ) = ITMP1 
                  END IF 
            END IF 
            KFNEW = KFNEW + 1 
            END IF 
110    CONTINUE 
      KF = KFNEW 
!                                                                       
!        Choose Midpoints                                               
!                                                                       
      DO 120 JI = KF, KL 
            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) ) 
120    CONTINUE 
!                                                                       
!        If no more intervals to refine, quit.                          
!                                                                       
      IF( KF.GT.KL )                                                 &
&      GO TO 140                                                   
130 END DO 
!                                                                       
!     Converged                                                         
!                                                                       
140 CONTINUE 
      INFO = MAX( KL+1-KF, 0 ) 
      MOUT = KL 
!                                                                       
      RETURN 
!                                                                       
!     End of DLAEBZ                                                     
!                                                                       
      END                                           
!> \brief \b DLAEV2 computes the eigenvalues and eigenvectors of a 2-by-
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAEV2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAEV2( A, B, C, RT1, RT2, CS1, SN1 )                
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION   A, B, C, CS1, RT1, RT2, SN1                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix  
!>    [  A   B  ]                                                       
!>    [  B   C  ].                                                      
!> On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
!> eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
!> eigenvector for RT1, giving the decomposition                        
!>                                                                      
!>    [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]             
!>    [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION                                       
!>          The (1,1) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is DOUBLE PRECISION                                       
!>          The (1,2) element and the conjugate of the (2,1) element of 
!>          the 2-by-2 matrix.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is DOUBLE PRECISION                                       
!>          The (2,2) element of the 2-by-2 matrix.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT1                                                      
!> \verbatim                                                            
!>          RT1 is DOUBLE PRECISION                                     
!>          The eigenvalue of larger absolute value.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RT2                                                      
!> \verbatim                                                            
!>          RT2 is DOUBLE PRECISION                                     
!>          The eigenvalue of smaller absolute value.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] CS1                                                      
!> \verbatim                                                            
!>          CS1 is DOUBLE PRECISION                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SN1                                                      
!> \verbatim                                                            
!>          SN1 is DOUBLE PRECISION                                     
!>          The vector (CS1, SN1) is a unit right eigenvector for RT1.  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  RT1 is accurate to a few ulps barring over/underflow.               
!>                                                                      
!>  RT2 may be inaccurate if there is massive cancellation in the       
!>  determinant A*C-B*B; higher precision or correctly rounded or       
!>  correctly truncated arithmetic would be needed to compute RT2       
!>  accurately in all cases.                                            
!>                                                                      
!>  CS1 and SN1 are accurate to a few ulps barring over/underflow.      
!>                                                                      
!>  Overflow is possible only if RT1 is within a factor of 5 of overflow
!>  Underflow is harmless if the input data is 0 or exceeds             
!>     underflow_threshold / macheps.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLAEV2( A, B, C, RT1, RT2, CS1, SN1 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION   A, B, C, CS1, RT1, RT2, SN1 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D0 ) 
      DOUBLE PRECISION   TWO 
      PARAMETER          ( TWO = 2.0D0 ) 
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
      DOUBLE PRECISION   HALF 
      PARAMETER          ( HALF = 0.5D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            SGN1, SGN2 
      DOUBLE PRECISION   AB, ACMN, ACMX, ACS, ADF, CS, CT, DF, RT, SM,  &
&                   TB, TN                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Compute the eigenvalues                                           
!                                                                       
      SM = A + C 
      DF = A - C 
      ADF = ABS( DF ) 
      TB = B + B 
      AB = ABS( TB ) 
      IF( ABS( A ).GT.ABS( C ) ) THEN 
      ACMX = A 
      ACMN = C 
      ELSE 
      ACMX = C 
      ACMN = A 
      END IF 
      IF( ADF.GT.AB ) THEN 
      RT = ADF*SQRT( ONE+( AB / ADF )**2 ) 
      ELSE IF( ADF.LT.AB ) THEN 
      RT = AB*SQRT( ONE+( ADF / AB )**2 ) 
      ELSE 
!                                                                       
!        Includes case AB=ADF=0                                         
!                                                                       
      RT = AB*SQRT( TWO ) 
      END IF 
      IF( SM.LT.ZERO ) THEN 
      RT1 = HALF*( SM-RT ) 
      SGN1 = -1 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
      RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE IF( SM.GT.ZERO ) THEN 
      RT1 = HALF*( SM+RT ) 
      SGN1 = 1 
!                                                                       
!        Order of execution important.                                  
!        To get fully accurate smaller eigenvalue,                      
!        next line needs to be executed in higher precision.            
!                                                                       
      RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B 
      ELSE 
!                                                                       
!        Includes case RT1 = RT2 = 0                                    
!                                                                       
      RT1 = HALF*RT 
      RT2 = -HALF*RT 
      SGN1 = 1 
      END IF 
!                                                                       
!     Compute the eigenvector                                           
!                                                                       
      IF( DF.GE.ZERO ) THEN 
      CS = DF + RT 
      SGN2 = 1 
      ELSE 
      CS = DF - RT 
      SGN2 = -1 
      END IF 
      ACS = ABS( CS ) 
      IF( ACS.GT.AB ) THEN 
      CT = -TB / CS 
      SN1 = ONE / SQRT( ONE+CT*CT ) 
      CS1 = CT*SN1 
      ELSE 
      IF( AB.EQ.ZERO ) THEN 
            CS1 = ONE 
            SN1 = ZERO 
      ELSE 
            TN = -CS / TB 
            CS1 = ONE / SQRT( ONE+TN*TN ) 
            SN1 = TN*CS1 
      END IF 
      END IF 
      IF( SGN1.EQ.SGN2 ) THEN 
      TN = CS1 
      CS1 = -SN1 
      SN1 = TN 
      END IF 
      RETURN 
!                                                                       
!     End of DLAEV2                                                     
!                                                                       
      END                                           
!> \brief \b DLAGTF computes an LU factorization of a matrix T-λI, wher
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAGTF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO )       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       DOUBLE PRECISION   LAMBDA, TOL                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IN( * )                                      
!       DOUBLE PRECISION   A( * ), B( * ), C( * ), D( * )               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAGTF factorizes the matrix (T - lambda*I), where T is an n by n    
!> tridiagonal matrix and lambda is a scalar, as                        
!>                                                                      
!>    T - lambda*I = PLU,                                               
!>                                                                      
!> where P is a permutation matrix, L is a unit lower tridiagonal matrix
!> with at most one non-zero sub-diagonal elements per column and U is  
!> an upper triangular matrix with at most two non-zero super-diagonal  
!> elements per column.                                                 
!>                                                                      
!> The factorization is obtained by Gaussian elimination with partial   
!> pivoting and implicit row scaling.                                   
!>                                                                      
!> The parameter LAMBDA is included in the routine so that DLAGTF may   
!> be used, in conjunction with DLAGTS, to obtain eigenvectors of T by  
!> inverse iteration.                                                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix T.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, A must contain the diagonal elements of T.        
!>                                                                      
!>          On exit, A is overwritten by the n diagonal elements of the 
!>          upper triangular matrix U of the factorization of T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LAMBDA                                                    
!> \verbatim                                                            
!>          LAMBDA is DOUBLE PRECISION                                  
!>          On entry, the scalar lambda.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] B                                                     
!> \verbatim                                                            
!>          B is DOUBLE PRECISION array, dimension (N-1)                
!>          On entry, B must contain the (n-1) super-diagonal elements o
!>          T.                                                          
!>                                                                      
!>          On exit, B is overwritten by the (n-1) super-diagonal       
!>          elements of the matrix U of the factorization of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (N-1)                
!>          On entry, C must contain the (n-1) sub-diagonal elements of 
!>          T.                                                          
!>                                                                      
!>          On exit, C is overwritten by the (n-1) sub-diagonal elements
!>          of the matrix L of the factorization of T.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TOL                                                       
!> \verbatim                                                            
!>          TOL is DOUBLE PRECISION                                     
!>          On entry, a relative tolerance used to indicate whether or  
!>          not the matrix (T - lambda*I) is nearly singular. TOL should
!>          normally be chose as approximately the largest relative erro
!>          in the elements of T. For example, if the elements of T are 
!>          correct to about 4 significant figures, then TOL should be  
!>          set to about 5*10**(-4). If TOL is supplied as less than eps
!>          where eps is the relative machine precision, then the value 
!>          eps is used in place of TOL.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N-2)                
!>          On exit, D is overwritten by the (n-2) second super-diagonal
!>          elements of the matrix U of the factorization of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IN                                                       
!> \verbatim                                                            
!>          IN is INTEGER array, dimension (N)                          
!>          On exit, IN contains details of the permutation matrix P. If
!>          an interchange occurred at the kth step of the elimination, 
!>          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)      
!>          returns the smallest positive integer j such that           
!>                                                                      
!>             abs( u(j,j) ) <= norm( (T - lambda*I)(j) )*TOL,          
!>                                                                      
!>          where norm( A(j) ) denotes the sum of the absolute values of
!>          the jth row of the matrix A. If no such j exists then IN(n) 
!>          is returned as zero. If IN(n) is returned as positive, then 
!>          diagonal element of U is small, indicating that             
!>          (T - lambda*I) is singular or nearly singular,              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -k, the kth argument had an illegal value   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
      DOUBLE PRECISION   LAMBDA, TOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IN( * ) 
      DOUBLE PRECISION   A( * ), B( * ), C( * ), D( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            K 
      DOUBLE PRECISION   EPS, MULT, PIV1, PIV2, SCALE1, SCALE2, TEMP, TL 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX 
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
      IF( N.LT.0 ) THEN 
      INFO = -1 
      CALL XERBLA( 'DLAGTF', -INFO ) 
      RETURN 
      END IF 
!                                                                       
      IF( N.EQ.0 )                                                      &
&   RETURN                                                         
!                                                                       
      A( 1 ) = A( 1 ) - LAMBDA 
      IN( N ) = 0 
      IF( N.EQ.1 ) THEN 
      IF( A( 1 ).EQ.ZERO )                                           &
&      IN( 1 ) = 1                                                 
      RETURN 
      END IF 
!                                                                       
      EPS = DLAMCH( 'Epsilon' ) 
!                                                                       
      TL = MAX( TOL, EPS ) 
      SCALE1 = ABS( A( 1 ) ) + ABS( B( 1 ) ) 
      DO 10 K = 1, N - 1 
      A( K+1 ) = A( K+1 ) - LAMBDA 
      SCALE2 = ABS( C( K ) ) + ABS( A( K+1 ) ) 
      IF( K.LT.( N-1 ) )                                             &
&      SCALE2 = SCALE2 + ABS( B( K+1 ) )                           
      IF( A( K ).EQ.ZERO ) THEN 
            PIV1 = ZERO 
      ELSE 
            PIV1 = ABS( A( K ) ) / SCALE1 
      END IF 
      IF( C( K ).EQ.ZERO ) THEN 
            IN( K ) = 0 
            PIV2 = ZERO 
            SCALE1 = SCALE2 
            IF( K.LT.( N-1 ) )                                          &
&         D( K ) = ZERO                                            
      ELSE 
            PIV2 = ABS( C( K ) ) / SCALE2 
            IF( PIV2.LE.PIV1 ) THEN 
            IN( K ) = 0 
            SCALE1 = SCALE2 
            C( K ) = C( K ) / A( K ) 
            A( K+1 ) = A( K+1 ) - C( K )*B( K ) 
            IF( K.LT.( N-1 ) )                                       &
&            D( K ) = ZERO                                         
            ELSE 
            IN( K ) = 1 
            MULT = A( K ) / C( K ) 
            A( K ) = C( K ) 
            TEMP = A( K+1 ) 
            A( K+1 ) = B( K ) - MULT*TEMP 
            IF( K.LT.( N-1 ) ) THEN 
                  D( K ) = B( K+1 ) 
                  B( K+1 ) = -MULT*D( K ) 
            END IF 
            B( K ) = TEMP 
            C( K ) = MULT 
            END IF 
      END IF 
      IF( ( MAX( PIV1, PIV2 ).LE.TL ) .AND. ( IN( N ).EQ.0 ) )       &
&      IN( N ) = K                                                 
10 END DO 
      IF( ( ABS( A( N ) ).LE.SCALE1*TL ) .AND. ( IN( N ).EQ.0 ) )       &
&   IN( N ) = N                                                    
!                                                                       
      RETURN 
!                                                                       
!     End of DLAGTF                                                     
!                                                                       
      END                                           
!> \brief \b DLAGTS solves the system of equations (T-λI)x = y or (T-λ
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAGTS + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO )       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, JOB, N                                 
!       DOUBLE PRECISION   TOL                                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IN( * )                                      
!       DOUBLE PRECISION   A( * ), B( * ), C( * ), D( * ), Y( * )       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAGTS may be used to solve one of the systems of equations          
!>                                                                      
!>    (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,              
!>                                                                      
!> where T is an n by n tridiagonal matrix, for x, following the        
!> factorization of (T - lambda*I) as                                   
!>                                                                      
!>    (T - lambda*I) = P*L*U ,                                          
!>                                                                      
!> by routine DLAGTF. The choice of equation to be solved is            
!> controlled by the argument JOB, and in each case there is an option  
!> to perturb zero or very small diagonal elements of U, this option    
!> being intended for use in applications such as inverse iteration.    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOB                                                       
!> \verbatim                                                            
!>          JOB is INTEGER                                              
!>          Specifies the job to be performed by DLAGTS as follows:     
!>          =  1: The equations  (T - lambda*I)x = y  are to be solved, 
!>                but diagonal elements of U are not to be perturbed.   
!>          = -1: The equations  (T - lambda*I)x = y  are to be solved  
!>                and, if overflow would otherwise occur, the diagonal  
!>                elements of U are to be perturbed. See argument TOL   
!>                below.                                                
!>          =  2: The equations  (T - lambda*I)**Tx = y  are to be solve
!>                but diagonal elements of U are not to be perturbed.   
!>          = -2: The equations  (T - lambda*I)**Tx = y  are to be solve
!>                and, if overflow would otherwise occur, the diagonal  
!>                elements of U are to be perturbed. See argument TOL   
!>                below.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix T.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, A must contain the diagonal elements of U as      
!>          returned from DLAGTF.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is DOUBLE PRECISION array, dimension (N-1)                
!>          On entry, B must contain the first super-diagonal elements o
!>          U as returned from DLAGTF.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] C                                                         
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (N-1)                
!>          On entry, C must contain the sub-diagonal elements of L as  
!>          returned from DLAGTF.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N-2)                
!>          On entry, D must contain the second super-diagonal elements 
!>          of U as returned from DLAGTF.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IN                                                        
!> \verbatim                                                            
!>          IN is INTEGER array, dimension (N)                          
!>          On entry, IN must contain details of the matrix P as returne
!>          from DLAGTF.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the right hand side vector y.                     
!>          On exit, Y is overwritten by the solution vector x.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TOL                                                   
!> \verbatim                                                            
!>          TOL is DOUBLE PRECISION                                     
!>          On entry, with  JOB < 0, TOL should be the minimum          
!>          perturbation to be made to very small diagonal elements of U
!>          TOL should normally be chosen as about eps*norm(U), where ep
!>          is the relative machine precision, but if TOL is supplied as
!>          non-positive, then it is reset to eps*max( abs( u(i,j) ) ). 
!>          If  JOB > 0  then TOL is not referenced.                    
!>                                                                      
!>          On exit, TOL is changed as described above, only if TOL is  
!>          non-positive on entry. Otherwise TOL is unchanged.          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  overflow would occur when computing the INFO(th)      
!>                element of the solution vector x. This can only occur 
!>                when JOB is supplied as positive and either means     
!>                that a diagonal element of U is very small, or that   
!>                the elements of the right-hand side vector y are very 
!>                large.                                                
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, JOB, N 
      DOUBLE PRECISION   TOL 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IN( * ) 
      DOUBLE PRECISION   A( * ), B( * ), C( * ), D( * ), Y( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            K 
      DOUBLE PRECISION   ABSAK, AK, BIGNUM, EPS, PERT, SFMIN, TEMP 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SIGN 
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
      IF( ( ABS( JOB ).GT.2 ) .OR. ( JOB.EQ.0 ) ) THEN 
      INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -2 
      END IF 
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DLAGTS', -INFO ) 
      RETURN 
      END IF 
!                                                                       
      IF( N.EQ.0 )                                                      &
&   RETURN                                                         
!                                                                       
      EPS = DLAMCH( 'Epsilon' ) 
      SFMIN = DLAMCH( 'Safe minimum' ) 
      BIGNUM = ONE / SFMIN 
!                                                                       
      IF( JOB.LT.0 ) THEN 
      IF( TOL.LE.ZERO ) THEN 
            TOL = ABS( A( 1 ) ) 
            IF( N.GT.1 )                                                &
&         TOL = MAX( TOL, ABS( A( 2 ) ), ABS( B( 1 ) ) )           
            DO 10 K = 3, N 
            TOL = MAX( TOL, ABS( A( K ) ), ABS( B( K-1 ) ),          &
&               ABS( D( K-2 ) ) )                                  
10       CONTINUE 
            TOL = TOL*EPS 
            IF( TOL.EQ.ZERO )                                           &
&         TOL = EPS                                                
      END IF 
      END IF 
!                                                                       
      IF( ABS( JOB ).EQ.1 ) THEN 
      DO 20 K = 2, N 
            IF( IN( K-1 ).EQ.0 ) THEN 
            Y( K ) = Y( K ) - C( K-1 )*Y( K-1 ) 
            ELSE 
            TEMP = Y( K-1 ) 
            Y( K-1 ) = Y( K ) 
            Y( K ) = TEMP - C( K-1 )*Y( K ) 
            END IF 
20    CONTINUE 
      IF( JOB.EQ.1 ) THEN 
            DO 30 K = N, 1, -1 
            IF( K.LE.N-2 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 ) 
            ELSE IF( K.EQ.N-1 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) 
            ELSE 
                  TEMP = Y( K ) 
            END IF 
            AK = A( K ) 
            ABSAK = ABS( AK ) 
            IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                  IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
&                    THEN                                          
                        INFO = K 
                        RETURN 
                  ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                  END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                  INFO = K 
                  RETURN 
                  END IF 
            END IF 
            Y( K ) = TEMP / AK 
30       CONTINUE 
      ELSE 
            DO 50 K = N, 1, -1 
            IF( K.LE.N-2 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 ) 
            ELSE IF( K.EQ.N-1 ) THEN 
                  TEMP = Y( K ) - B( K )*Y( K+1 ) 
            ELSE 
                  TEMP = Y( K ) 
            END IF 
            AK = A( K ) 
            PERT = SIGN( TOL, AK ) 
40          CONTINUE 
            ABSAK = ABS( AK ) 
            IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                  IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
&                    THEN                                          
                        AK = AK + PERT 
                        PERT = 2*PERT 
                        GO TO 40 
                  ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                  END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                  AK = AK + PERT 
                  PERT = 2*PERT 
                  GO TO 40 
                  END IF 
            END IF 
            Y( K ) = TEMP / AK 
50       CONTINUE 
      END IF 
      ELSE 
!                                                                       
!        Come to here if  JOB = 2 or -2                                 
!                                                                       
      IF( JOB.EQ.2 ) THEN 
            DO 60 K = 1, N 
            IF( K.GE.3 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 ) 
            ELSE IF( K.EQ.2 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) 
            ELSE 
                  TEMP = Y( K ) 
            END IF 
            AK = A( K ) 
            ABSAK = ABS( AK ) 
            IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                  IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
&                    THEN                                          
                        INFO = K 
                        RETURN 
                  ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                  END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                  INFO = K 
                  RETURN 
                  END IF 
            END IF 
            Y( K ) = TEMP / AK 
60       CONTINUE 
      ELSE 
            DO 80 K = 1, N 
            IF( K.GE.3 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 ) 
            ELSE IF( K.EQ.2 ) THEN 
                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) 
            ELSE 
                  TEMP = Y( K ) 
            END IF 
            AK = A( K ) 
            PERT = SIGN( TOL, AK ) 
70          CONTINUE 
            ABSAK = ABS( AK ) 
            IF( ABSAK.LT.ONE ) THEN 
                  IF( ABSAK.LT.SFMIN ) THEN 
                  IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )&
&                    THEN                                          
                        AK = AK + PERT 
                        PERT = 2*PERT 
                        GO TO 70 
                  ELSE 
                        TEMP = TEMP*BIGNUM 
                        AK = AK*BIGNUM 
                  END IF 
                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN 
                  AK = AK + PERT 
                  PERT = 2*PERT 
                  GO TO 70 
                  END IF 
            END IF 
            Y( K ) = TEMP / AK 
80       CONTINUE 
      END IF 
!                                                                       
      DO 90 K = N, 2, -1 
            IF( IN( K-1 ).EQ.0 ) THEN 
            Y( K-1 ) = Y( K-1 ) - C( K-1 )*Y( K ) 
            ELSE 
            TEMP = Y( K-1 ) 
            Y( K-1 ) = Y( K ) 
            Y( K ) = TEMP - C( K-1 )*Y( K ) 
            END IF 
90    CONTINUE 
      END IF 
!                                                                       
!     End of DLAGTS                                                     
!                                                                       
      END                                           
!> \brief \b DLAISNAN tests input for NaN by comparing two arguments for
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAISNAN + dependencies                                     
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION DLAISNAN( DIN1, DIN2 )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION, INTENT(IN) :: DIN1, DIN2                      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> This routine is not for general use.  It exists solely to avoid      
!> over-optimization in DISNAN.                                         
!>                                                                      
!> DLAISNAN checks for NaNs by comparing its two arguments for          
!> inequality.  NaN is the only floating-point value where NaN != NaN   
!> returns .TRUE.  To check for NaNs, pass the same variable as both    
!> arguments.                                                           
!>                                                                      
!> A compiler must assume that the two arguments are                    
!> not the same variable, and the test will not be optimized away.      
!> Interprocedural or whole-program optimization may delete this        
!> test.  The ISNAN functions will be replaced by the correct           
!> Fortran 03 intrinsic once the intrinsic is widely available.         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] DIN1                                                      
!> \verbatim                                                            
!>          DIN1 is DOUBLE PRECISION                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIN2                                                      
!> \verbatim                                                            
!>          DIN2 is DOUBLE PRECISION                                    
!>          Two numbers to compare for inequality.                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION DLAISNAN( DIN1, DIN2 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION, INTENT(IN) :: DIN1, DIN2 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!  .. Executable Statements ..                                          
      DLAISNAN = (DIN1.NE.DIN2) 
      RETURN 
      END                                           
!> \brief \b DLANEG computes the Sturm count.                           
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLANEG + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION DLANEG( N, D, LLD, SIGMA, PIVMIN, R )          
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N, R                                         
!       DOUBLE PRECISION   PIVMIN, SIGMA                                
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), LLD( * )                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLANEG computes the Sturm count, the number of negative pivots       
!> encountered while factoring tridiagonal T - sigma I = L D L^T.       
!> This implementation works directly on the factors without forming    
!> the tridiagonal matrix T.  The Sturm count is also the number of     
!> eigenvalues of T less than sigma.                                    
!>                                                                      
!> This routine is called from DLARRB.                                  
!>                                                                      
!> The current routine does not use the PIVMIN parameter but rather     
!> requires IEEE-754 propagation of Infinities and NaNs.  This          
!> routine also has no input range restrictions but does require        
!> default exception handling such that x/0 produces Inf when x is      
!> non-zero, and Inf/Inf produces NaN.  For more information, see:      
!>                                                                      
!>   Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in      
!>   Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on        
!>   Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624        
!>   (Tech report version in LAWN 172 with the same title.)             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is DOUBLE PRECISION array, dimension (N-1)              
!>          The (N-1) elements L(i)*L(i)*D(i).                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SIGMA                                                     
!> \verbatim                                                            
!>          SIGMA is DOUBLE PRECISION                                   
!>          Shift amount in T - sigma I = L D L^T.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot in the Sturm sequence.  May be used       
!>          when zero pivots are encountered on non-IEEE-754            
!>          architectures.                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] R                                                         
!> \verbatim                                                            
!>          R is INTEGER                                                
!>          The twist index for the twisted factorization that is used  
!>          for the negcount.                                           
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!>     Jason Riedy, University of California, Berkeley, USA \n          
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION DLANEG( N, D, LLD, SIGMA, PIVMIN, R ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N, R 
      DOUBLE PRECISION   PIVMIN, SIGMA 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), LLD( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE 
      PARAMETER        ( ZERO = 0.0D0, ONE = 1.0D0 ) 
!     Some architectures propagate Infinities and NaNs very slowly, so  
!     the code computes counts in BLKLEN chunks.  Then a NaN can        
!     propagate at most BLKLEN columns before being detected.  This is  
!     not a general tuning parameter; it needs only to be just large    
!     enough that the overhead is tiny in common cases.                 
      INTEGER BLKLEN 
      PARAMETER ( BLKLEN = 128 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            BJ, J, NEG1, NEG2, NEGCNT 
      DOUBLE PRECISION   BSAV, DMINUS, DPLUS, GAMMA, P, T, TMP 
      LOGICAL SAWNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MIN, MAX 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL DISNAN 
      EXTERNAL DISNAN 
!     ..                                                                
!     .. Executable Statements ..                                       
                                                                        
      NEGCNT = 0 
                                                                        
!     I) upper part: L D L^T - SIGMA I = L+ D+ L+^T                     
      T = -SIGMA 
      DO 210 BJ = 1, R-1, BLKLEN 
      NEG1 = 0 
      BSAV = T 
      DO 21 J = BJ, MIN(BJ+BLKLEN-1, R-1) 
            DPLUS = D( J ) + T 
            IF( DPLUS.LT.ZERO ) NEG1 = NEG1 + 1 
            TMP = T / DPLUS 
            T = TMP * LLD( J ) - SIGMA 
21    CONTINUE 
      SAWNAN = DISNAN( T ) 
!     Run a slower version of the above loop if a NaN is detected.      
!     A NaN should occur only with a zero pivot after an infinite       
!     pivot.  In that case, substituting 1 for T/DPLUS is the           
!     correct limit.                                                    
      IF( SAWNAN ) THEN 
            NEG1 = 0 
            T = BSAV 
            DO 22 J = BJ, MIN(BJ+BLKLEN-1, R-1) 
            DPLUS = D( J ) + T 
            IF( DPLUS.LT.ZERO ) NEG1 = NEG1 + 1 
            TMP = T / DPLUS 
            IF (DISNAN(TMP)) TMP = ONE 
            T = TMP * LLD(J) - SIGMA 
22       CONTINUE 
      END IF 
      NEGCNT = NEGCNT + NEG1 
210 END DO 
!                                                                       
!     II) lower part: L D L^T - SIGMA I = U- D- U-^T                    
      P = D( N ) - SIGMA 
      DO 230 BJ = N-1, R, -BLKLEN 
      NEG2 = 0 
      BSAV = P 
      DO 23 J = BJ, MAX(BJ-BLKLEN+1, R), -1 
            DMINUS = LLD( J ) + P 
            IF( DMINUS.LT.ZERO ) NEG2 = NEG2 + 1 
            TMP = P / DMINUS 
            P = TMP * D( J ) - SIGMA 
23    CONTINUE 
      SAWNAN = DISNAN( P ) 
!     As above, run a slower version that substitutes 1 for Inf/Inf.    
!                                                                       
      IF( SAWNAN ) THEN 
            NEG2 = 0 
            P = BSAV 
            DO 24 J = BJ, MAX(BJ-BLKLEN+1, R), -1 
            DMINUS = LLD( J ) + P 
            IF( DMINUS.LT.ZERO ) NEG2 = NEG2 + 1 
            TMP = P / DMINUS 
            IF (DISNAN(TMP)) TMP = ONE 
            P = TMP * D(J) - SIGMA 
24       CONTINUE 
      END IF 
      NEGCNT = NEGCNT + NEG2 
230 END DO 
!                                                                       
!     III) Twist index                                                  
!       T was shifted by SIGMA initially.                               
      GAMMA = (T + SIGMA) + P 
      IF( GAMMA.LT.ZERO ) NEGCNT = NEGCNT+1 
                                                                        
      DLANEG = NEGCNT 
      END                                           
!> \brief \b DLANST returns the value of the 1-norm, or the Frobenius no
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLANST + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       DOUBLE PRECISION FUNCTION DLANST( NORM, N, D, E )               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          NORM                                         
!       INTEGER            N                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLANST  returns the value of the one norm,  or the Frobenius norm, or
!> the  infinity norm,  or the  element of  largest absolute value  of a
!> real symmetric tridiagonal matrix A.                                 
!> \endverbatim                                                         
!>                                                                      
!> \return DLANST                                                       
!> \verbatim                                                            
!>                                                                      
!>    DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'                    
!>             (                                                        
!>             ( norm1(A),         NORM = '1', 'O' or 'o'               
!>             (                                                        
!>             ( normI(A),         NORM = 'I' or 'i'                    
!>             (                                                        
!>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'          
!>                                                                      
!> where  norm1  denotes the  one norm of a matrix (maximum column sum),
!> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!> normF  denotes the  Frobenius norm of a matrix (square root of sum of
!> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix no
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] NORM                                                      
!> \verbatim                                                            
!>          NORM is CHARACTER*1                                         
!>          Specifies the value to be returned in DLANST as described   
!>          above.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.  When N = 0, DLANST is  
!>          set to zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The diagonal elements of A.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The (n-1) sub-diagonal or super-diagonal elements of A.     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      DOUBLE PRECISION FUNCTION DLANST( NORM, N, D, E ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          NORM 
      INTEGER            N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      DOUBLE PRECISION   ANORM, SCALE, SUM 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, DISNAN 
      EXTERNAL           LSAME, DISNAN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLASSQ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.0 ) THEN 
      ANORM = ZERO 
      ELSE IF( LSAME( NORM, 'M' ) ) THEN 
!                                                                       
!        Find max(abs(A(i,j))).                                         
!                                                                       
      ANORM = ABS( D( N ) ) 
      DO 10 I = 1, N - 1 
            SUM = ABS( D( I ) ) 
            IF( ANORM .LT. SUM .OR. DISNAN( SUM ) ) ANORM = SUM 
            SUM = ABS( E( I ) ) 
            IF( ANORM .LT. SUM .OR. DISNAN( SUM ) ) ANORM = SUM 
10    CONTINUE 
      ELSE IF( LSAME( NORM, 'O' ) .OR. NORM.EQ.'1' .OR.                 &
&         LSAME( NORM, 'I' ) ) THEN                                
!                                                                       
!        Find norm1(A).                                                 
!                                                                       
      IF( N.EQ.1 ) THEN 
            ANORM = ABS( D( 1 ) ) 
      ELSE 
            ANORM = ABS( D( 1 ) )+ABS( E( 1 ) ) 
            SUM = ABS( E( N-1 ) )+ABS( D( N ) ) 
            IF( ANORM .LT. SUM .OR. DISNAN( SUM ) ) ANORM = SUM 
            DO 20 I = 2, N - 1 
            SUM = ABS( D( I ) )+ABS( E( I ) )+ABS( E( I-1 ) ) 
            IF( ANORM .LT. SUM .OR. DISNAN( SUM ) ) ANORM = SUM 
20       CONTINUE 
      END IF 
      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN 
!                                                                       
!        Find normF(A).                                                 
!                                                                       
      SCALE = ZERO 
      SUM = ONE 
      IF( N.GT.1 ) THEN 
            CALL DLASSQ( N-1, E, 1, SCALE, SUM ) 
            SUM = 2*SUM 
      END IF 
      CALL DLASSQ( N, D, 1, SCALE, SUM ) 
      ANORM = SCALE*SQRT( SUM ) 
      END IF 
!                                                                       
      DLANST = ANORM 
      RETURN 
!                                                                       
!     End of DLANST                                                     
!                                                                       
      END                                           
!> \brief \b DLANSY returns the value of the 1-norm, or the Frobenius no
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLANSY + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       DOUBLE PRECISION FUNCTION DLANSY( NORM, UPLO, N, A, LDA, WORK ) 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          NORM, UPLO                                   
!       INTEGER            LDA, N                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), WORK( * )                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLANSY  returns the value of the one norm,  or the Frobenius norm, or
!> the  infinity norm,  or the  element of  largest absolute value  of a
!> real symmetric matrix A.                                             
!> \endverbatim                                                         
!>                                                                      
!> \return DLANSY                                                       
!> \verbatim                                                            
!>                                                                      
!>    DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'                    
!>             (                                                        
!>             ( norm1(A),         NORM = '1', 'O' or 'o'               
!>             (                                                        
!>             ( normI(A),         NORM = 'I' or 'i'                    
!>             (                                                        
!>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'          
!>                                                                      
!> where  norm1  denotes the  one norm of a matrix (maximum column sum),
!> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!> normF  denotes the  Frobenius norm of a matrix (square root of sum of
!> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix no
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] NORM                                                      
!> \verbatim                                                            
!>          NORM is CHARACTER*1                                         
!>          Specifies the value to be returned in DLANSY as described   
!>          above.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is to be referenced.                     
!>          = 'U':  Upper triangular part of A is referenced            
!>          = 'L':  Lower triangular part of A is referenced            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.  When N = 0, DLANSY is  
!>          set to zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          The symmetric matrix A.  If UPLO = 'U', the leading n by n  
!>          upper triangular part of A contains the upper triangular par
!>          of the matrix A, and the strictly lower triangular part of A
!>          is not referenced.  If UPLO = 'L', the leading n by n lower 
!>          triangular part of A contains the lower triangular part of  
!>          the matrix A, and the strictly upper triangular part of A is
!>          not referenced.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(N,1).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),   
!>          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,  
!>          WORK is not referenced.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleSYauxiliary                                           
!                                                                       
!  =====================================================================
      DOUBLE PRECISION FUNCTION DLANSY( NORM, UPLO, N, A, LDA, WORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
      IMPLICIT NONE 
!     .. Scalar Arguments ..                                            
      CHARACTER          NORM, UPLO 
      INTEGER            LDA, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), WORK( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J 
      DOUBLE PRECISION   ABSA, SUM, VALUE 
!     ..                                                                
!     .. Local Arrays ..                                                
      DOUBLE PRECISION   SSQ( 2 ), COLSSQ( 2 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, DISNAN 
      EXTERNAL           LSAME, DISNAN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLASSQ, DCOMBSSQ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.EQ.0 ) THEN 
      VALUE = ZERO 
      ELSE IF( LSAME( NORM, 'M' ) ) THEN 
!                                                                       
!        Find max(abs(A(i,j))).                                         
!                                                                       
      VALUE = ZERO 
      IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 20 J = 1, N 
            DO 10 I = 1, J 
                  SUM = ABS( A( I, J ) ) 
                  IF( VALUE .LT. SUM .OR. DISNAN( SUM ) ) VALUE = SUM 
10          CONTINUE 
20       CONTINUE 
      ELSE 
            DO 40 J = 1, N 
            DO 30 I = J, N 
                  SUM = ABS( A( I, J ) ) 
                  IF( VALUE .LT. SUM .OR. DISNAN( SUM ) ) VALUE = SUM 
30          CONTINUE 
40       CONTINUE 
      END IF 
      ELSE IF( ( LSAME( NORM, 'I' ) ) .OR. ( LSAME( NORM, 'O' ) ) .OR.  &
&         ( NORM.EQ.'1' ) ) THEN                                   
!                                                                       
!        Find normI(A) ( = norm1(A), since A is symmetric).             
!                                                                       
      VALUE = ZERO 
      IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 60 J = 1, N 
            SUM = ZERO 
            DO 50 I = 1, J - 1 
                  ABSA = ABS( A( I, J ) ) 
                  SUM = SUM + ABSA 
                  WORK( I ) = WORK( I ) + ABSA 
50          CONTINUE 
            WORK( J ) = SUM + ABS( A( J, J ) ) 
60       CONTINUE 
            DO 70 I = 1, N 
            SUM = WORK( I ) 
            IF( VALUE .LT. SUM .OR. DISNAN( SUM ) ) VALUE = SUM 
70       CONTINUE 
      ELSE 
            DO 80 I = 1, N 
            WORK( I ) = ZERO 
80       CONTINUE 
            DO 100 J = 1, N 
            SUM = WORK( J ) + ABS( A( J, J ) ) 
            DO 90 I = J + 1, N 
                  ABSA = ABS( A( I, J ) ) 
                  SUM = SUM + ABSA 
                  WORK( I ) = WORK( I ) + ABSA 
90          CONTINUE 
            IF( VALUE .LT. SUM .OR. DISNAN( SUM ) ) VALUE = SUM 
100       CONTINUE 
      END IF 
      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN 
!                                                                       
!        Find normF(A).                                                 
!        SSQ(1) is scale                                                
!        SSQ(2) is sum-of-squares                                       
!        For better accuracy, sum each column separately.               
!                                                                       
      SSQ( 1 ) = ZERO 
      SSQ( 2 ) = ONE 
!                                                                       
!        Sum off-diagonals                                              
!                                                                       
      IF( LSAME( UPLO, 'U' ) ) THEN 
            DO 110 J = 2, N 
            COLSSQ( 1 ) = ZERO 
            COLSSQ( 2 ) = ONE 
            CALL DLASSQ( J-1, A( 1, J ), 1, COLSSQ(1), COLSSQ(2) ) 
            CALL DCOMBSSQ( SSQ, COLSSQ ) 
110       CONTINUE 
      ELSE 
            DO 120 J = 1, N - 1 
            COLSSQ( 1 ) = ZERO 
            COLSSQ( 2 ) = ONE 
            CALL DLASSQ( N-J, A( J+1, J ), 1, COLSSQ(1), COLSSQ(2) ) 
            CALL DCOMBSSQ( SSQ, COLSSQ ) 
120       CONTINUE 
      END IF 
      SSQ( 2 ) = 2*SSQ( 2 ) 
!                                                                       
!        Sum diagonal                                                   
!                                                                       
      COLSSQ( 1 ) = ZERO 
      COLSSQ( 2 ) = ONE 
      CALL DLASSQ( N, A, LDA+1, COLSSQ( 1 ), COLSSQ( 2 ) ) 
      CALL DCOMBSSQ( SSQ, COLSSQ ) 
      VALUE = SSQ( 1 )*SQRT( SSQ( 2 ) ) 
      END IF 
!                                                                       
      DLANSY = VALUE 
      RETURN 
!                                                                       
!     End of DLANSY                                                     
!                                                                       
      END                                           
!> \brief \b DLAPY2 returns sqrt(x2+y2).                                
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAPY2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       DOUBLE PRECISION FUNCTION DLAPY2( X, Y )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION   X, Y                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary 
!> overflow.                                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION                                       
!>          X and Y specify the values x and y.                         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      DOUBLE PRECISION FUNCTION DLAPY2( X, Y ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION   X, Y 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION   W, XABS, YABS, Z 
      LOGICAL            X_IS_NAN, Y_IS_NAN 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            DISNAN 
      EXTERNAL           DISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      X_IS_NAN = DISNAN( X ) 
      Y_IS_NAN = DISNAN( Y ) 
      IF ( X_IS_NAN ) DLAPY2 = X 
      IF ( Y_IS_NAN ) DLAPY2 = Y 
!                                                                       
      IF ( .NOT.( X_IS_NAN.OR.Y_IS_NAN ) ) THEN 
      XABS = ABS( X ) 
      YABS = ABS( Y ) 
      W = MAX( XABS, YABS ) 
      Z = MIN( XABS, YABS ) 
      IF( Z.EQ.ZERO ) THEN 
            DLAPY2 = W 
      ELSE 
            DLAPY2 = W*SQRT( ONE+( Z / W )**2 ) 
      END IF 
      END IF 
      RETURN 
!                                                                       
!     End of DLAPY2                                                     
!                                                                       
!> \brief \b DLAR1V computes the (scaled) r-th column of the inverse of 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLAR1V + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLAR1V( N, B1, BN, LAMBDA, D, L, LD, LLD,            
!                  PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA,      
!                  R, ISUPPZ, NRMINV, RESID, RQCORR, WORK )             
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            WANTNC                                       
!       INTEGER   B1, BN, N, NEGCNT, R                                  
!       DOUBLE PRECISION   GAPTOL, LAMBDA, MINGMA, NRMINV, PIVMIN, RESID
!      $                   RQCORR, ZTZ                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * )                                  
!       DOUBLE PRECISION   D( * ), L( * ), LD( * ), LLD( * ),           
!      $                  WORK( * )                                     
!       DOUBLE PRECISION Z( * )                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAR1V computes the (scaled) r-th column of the inverse of           
!> the sumbmatrix in rows B1 through BN of the tridiagonal matrix       
!> L D L**T - sigma I. When sigma is close to an eigenvalue, the        
!> computed vector is an accurate eigenvector. Usually, r corresponds   
!> to the index where the eigenvector is largest in magnitude.          
!> The following steps accomplish this computation :                    
!> (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
!> (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
!> (c) Computation of the diagonal elements of the inverse of           
!>     L D L**T - sigma I by combining the above transforms, and choosin
!>     r as the index where the diagonal of the inverse is (one of the) 
!>     largest in magnitude.                                            
!> (d) Computation of the (scaled) r-th column of the inverse using the 
!>     twisted factorization obtained by combining the top part of the  
!>     the stationary and the bottom part of the progressive transform. 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           The order of the matrix L D L**T.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B1                                                        
!> \verbatim                                                            
!>          B1 is INTEGER                                               
!>           First index of the submatrix of L D L**T.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BN                                                        
!> \verbatim                                                            
!>          BN is INTEGER                                               
!>           Last index of the submatrix of L D L**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LAMBDA                                                    
!> \verbatim                                                            
!>          LAMBDA is DOUBLE PRECISION                                  
!>           The shift. In order to compute an accurate eigenvector,    
!>           LAMBDA should be a good approximation to an eigenvalue     
!>           of L D L**T.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] L                                                         
!> \verbatim                                                            
!>          L is DOUBLE PRECISION array, dimension (N-1)                
!>           The (n-1) subdiagonal elements of the unit bidiagonal matri
!>           L, in elements 1 to N-1.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>           The n diagonal elements of the diagonal matrix D.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LD                                                        
!> \verbatim                                                            
!>          LD is DOUBLE PRECISION array, dimension (N-1)               
!>           The n-1 elements L(i)*D(i).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is DOUBLE PRECISION array, dimension (N-1)              
!>           The n-1 elements L(i)*L(i)*D(i).                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>           The minimum pivot in the Sturm sequence.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GAPTOL                                                    
!> \verbatim                                                            
!>          GAPTOL is DOUBLE PRECISION                                  
!>           Tolerance that indicates when eigenvector entries are negli
!>           w.r.t. their contribution to the residual.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension (N)                  
!>           On input, all entries of Z must be set to 0.               
!>           On output, Z contains the (scaled) r-th column of the      
!>           inverse. The scaling is such that Z(R) equals 1.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] WANTNC                                                    
!> \verbatim                                                            
!>          WANTNC is LOGICAL                                           
!>           Specifies whether NEGCNT has to be computed.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NEGCNT                                                   
!> \verbatim                                                            
!>          NEGCNT is INTEGER                                           
!>           If WANTNC is .TRUE. then NEGCNT = the number of pivots < pi
!>           in the  matrix factorization L D L**T, and NEGCNT = -1 othe
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ZTZ                                                      
!> \verbatim                                                            
!>          ZTZ is DOUBLE PRECISION                                     
!>           The square of the 2-norm of Z.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] MINGMA                                                   
!> \verbatim                                                            
!>          MINGMA is DOUBLE PRECISION                                  
!>           The reciprocal of the largest (in magnitude) diagonal      
!>           element of the inverse of L D L**T - sigma I.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] R                                                     
!> \verbatim                                                            
!>          R is INTEGER                                                
!>           The twist index for the twisted factorization used to      
!>           compute Z.                                                 
!>           On input, 0 <= R <= N. If R is input as 0, R is set to     
!>           the index where (L D L**T - sigma I)^{-1} is largest       
!>           in magnitude. If 1 <= R <= N, R is unchanged.              
!>           On output, R contains the twist index used to compute Z.   
!>           Ideally, R designates the position of the maximum entry in 
!>           eigenvector.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension (2)                      
!>           The support of the vector in Z, i.e., the vector Z is      
!>           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NRMINV                                                   
!> \verbatim                                                            
!>          NRMINV is DOUBLE PRECISION                                  
!>           NRMINV = 1/SQRT( ZTZ )                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RESID                                                    
!> \verbatim                                                            
!>          RESID is DOUBLE PRECISION                                   
!>           The residual of the FP vector.                             
!>           RESID = ABS( MINGMA )/SQRT( ZTZ )                          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RQCORR                                                   
!> \verbatim                                                            
!>          RQCORR is DOUBLE PRECISION                                  
!>           The Rayleigh Quotient correction to LAMBDA.                
!>           RQCORR = MINGMA*TMP                                        
!> \endverbatim                                                         
!>                                                                      
      END                                           
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (4*N)             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLAR1V( N, B1, BN, LAMBDA, D, L, LD, LLD,              &
&           PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA,        &
&           R, ISUPPZ, NRMINV, RESID, RQCORR, WORK )               
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            WANTNC 
      INTEGER   B1, BN, N, NEGCNT, R 
      DOUBLE PRECISION   GAPTOL, LAMBDA, MINGMA, NRMINV, PIVMIN, RESID, &
&                   RQCORR, ZTZ                                    
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ) 
      DOUBLE PRECISION   D( * ), L( * ), LD( * ), LLD( * ),             &
&                  WORK( * )                                       
      DOUBLE PRECISION Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 ) 
                                                                        
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            SAWNAN1, SAWNAN2 
      INTEGER            I, INDLPL, INDP, INDS, INDUMN, NEG1, NEG2, R1, &
&                   R2                                             
      DOUBLE PRECISION   DMINUS, DPLUS, EPS, S, TMP 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL DISNAN 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DISNAN, DLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      EPS = DLAMCH( 'Precision' ) 
                                                                        
                                                                        
      IF( R.EQ.0 ) THEN 
      R1 = B1 
      R2 = BN 
      ELSE 
      R1 = R 
      R2 = R 
      END IF 
                                                                        
!     Storage for LPLUS                                                 
      INDLPL = 0 
!     Storage for UMINUS                                                
      INDUMN = N 
      INDS = 2*N + 1 
      INDP = 3*N + 1 
                                                                        
      IF( B1.EQ.1 ) THEN 
      WORK( INDS ) = ZERO 
      ELSE 
      WORK( INDS+B1-1 ) = LLD( B1-1 ) 
      END IF 
                                                                        
!                                                                       
!     Compute the stationary transform (using the differential form)    
!     until the index R2.                                               
!                                                                       
      SAWNAN1 = .FALSE. 
      NEG1 = 0 
      S = WORK( INDS+B1-1 ) - LAMBDA 
      DO 50 I = B1, R1 - 1 
      DPLUS = D( I ) + S 
      WORK( INDLPL+I ) = LD( I ) / DPLUS 
      IF(DPLUS.LT.ZERO) NEG1 = NEG1 + 1 
      WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
      S = WORK( INDS+I ) - LAMBDA 
50 END DO 
      SAWNAN1 = DISNAN( S ) 
      IF( SAWNAN1 ) GOTO 60 
      DO 51 I = R1, R2 - 1 
      DPLUS = D( I ) + S 
      WORK( INDLPL+I ) = LD( I ) / DPLUS 
      WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
      S = WORK( INDS+I ) - LAMBDA 
51 END DO 
      SAWNAN1 = DISNAN( S ) 
!                                                                       
60 CONTINUE 
      IF( SAWNAN1 ) THEN 
!        Runs a slower version of the above loop if a NaN is detected   
      NEG1 = 0 
      S = WORK( INDS+B1-1 ) - LAMBDA 
      DO 70 I = B1, R1 - 1 
            DPLUS = D( I ) + S 
            IF(ABS(DPLUS).LT.PIVMIN) DPLUS = -PIVMIN 
            WORK( INDLPL+I ) = LD( I ) / DPLUS 
            IF(DPLUS.LT.ZERO) NEG1 = NEG1 + 1 
            WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
            IF( WORK( INDLPL+I ).EQ.ZERO )                              &
&                      WORK( INDS+I ) = LLD( I )                   
            S = WORK( INDS+I ) - LAMBDA 
70    CONTINUE 
      DO 71 I = R1, R2 - 1 
            DPLUS = D( I ) + S 
            IF(ABS(DPLUS).LT.PIVMIN) DPLUS = -PIVMIN 
            WORK( INDLPL+I ) = LD( I ) / DPLUS 
            WORK( INDS+I ) = S*WORK( INDLPL+I )*L( I ) 
            IF( WORK( INDLPL+I ).EQ.ZERO )                              &
&                      WORK( INDS+I ) = LLD( I )                   
            S = WORK( INDS+I ) - LAMBDA 
71    CONTINUE 
      END IF 
!                                                                       
!     Compute the progressive transform (using the differential form)   
!     until the index R1                                                
!                                                                       
      SAWNAN2 = .FALSE. 
      NEG2 = 0 
      WORK( INDP+BN-1 ) = D( BN ) - LAMBDA 
      DO 80 I = BN - 1, R1, -1 
      DMINUS = LLD( I ) + WORK( INDP+I ) 
      TMP = D( I ) / DMINUS 
      IF(DMINUS.LT.ZERO) NEG2 = NEG2 + 1 
      WORK( INDUMN+I ) = L( I )*TMP 
      WORK( INDP+I-1 ) = WORK( INDP+I )*TMP - LAMBDA 
80 END DO 
      TMP = WORK( INDP+R1-1 ) 
      SAWNAN2 = DISNAN( TMP ) 
                                                                        
      IF( SAWNAN2 ) THEN 
!        Runs a slower version of the above loop if a NaN is detected   
      NEG2 = 0 
      DO 100 I = BN-1, R1, -1 
            DMINUS = LLD( I ) + WORK( INDP+I ) 
            IF(ABS(DMINUS).LT.PIVMIN) DMINUS = -PIVMIN 
            TMP = D( I ) / DMINUS 
            IF(DMINUS.LT.ZERO) NEG2 = NEG2 + 1 
            WORK( INDUMN+I ) = L( I )*TMP 
            WORK( INDP+I-1 ) = WORK( INDP+I )*TMP - LAMBDA 
            IF( TMP.EQ.ZERO )                                           &
&          WORK( INDP+I-1 ) = D( I ) - LAMBDA                      
100    CONTINUE 
      END IF 
!                                                                       
!     Find the index (from R1 to R2) of the largest (in magnitude)      
!     diagonal element of the inverse                                   
!                                                                       
      MINGMA = WORK( INDS+R1-1 ) + WORK( INDP+R1-1 ) 
      IF( MINGMA.LT.ZERO ) NEG1 = NEG1 + 1 
      IF( WANTNC ) THEN 
      NEGCNT = NEG1 + NEG2 
      ELSE 
      NEGCNT = -1 
      ENDIF 
      IF( ABS(MINGMA).EQ.ZERO )                                         &
&   MINGMA = EPS*WORK( INDS+R1-1 )                                 
      R = R1 
      DO 110 I = R1, R2 - 1 
      TMP = WORK( INDS+I ) + WORK( INDP+I ) 
      IF( TMP.EQ.ZERO )                                              &
&      TMP = EPS*WORK( INDS+I )                                    
      IF( ABS( TMP ).LE.ABS( MINGMA ) ) THEN 
            MINGMA = TMP 
            R = I + 1 
      END IF 
110 END DO 
!                                                                       
!     Compute the FP vector: solve N^T v = e_r                          
!                                                                       
      ISUPPZ( 1 ) = B1 
      ISUPPZ( 2 ) = BN 
      Z( R ) = ONE 
      ZTZ = ONE 
!                                                                       
!     Compute the FP vector upwards from R                              
!                                                                       
      IF( .NOT.SAWNAN1 .AND. .NOT.SAWNAN2 ) THEN 
      DO 210 I = R-1, B1, -1 
            Z( I ) = -( WORK( INDLPL+I )*Z( I+1 ) ) 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
&           THEN                                                   
            Z( I ) = ZERO 
            ISUPPZ( 1 ) = I + 1 
            GOTO 220 
            ENDIF 
            ZTZ = ZTZ + Z( I )*Z( I ) 
210    CONTINUE 
220    CONTINUE 
      ELSE 
!        Run slower loop if NaN occurred.                               
      DO 230 I = R - 1, B1, -1 
            IF( Z( I+1 ).EQ.ZERO ) THEN 
            Z( I ) = -( LD( I+1 ) / LD( I ) )*Z( I+2 ) 
            ELSE 
            Z( I ) = -( WORK( INDLPL+I )*Z( I+1 ) ) 
            END IF 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
&           THEN                                                   
            Z( I ) = ZERO 
            ISUPPZ( 1 ) = I + 1 
            GO TO 240 
            END IF 
            ZTZ = ZTZ + Z( I )*Z( I ) 
230    CONTINUE 
240    CONTINUE 
      ENDIF 
                                                                        
!     Compute the FP vector downwards from R in blocks of size BLKSIZ   
      IF( .NOT.SAWNAN1 .AND. .NOT.SAWNAN2 ) THEN 
      DO 250 I = R, BN-1 
            Z( I+1 ) = -( WORK( INDUMN+I )*Z( I ) ) 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
&         THEN                                                     
            Z( I+1 ) = ZERO 
            ISUPPZ( 2 ) = I 
            GO TO 260 
            END IF 
            ZTZ = ZTZ + Z( I+1 )*Z( I+1 ) 
250    CONTINUE 
260    CONTINUE 
      ELSE 
!        Run slower loop if NaN occurred.                               
      DO 270 I = R, BN - 1 
            IF( Z( I ).EQ.ZERO ) THEN 
            Z( I+1 ) = -( LD( I-1 ) / LD( I ) )*Z( I-1 ) 
            ELSE 
            Z( I+1 ) = -( WORK( INDUMN+I )*Z( I ) ) 
            END IF 
            IF( (ABS(Z(I))+ABS(Z(I+1)))* ABS(LD(I)).LT.GAPTOL )         &
&           THEN                                                   
            Z( I+1 ) = ZERO 
            ISUPPZ( 2 ) = I 
            GO TO 280 
            END IF 
            ZTZ = ZTZ + Z( I+1 )*Z( I+1 ) 
270    CONTINUE 
280    CONTINUE 
      END IF 
!                                                                       
!     Compute quantities for convergence test                           
!                                                                       
      TMP = ONE / ZTZ 
      NRMINV = SQRT( TMP ) 
      RESID = ABS( MINGMA )*NRMINV 
      RQCORR = MINGMA*TMP 
!                                                                       
!                                                                       
      RETURN 
!                                                                       
!     End of DLAR1V                                                     
!                                                                       
      END                                           
!> \brief \b DLARF applies an elementary reflector to a general rectangu
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARF + dependencies                                        
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )      
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE                                         
!       INTEGER            INCV, LDC, M, N                              
!       DOUBLE PRECISION   TAU                                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   C( LDC, * ), V( * ), WORK( * )               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARF applies a real elementary reflector H to a real m by n matrix  
!> C, from either the left or the right. H is represented in the form   
!>                                                                      
!>       H = I - tau * v * v**T                                         
!>                                                                      
!> where tau is a real scalar and v is a real vector.                   
!>                                                                      
!> If tau = 0, then H is taken to be the unit matrix.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': form  H * C                                          
!>          = 'R': form  C * H                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is DOUBLE PRECISION array, dimension                      
!>                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'              
!>                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'              
!>          The vector v in the representation of H. V is not used if   
!>          TAU = 0.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCV                                                      
!> \verbatim                                                            
!>          INCV is INTEGER                                             
!>          The increment between elements of v. INCV <> 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION                                     
!>          The value tau in the representation of H.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
!>          or C * H if SIDE = 'R'.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension                   
!>                         (N) if SIDE = 'L'                            
!>                      or (M) if SIDE = 'R'                            
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!  =====================================================================
      SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE 
      INTEGER            INCV, LDC, M, N 
      DOUBLE PRECISION   TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   C( LDC, * ), V( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            APPLYLEFT 
      INTEGER            I, LASTV, LASTC 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DGEMV, DGER 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILADLR, ILADLC 
      EXTERNAL           LSAME, ILADLR, ILADLC 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      APPLYLEFT = LSAME( SIDE, 'L' ) 
      LASTV = 0 
      LASTC = 0 
      IF( TAU.NE.ZERO ) THEN 
!     Set up variables for scanning V.  LASTV begins pointing to the end
!     of V.                                                             
      IF( APPLYLEFT ) THEN 
            LASTV = M 
      ELSE 
            LASTV = N 
      END IF 
      IF( INCV.GT.0 ) THEN 
            I = 1 + (LASTV-1) * INCV 
      ELSE 
            I = 1 
      END IF 
!     Look for the last non-zero row in V.                              
      DO WHILE( LASTV.GT.0 .AND. V( I ).EQ.ZERO ) 
            LASTV = LASTV - 1 
            I = I - INCV 
      END DO 
      IF( APPLYLEFT ) THEN 
!     Scan for the last non-zero column in C(1:lastv,:).                
            LASTC = ILADLC(LASTV, N, C, LDC) 
      ELSE 
!     Scan for the last non-zero row in C(:,1:lastv).                   
            LASTC = ILADLR(M, LASTV, C, LDC) 
      END IF 
      END IF 
!     Note that lastc.eq.0 renders the BLAS operations null; no special 
!     case is needed at this level.                                     
      IF( APPLYLEFT ) THEN 
!                                                                       
!        Form  H * C                                                    
!                                                                       
      IF( LASTV.GT.0 ) THEN 
!                                                                       
!           w(1:lastc,1) := C(1:lastv,1:lastc)**T * v(1:lastv,1)        
!                                                                       
            CALL DGEMV( 'Transpose', LASTV, LASTC, ONE, C, LDC, V, INCV,&
&           ZERO, WORK, 1 )                                        
!                                                                       
!           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**
!                                                                       
            CALL DGER( LASTV, LASTC, -TAU, V, INCV, WORK, 1, C, LDC ) 
      END IF 
      ELSE 
!                                                                       
!        Form  C * H                                                    
!                                                                       
      IF( LASTV.GT.0 ) THEN 
!                                                                       
!           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)           
!                                                                       
            CALL DGEMV( 'No transpose', LASTC, LASTV, ONE, C, LDC,      &
&           V, INCV, ZERO, WORK, 1 )                               
!                                                                       
!           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**
!                                                                       
            CALL DGER( LASTC, LASTV, -TAU, WORK, 1, V, INCV, C, LDC ) 
      END IF 
      END IF 
      RETURN 
!                                                                       
!     End of DLARF                                                      
!                                                                       
      END                                           
!> \brief \b DLARFB applies a block reflector or its transpose to a gene
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARFB + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
!                          T, LDT, C, LDC, WORK, LDWORK )               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          DIRECT, SIDE, STOREV, TRANS                  
!       INTEGER            K, LDC, LDT, LDV, LDWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   C( LDC, * ), T( LDT, * ), V( LDV, * ),       
!      $                   WORK( LDWORK, * )                            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARFB applies a real block reflector H or its transpose H**T to a   
!> real m by n matrix C, from either the left or the right.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply H or H**T from the Left                        
!>          = 'R': apply H or H**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply H (No transpose)                               
!>          = 'T': apply H**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIRECT                                                    
!> \verbatim                                                            
!>          DIRECT is CHARACTER*1                                       
!>          Indicates how H is formed from a product of elementary      
!>          reflectors                                                  
!>          = 'F': H = H(1) H(2) . . . H(k) (Forward)                   
!>          = 'B': H = H(k) . . . H(2) H(1) (Backward)                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] STOREV                                                    
!> \verbatim                                                            
!>          STOREV is CHARACTER*1                                       
!>          Indicates how the vectors which define the elementary       
!>          reflectors are stored:                                      
!>          = 'C': Columnwise                                           
!>          = 'R': Rowwise                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The order of the matrix T (= the number of elementary       
!>          reflectors whose product defines the block reflector).      
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is DOUBLE PRECISION array, dimension                      
!>                                (LDV,K) if STOREV = 'C'               
!>                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
!>                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
!>          The matrix V. See Further Details.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDV                                                       
!> \verbatim                                                            
!>          LDV is INTEGER                                              
!>          The leading dimension of the array V.                       
!>          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);            
!>          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);            
!>          if STOREV = 'R', LDV >= K.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] T                                                         
!> \verbatim                                                            
!>          T is DOUBLE PRECISION array, dimension (LDT,K)              
!>          The triangular k by k matrix T in the representation of the 
!>          block reflector.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDT                                                       
!> \verbatim                                                            
!>          LDT is INTEGER                                              
!>          The leading dimension of the array T. LDT >= K.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (LDWORK,K)        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDWORK                                                    
!> \verbatim                                                            
!>          LDWORK is INTEGER                                           
!>          The leading dimension of the array WORK.                    
!>          If SIDE = 'L', LDWORK >= max(1,N);                          
!>          if SIDE = 'R', LDWORK >= max(1,M).                          
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2013                                                      
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The shape of the matrix V and the storage of the vectors which defin
!>  the H(i) is best illustrated by the following example with n = 5 and
!>  k = 3. The elements equal to 1 are not stored; the corresponding    
!>  array elements are modified but restored on exit. The rest of the   
!>  array is not used.                                                  
!>                                                                      
!>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R'
!>                                                                      
!>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
!>                   ( v1  1    )                     (     1 v2 v2 v2 )
!>                   ( v1 v2  1 )                     (        1 v3 v3 )
!>                   ( v1 v2 v3 )                                       
!>                   ( v1 v2 v3 )                                       
!>                                                                      
!>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R'
!>                                                                      
!>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
!>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
!>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
!>                   (     1 v3 )                                       
!>                   (        1 )                                       
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,  &
&                   T, LDT, C, LDC, WORK, LDWORK )                 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2013                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, SIDE, STOREV, TRANS 
      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   C( LDC, * ), T( LDT, * ), V( LDV, * ),         &
&                   WORK( LDWORK, * )                              
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      CHARACTER          TRANST 
      INTEGER            I, J 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY, DGEMM, DTRMM 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.LE.0 .OR. N.LE.0 )                                          &
&   RETURN                                                         
!                                                                       
      IF( LSAME( TRANS, 'N' ) ) THEN 
      TRANST = 'T' 
      ELSE 
      TRANST = 'N' 
      END IF 
!                                                                       
      IF( LSAME( STOREV, 'C' ) ) THEN 
!                                                                       
      IF( LSAME( DIRECT, 'F' ) ) THEN 
!                                                                       
!           Let  V =  ( V1 )    (first K rows)                          
!                     ( V2 )                                            
!           where  V1  is unit lower triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in W
!                                                                       
!              W := C1**T                                               
!                                                                       
            DO 10 J = 1, K 
                  CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 ) 
10          CONTINUE 
!                                                                       
!              W := W * V1                                              
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
&                     K, ONE, V, LDV, WORK, LDWORK )               
            IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C2**T * V2                                   
!                                                                       
                  CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K,   &
&                        ONE, C( K+1, 1 ), LDC, V( K+1, 1 ), LDV,  &
&                        ONE, WORK, LDWORK )                       
            END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,  &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W**T                                        
!                                                                       
            IF( M.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - V2 * W**T                                  
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K,   &
&                        -ONE, V( K+1, 1 ), LDV, WORK, LDWORK, ONE,&
&                        C( K+1, 1 ), LDC )                        
            END IF 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
&                     ONE, V, LDV, WORK, LDWORK )                  
!                                                                       
!              C1 := C1 - W**T                                          
!                                                                       
            DO 30 J = 1, K 
                  DO 20 I = 1, N 
                  C( J, I ) = C( J, I ) - WORK( I, J ) 
20             CONTINUE 
30          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C1                                                  
!                                                                       
            DO 40 J = 1, K 
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 ) 
40          CONTINUE 
!                                                                       
!              W := W * V1                                              
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
&                     K, ONE, V, LDV, WORK, LDWORK )               
            IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C2 * V2                                      
!                                                                       
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,&
&                        ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,  &
&                        ONE, WORK, LDWORK )                       
            END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,   &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V**T                                        
!                                                                       
            IF( N.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - W * V2**T                                  
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,   &
&                        -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE,&
&                        C( 1, K+1 ), LDC )                        
            END IF 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
&                     ONE, V, LDV, WORK, LDWORK )                  
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
            DO 60 J = 1, K 
                  DO 50 I = 1, M 
                  C( I, J ) = C( I, J ) - WORK( I, J ) 
50             CONTINUE 
60          CONTINUE 
            END IF 
!                                                                       
      ELSE 
!                                                                       
!           Let  V =  ( V1 )                                            
!                     ( V2 )    (last K rows)                           
!           where  V2  is unit upper triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in W
!                                                                       
!              W := C2**T                                               
!                                                                       
            DO 70 J = 1, K 
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 ) 
70          CONTINUE 
!                                                                       
!              W := W * V2                                              
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
&                     K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )   
            IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C1**T * V1                                   
!                                                                       
                  CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K,   &
&                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
            END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,  &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W**T                                        
!                                                                       
            IF( M.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - V1 * W**T                                  
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K,   &
&                        -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC ) 
            END IF 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
&                     ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )      
!                                                                       
!              C2 := C2 - W**T                                          
!                                                                       
            DO 90 J = 1, K 
                  DO 80 I = 1, N 
                  C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J ) 
80             CONTINUE 
90          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C2                                                  
!                                                                       
            DO 100 J = 1, K 
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 ) 
100          CONTINUE 
!                                                                       
!              W := W * V2                                              
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
&                     K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )   
            IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C1 * V1                                      
!                                                                       
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,&
&                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
            END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,   &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V**T                                        
!                                                                       
            IF( N.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - W * V1**T                                  
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,   &
&                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC ) 
            END IF 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
&                     ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )      
!                                                                       
!              C2 := C2 - W                                             
!                                                                       
            DO 120 J = 1, K 
                  DO 110 I = 1, M 
                  C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J ) 
110             CONTINUE 
120          CONTINUE 
            END IF 
      END IF 
!                                                                       
      ELSE IF( LSAME( STOREV, 'R' ) ) THEN 
!                                                                       
      IF( LSAME( DIRECT, 'F' ) ) THEN 
!                                                                       
!           Let  V =  ( V1  V2 )    (V1: first K columns)               
!           where  V1  is unit upper triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (sto
!                                                                       
!              W := C1**T                                               
!                                                                       
            DO 130 J = 1, K 
                  CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 ) 
130          CONTINUE 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
&                     ONE, V, LDV, WORK, LDWORK )                  
            IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C2**T * V2**T                                
!                                                                       
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
&                        C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,  &
&                        WORK, LDWORK )                            
            END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,  &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V**T * W**T                                     
!                                                                       
            IF( M.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - V2**T * W**T                               
!                                                                       
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,&
&                        V( 1, K+1 ), LDV, WORK, LDWORK, ONE,      &
&                        C( K+1, 1 ), LDC )                        
            END IF 
!                                                                       
!              W := W * V1                                              
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
&                     K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W**T                                          
!                                                                       
            DO 150 J = 1, K 
                  DO 140 I = 1, N 
                  C( J, I ) = C( J, I ) - WORK( I, J ) 
140             CONTINUE 
150          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H**T  where  C = ( C1  C2 )         
!                                                                       
!              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
!                                                                       
!              W := C1                                                  
!                                                                       
            DO 160 J = 1, K 
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 ) 
160          CONTINUE 
!                                                                       
!              W := W * V1**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
&                     ONE, V, LDV, WORK, LDWORK )                  
            IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C2 * V2**T                                   
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,   &
&                        ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV,  &
&                        ONE, WORK, LDWORK )                       
            END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,   &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
            IF( N.GT.K ) THEN 
!                                                                       
!                 C2 := C2 - W * V2                                     
!                                                                       
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,&
&                        -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,&
&                        C( 1, K+1 ), LDC )                        
            END IF 
!                                                                       
!              W := W * V1                                              
!                                                                       
            CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
&                     K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
            DO 180 J = 1, K 
                  DO 170 I = 1, M 
                  C( I, J ) = C( I, J ) - WORK( I, J ) 
170             CONTINUE 
180          CONTINUE 
!                                                                       
            END IF 
!                                                                       
      ELSE 
!                                                                       
!           Let  V =  ( V1  V2 )    (V2: last K columns)                
!           where  V2  is unit lower triangular.                        
!                                                                       
            IF( LSAME( SIDE, 'L' ) ) THEN 
!                                                                       
!              Form  H * C  or  H**T * C  where  C = ( C1 )             
!                                                    ( C2 )             
!                                                                       
!              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (sto
!                                                                       
!              W := C2**T                                               
!                                                                       
            DO 190 J = 1, K 
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 ) 
190          CONTINUE 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
&                     ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )      
            IF( M.GT.K ) THEN 
!                                                                       
!                 W := W + C1**T * V1**T                                
!                                                                       
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
&                        C, LDC, V, LDV, ONE, WORK, LDWORK )       
            END IF 
!                                                                       
!              W := W * T**T  or  W * T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,  &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V**T * W**T                                     
!                                                                       
            IF( M.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - V1**T * W**T                               
!                                                                       
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,&
&                        V, LDV, WORK, LDWORK, ONE, C, LDC )       
            END IF 
!                                                                       
!              W := W * V2                                              
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
&                     K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C2 := C2 - W**T                                          
!                                                                       
            DO 210 J = 1, K 
                  DO 200 I = 1, N 
                  C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J ) 
200             CONTINUE 
210          CONTINUE 
!                                                                       
            ELSE IF( LSAME( SIDE, 'R' ) ) THEN 
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
!                                                                       
!              W := C2                                                  
!                                                                       
            DO 220 J = 1, K 
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 ) 
220          CONTINUE 
!                                                                       
!              W := W * V2**T                                           
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
&                     ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )      
            IF( N.GT.K ) THEN 
!                                                                       
!                 W := W + C1 * V1**T                                   
!                                                                       
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,   &
&                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
            END IF 
!                                                                       
!              W := W * T  or  W * T**T                                 
!                                                                       
            CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,   &
&                     ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
            IF( N.GT.K ) THEN 
!                                                                       
!                 C1 := C1 - W * V1                                     
!                                                                       
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,&
&                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC ) 
            END IF 
!                                                                       
!              W := W * V2                                              
!                                                                       
            CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
&                     K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
            DO 240 J = 1, K 
                  DO 230 I = 1, M 
                  C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J ) 
230             CONTINUE 
240          CONTINUE 
!                                                                       
            END IF 
!                                                                       
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DLARFB                                                     
!                                                                       
      END                                           
!> \brief \b DLARFG generates an elementary reflector (Householder matri
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARFG + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )                     
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INCX, N                                      
!       DOUBLE PRECISION   ALPHA, TAU                                   
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARFG generates a real elementary reflector H of order n, such      
!> that                                                                 
!>                                                                      
!>       H * ( alpha ) = ( beta ),   H**T * H = I.                      
!>           (   x   )   (   0  )                                       
!>                                                                      
!> where alpha and beta are scalars, and x is an (n-1)-element real     
!> vector. H is represented in the form                                 
!>                                                                      
!>       H = I - tau * ( 1 ) * ( 1 v**T ) ,                             
!>                     ( v )                                            
!>                                                                      
!> where tau is a real scalar and v is a real (n-1)-element             
!> vector.                                                              
!>                                                                      
!> If the elements of x are all zero, then tau = 0 and H is taken to be 
!> the unit matrix.                                                     
!>                                                                      
!> Otherwise  1 <= tau <= 2.                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the elementary reflector.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ALPHA                                                 
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION                                   
!>          On entry, the value alpha.                                  
!>          On exit, it is overwritten with the value beta.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] X                                                     
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension                      
!>                         (1+(N-2)*abs(INCX))                          
!>          On entry, the vector x.                                     
!>          On exit, it is overwritten with the vector v.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>          The increment between elements of X. INCX > 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION                                     
!>          The value tau.                                              
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!  =====================================================================
      SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N 
      DOUBLE PRECISION   ALPHA, TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   X( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J, KNT 
      DOUBLE PRECISION   BETA, RSAFMN, SAFMIN, XNORM 
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH, DLAPY2, DNRM2 
      EXTERNAL           DLAMCH, DLAPY2, DNRM2 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SIGN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DSCAL 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.1 ) THEN 
      TAU = ZERO 
      RETURN 
      END IF 
!                                                                       
      XNORM = DNRM2( N-1, X, INCX ) 
!                                                                       
      IF( XNORM.EQ.ZERO ) THEN 
!                                                                       
!        H  =  I                                                        
!                                                                       
      TAU = ZERO 
      ELSE 
!                                                                       
!        general case                                                   
!                                                                       
      BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA ) 
      SAFMIN = DLAMCH( 'S' ) / DLAMCH( 'E' ) 
      KNT = 0 
      IF( ABS( BETA ).LT.SAFMIN ) THEN 
!                                                                       
!           XNORM, BETA may be inaccurate; scale X and recompute them   
!                                                                       
            RSAFMN = ONE / SAFMIN 
10       CONTINUE 
            KNT = KNT + 1 
            CALL DSCAL( N-1, RSAFMN, X, INCX ) 
            BETA = BETA*RSAFMN 
            ALPHA = ALPHA*RSAFMN 
            IF( (ABS( BETA ).LT.SAFMIN) .AND. (KNT .LT. 20) )           &
&         GO TO 10                                                 
!                                                                       
!           New BETA is at most 1, at least SAFMIN                      
!                                                                       
            XNORM = DNRM2( N-1, X, INCX ) 
            BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA ) 
      END IF 
      TAU = ( BETA-ALPHA ) / BETA 
      CALL DSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX ) 
!                                                                       
!        If ALPHA is subnormal, it may lose relative accuracy           
!                                                                       
      DO 20 J = 1, KNT 
            BETA = BETA*SAFMIN 
20    CONTINUE 
      ALPHA = BETA 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DLARFG                                                     
!                                                                       
      END                                           
!> \brief \b DLARFT forms the triangular factor T of a block reflector H
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARFT + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )  
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          DIRECT, STOREV                               
!       INTEGER            K, LDT, LDV, N                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   T( LDT, * ), TAU( * ), V( LDV, * )           
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARFT forms the triangular factor T of a real block reflector H     
!> of order n, which is defined as a product of k elementary reflectors.
!>                                                                      
!> If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; 
!>                                                                      
!> If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. 
!>                                                                      
!> If STOREV = 'C', the vector which defines the elementary reflector   
!> H(i) is stored in the i-th column of the array V, and                
!>                                                                      
!>    H  =  I - V * T * V**T                                            
!>                                                                      
!> If STOREV = 'R', the vector which defines the elementary reflector   
!> H(i) is stored in the i-th row of the array V, and                   
!>                                                                      
!>    H  =  I - V**T * T * V                                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] DIRECT                                                    
!> \verbatim                                                            
!>          DIRECT is CHARACTER*1                                       
!>          Specifies the order in which the elementary reflectors are  
!>          multiplied to form the block reflector:                     
!>          = 'F': H = H(1) H(2) . . . H(k) (Forward)                   
!>          = 'B': H = H(k) . . . H(2) H(1) (Backward)                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] STOREV                                                    
!> \verbatim                                                            
!>          STOREV is CHARACTER*1                                       
!>          Specifies how the vectors which define the elementary       
!>          reflectors are stored (see also Further Details):           
!>          = 'C': columnwise                                           
!>          = 'R': rowwise                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the block reflector H. N >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The order of the triangular factor T (= the number of       
!>          elementary reflectors). K >= 1.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] V                                                         
!> \verbatim                                                            
!>          V is DOUBLE PRECISION array, dimension                      
!>                               (LDV,K) if STOREV = 'C'                
!>                               (LDV,N) if STOREV = 'R'                
!>          The matrix V. See further details.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDV                                                       
!> \verbatim                                                            
!>          LDV is INTEGER                                              
!>          The leading dimension of the array V.                       
!>          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (K)                
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i).                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] T                                                        
!> \verbatim                                                            
!>          T is DOUBLE PRECISION array, dimension (LDT,K)              
!>          The k by k triangular factor T of the block reflector.      
!>          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T i
!>          lower triangular. The rest of the array is not used.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDT                                                       
!> \verbatim                                                            
!>          LDT is INTEGER                                              
!>          The leading dimension of the array T. LDT >= K.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The shape of the matrix V and the storage of the vectors which defin
!>  the H(i) is best illustrated by the following example with n = 5 and
!>  k = 3. The elements equal to 1 are not stored.                      
!>                                                                      
!>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R'
!>                                                                      
!>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
!>                   ( v1  1    )                     (     1 v2 v2 v2 )
!>                   ( v1 v2  1 )                     (        1 v3 v3 )
!>                   ( v1 v2 v3 )                                       
!>                   ( v1 v2 v3 )                                       
!>                                                                      
!>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R'
!>                                                                      
!>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
!>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
!>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
!>                   (     1 v3 )                                       
!>                   (        1 )                                       
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, STOREV 
      INTEGER            K, LDT, LDV, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   T( LDT, * ), TAU( * ), V( LDV, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J, PREVLASTV, LASTV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DGEMV, DTRMV 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 )                                                      &
&   RETURN                                                         
!                                                                       
      IF( LSAME( DIRECT, 'F' ) ) THEN 
      PREVLASTV = N 
      DO I = 1, K 
            PREVLASTV = MAX( I, PREVLASTV ) 
            IF( TAU( I ).EQ.ZERO ) THEN 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
            DO J = 1, I 
                  T( J, I ) = ZERO 
            END DO 
            ELSE 
!                                                                       
!              general case                                             
!                                                                       
            IF( LSAME( STOREV, 'C' ) ) THEN 
!                 Skip any trailing zeros.                              
                  DO LASTV = N, I+1, -1 
                  IF( V( LASTV, I ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = 1, I-1 
                  T( J, I ) = -TAU( I ) * V( I , J ) 
                  END DO 
                  J = MIN( LASTV, PREVLASTV ) 
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**T * V(i:j,i)   
!                                                                       
                  CALL DGEMV( 'Transpose', J-I, I-1, -TAU( I ),         &
&                        V( I+1, 1 ), LDV, V( I+1, I ), 1, ONE,    &
&                        T( 1, I ), 1 )                            
            ELSE 
!                 Skip any trailing zeros.                              
                  DO LASTV = N, I+1, -1 
                  IF( V( I, LASTV ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = 1, I-1 
                  T( J, I ) = -TAU( I ) * V( J , I ) 
                  END DO 
                  J = MIN( LASTV, PREVLASTV ) 
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**T   
!                                                                       
                  CALL DGEMV( 'No transpose', I-1, J-I, -TAU( I ),      &
&                        V( 1, I+1 ), LDV, V( I, I+1 ), LDV, ONE,  &
&                        T( 1, I ), 1 )                            
            END IF 
!                                                                       
!              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)                
!                                                                       
            CALL DTRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T, &
&                     LDT, T( 1, I ), 1 )                          
            T( I, I ) = TAU( I ) 
            IF( I.GT.1 ) THEN 
                  PREVLASTV = MAX( PREVLASTV, LASTV ) 
            ELSE 
                  PREVLASTV = LASTV 
            END IF 
            END IF 
      END DO 
      ELSE 
      PREVLASTV = 1 
      DO I = K, 1, -1 
            IF( TAU( I ).EQ.ZERO ) THEN 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
            DO J = I, K 
                  T( J, I ) = ZERO 
            END DO 
            ELSE 
!                                                                       
!              general case                                             
!                                                                       
            IF( I.LT.K ) THEN 
                  IF( LSAME( STOREV, 'C' ) ) THEN 
!                    Skip any leading zeros.                            
                  DO LASTV = 1, I-1 
                        IF( V( LASTV, I ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = I+1, K 
                        T( J, I ) = -TAU( I ) * V( N-K+I , J ) 
                  END DO 
                  J = MAX( LASTV, PREVLASTV ) 
!                                                                       
!                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**T * V(j:n-
!                                                                       
                  CALL DGEMV( 'Transpose', N-K+I-J, K-I, -TAU( I ),  &
&                           V( J, I+1 ), LDV, V( J, I ), 1, ONE,   &
&                           T( I+1, I ), 1 )                       
                  ELSE 
!                    Skip any leading zeros.                            
                  DO LASTV = 1, I-1 
                        IF( V( I, LASTV ).NE.ZERO ) EXIT 
                  END DO 
                  DO J = I+1, K 
                        T( J, I ) = -TAU( I ) * V( J, N-K+I ) 
                  END DO 
                  J = MAX( LASTV, PREVLASTV ) 
!                                                                       
!                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k
!                                                                       
                  CALL DGEMV( 'No transpose', K-I, N-K+I-J,          &
&                    -TAU( I ), V( I+1, J ), LDV, V( I, J ), LDV,  &
&                    ONE, T( I+1, I ), 1 )                         
                  END IF 
!                                                                       
!                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)             
!                                                                       
                  CALL DTRMV( 'Lower', 'No transpose', 'Non-unit', K-I, &
&                        T( I+1, I+1 ), LDT, T( I+1, I ), 1 )      
                  IF( I.GT.1 ) THEN 
                  PREVLASTV = MIN( PREVLASTV, LASTV ) 
                  ELSE 
                  PREVLASTV = LASTV 
                  END IF 
            END IF 
            T( I, I ) = TAU( I ) 
            END IF 
      END DO 
      END IF 
      RETURN 
!                                                                       
!     End of DLARFT                                                     
!                                                                       
      END                                           
!> \brief \b DLARNV returns a vector of random numbers from a uniform or
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARNV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARNV( IDIST, ISEED, N, X )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IDIST, N                                     
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISEED( 4 )                                   
!       DOUBLE PRECISION   X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARNV returns a vector of n random real numbers from a uniform or   
!> normal distribution.                                                 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] IDIST                                                     
!> \verbatim                                                            
!>          IDIST is INTEGER                                            
!>          Specifies the distribution of the random numbers:           
!>          = 1:  uniform (0,1)                                         
!>          = 2:  uniform (-1,1)                                        
!>          = 3:  normal (0,1)                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ISEED                                                 
!> \verbatim                                                            
!>          ISEED is INTEGER array, dimension (4)                       
!>          On entry, the seed of the random number generator; the array
!>          elements must be between 0 and 4095, and ISEED(4) must be   
!>          odd.                                                        
!>          On exit, the seed is updated.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of random numbers to be generated.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] X                                                        
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension (N)                  
!>          The generated random numbers.                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  This routine calls the auxiliary routine DLARUV to generate random  
!>  real numbers from a uniform (0,1) distribution, in batches of up to 
!>  128 using vectorisable code. The Box-Muller method is used to       
!>  transform numbers from a uniform to a normal distribution.          
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLARNV( IDIST, ISEED, N, X ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IDIST, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISEED( 4 ) 
      DOUBLE PRECISION   X( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, TWO 
      PARAMETER          ( ONE = 1.0D+0, TWO = 2.0D+0 ) 
      INTEGER            LV 
      PARAMETER          ( LV = 128 ) 
      DOUBLE PRECISION   TWOPI 
      PARAMETER          ( TWOPI = 6.2831853071795864769252867663D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, IL, IL2, IV 
!     ..                                                                
!     .. Local Arrays ..                                                
      DOUBLE PRECISION   U( LV ) 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          COS, LOG, MIN, SQRT 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLARUV 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      DO 40 IV = 1, N, LV / 2 
      IL = MIN( LV / 2, N-IV+1 ) 
      IF( IDIST.EQ.3 ) THEN 
            IL2 = 2*IL 
      ELSE 
            IL2 = IL 
      END IF 
!                                                                       
!        Call DLARUV to generate IL2 numbers from a uniform (0,1)       
!        distribution (IL2 <= LV)                                       
!                                                                       
      CALL DLARUV( ISEED, IL2, U ) 
!                                                                       
      IF( IDIST.EQ.1 ) THEN 
!                                                                       
!           Copy generated numbers                                      
!                                                                       
            DO 10 I = 1, IL 
            X( IV+I-1 ) = U( I ) 
10       CONTINUE 
      ELSE IF( IDIST.EQ.2 ) THEN 
!                                                                       
!           Convert generated numbers to uniform (-1,1) distribution    
!                                                                       
            DO 20 I = 1, IL 
            X( IV+I-1 ) = TWO*U( I ) - ONE 
20       CONTINUE 
      ELSE IF( IDIST.EQ.3 ) THEN 
!                                                                       
!           Convert generated numbers to normal (0,1) distribution      
!                                                                       
            DO 30 I = 1, IL 
            X( IV+I-1 ) = SQRT( -TWO*LOG( U( 2*I-1 ) ) )*            &
&                       COS( TWOPI*U( 2*I ) )                      
30       CONTINUE 
      END IF 
40 END DO 
      RETURN 
!                                                                       
!     End of DLARNV                                                     
!                                                                       
      END                                           
!> \brief \b DLARRA computes the splitting points with the specified thr
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRA + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRA( N, D, E, E2, SPLTOL, TNRM,                   
!                           NSPLIT, ISPLIT, INFO )                      
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N, NSPLIT                              
!       DOUBLE PRECISION    SPLTOL, TNRM                                
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISPLIT( * )                                  
!       DOUBLE PRECISION   D( * ), E( * ), E2( * )                      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Compute the splitting points with threshold SPLTOL.                  
!> DLARRA sets any "small" off-diagonal elements to zero.               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the N diagonal elements of the tridiagonal        
!>          matrix T.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) need not be set. 
!>          On exit, the entries E( ISPLIT( I ) ), 1 <= I <= NSPLIT,    
!>          are set to zero, the other entries of E are untouched.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E2                                                    
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N)                 
!>          On entry, the first (N-1) entries contain the SQUARES of the
!>          subdiagonal elements of the tridiagonal matrix T;           
!>          E2(N) need not be set.                                      
!>          On exit, the entries E2( ISPLIT( I ) ),                     
!>          1 <= I <= NSPLIT, have been set to zero                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPLTOL                                                    
!> \verbatim                                                            
!>          SPLTOL is DOUBLE PRECISION                                  
!>          The threshold for splitting. Two criteria can be used:      
!>          SPLTOL<0 : criterion based on absolute off-diagonal value   
!>          SPLTOL>0 : criterion that preserves relative accuracy       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TNRM                                                      
!> \verbatim                                                            
!>          TNRM is DOUBLE PRECISION                                    
!>          The norm of the matrix.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of blocks T splits into. 1 <= NSPLIT <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to ISPLIT(1),    
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRA( N, D, E, E2, SPLTOL, TNRM,                     &
&                    NSPLIT, ISPLIT, INFO )                        
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N, NSPLIT 
      DOUBLE PRECISION    SPLTOL, TNRM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISPLIT( * ) 
      DOUBLE PRECISION   D( * ), E( * ), E2( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      DOUBLE PRECISION   EABS, TMP1 
                                                                        
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Compute splitting points                                          
      NSPLIT = 1 
      IF(SPLTOL.LT.ZERO) THEN 
!        Criterion based on absolute off-diagonal value                 
      TMP1 = ABS(SPLTOL)* TNRM 
      DO 9 I = 1, N-1 
            EABS = ABS( E(I) ) 
            IF( EABS .LE. TMP1) THEN 
            E(I) = ZERO 
            E2(I) = ZERO 
            ISPLIT( NSPLIT ) = I 
            NSPLIT = NSPLIT + 1 
            END IF 
9    CONTINUE 
      ELSE 
!        Criterion that guarantees relative accuracy                    
      DO 10 I = 1, N-1 
            EABS = ABS( E(I) ) 
            IF( EABS .LE. SPLTOL * SQRT(ABS(D(I)))*SQRT(ABS(D(I+1))) )  &
&      THEN                                                        
            E(I) = ZERO 
            E2(I) = ZERO 
            ISPLIT( NSPLIT ) = I 
            NSPLIT = NSPLIT + 1 
            END IF 
10    CONTINUE 
      ENDIF 
      ISPLIT( NSPLIT ) = N 
                                                                        
      RETURN 
!                                                                       
!     End of DLARRA                                                     
!                                                                       
      END                                           
!> \brief \b DLARRB provides limited bisection to locate eigenvalues for
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRB + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRB( N, D, LLD, IFIRST, ILAST, RTOL1,             
!                          RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK,   
!                          PIVMIN, SPDIAM, TWIST, INFO )                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IFIRST, ILAST, INFO, N, OFFSET, TWIST        
!       DOUBLE PRECISION   PIVMIN, RTOL1, RTOL2, SPDIAM                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * )                                   
!       DOUBLE PRECISION   D( * ), LLD( * ), W( * ),                    
!      $                   WERR( * ), WGAP( * ), WORK( * )              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the relatively robust representation(RRR) L D L^T, DLARRB      
!> does "limited" bisection to refine the eigenvalues of L D L^T,       
!> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initi
!> guesses for these eigenvalues are input in W, the corresponding estim
!> of the error in these guesses and their gaps are input in WERR       
!> and WGAP, respectively. During bisection, intervals                  
!> [left, right] are maintained by storing their mid-points and         
!> semi-widths in the arrays W and WERR respectively.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LLD                                                       
!> \verbatim                                                            
!>          LLD is DOUBLE PRECISION array, dimension (N-1)              
!>          The (N-1) elements L(i)*L(i)*D(i).                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IFIRST                                                    
!> \verbatim                                                            
!>          IFIRST is INTEGER                                           
!>          The index of the first eigenvalue to be computed.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILAST                                                     
!> \verbatim                                                            
!>          ILAST is INTEGER                                            
!>          The index of the last eigenvalue to be computed.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is DOUBLE PRECISION                                   
!>          Tolerance for the convergence of the bisection intervals.   
!>          An interval [LEFT,RIGHT] has converged if                   
!>          RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )    
!>          where GAP is the (estimated) distance to the nearest        
!>          eigenvalue.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OFFSET                                                    
!> \verbatim                                                            
!>          OFFSET is INTEGER                                           
!>          Offset for the arrays W, WGAP and WERR, i.e., the IFIRST-OFF
!>          through ILAST-OFFSET elements of these arrays are to be used
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are  
!>          estimates of the eigenvalues of L D L^T indexed IFIRST throu
!>          ILAST.                                                      
!>          On output, these estimates are refined.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is DOUBLE PRECISION array, dimension (N-1)             
!>          On input, the (estimated) gaps between consecutive          
!>          eigenvalues of L D L^T, i.e., WGAP(I-OFFSET) is the gap betw
!>          eigenvalues I and I+1. Note that if IFIRST = ILAST          
!>          then WGAP(IFIRST-OFFSET) must be set to ZERO.               
!>          On output, these gaps are refined.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension (N)               
!>          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET )
!>          the errors in the estimates of the corresponding elements in
!>          On output, these errors are refined.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (2*N)             
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (2*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot in the Sturm sequence.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is DOUBLE PRECISION                                  
!>          The spectral diameter of the matrix.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TWIST                                                     
!> \verbatim                                                            
!>          TWIST is INTEGER                                            
!>          The twist index for the twisted factorization that is used  
!>          for the negcount.                                           
!>          TWIST = N: Compute negcount from L D L^T - LAMBDA I = L+ D+ 
!>          TWIST = 1: Compute negcount from L D L^T - LAMBDA I = U- D- 
!>          TWIST = R: Compute negcount from L D L^T - LAMBDA I = N(r) D
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Error flag.                                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRB( N, D, LLD, IFIRST, ILAST, RTOL1,               &
&                   RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK,     &
&                   PIVMIN, SPDIAM, TWIST, INFO )                  
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IFIRST, ILAST, INFO, N, OFFSET, TWIST 
      DOUBLE PRECISION   PIVMIN, RTOL1, RTOL2, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ) 
      DOUBLE PRECISION   D( * ), LLD( * ), W( * ),                      &
&                   WERR( * ), WGAP( * ), WORK( * )                
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, TWO, HALF 
      PARAMETER        ( ZERO = 0.0D0, TWO = 2.0D0,                     &
&                   HALF = 0.5D0 )                                 
      INTEGER   MAXITR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, I1, II, IP, ITER, K, NEGCNT, NEXT, NINT,    &
&                   OLNINT, PREV, R                                
      DOUBLE PRECISION   BACK, CVRGD, GAP, LEFT, LGAP, MID, MNWDTH,     &
&                   RGAP, RIGHT, TMP, WIDTH                        
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            DLANEG 
      EXTERNAL           DLANEG 
!                                                                       
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
      MAXITR = INT( ( LOG( SPDIAM+PIVMIN )-LOG( PIVMIN ) ) /            &
&           LOG( TWO ) ) + 2                                       
      MNWDTH = TWO * PIVMIN 
!                                                                       
      R = TWIST 
      IF((R.LT.1).OR.(R.GT.N)) R = N 
!                                                                       
!     Initialize unconverged intervals in [ WORK(2*I-1), WORK(2*I) ].   
!     The Sturm Count, Count( WORK(2*I-1) ) is arranged to be I-1, while
!     Count( WORK(2*I) ) is stored in IWORK( 2*I ). The integer IWORK( 2
!     for an unconverged interval is set to the index of the next unconv
!     interval, and is -1 or 0 for a converged interval. Thus a linked  
!     list of unconverged intervals is set up.                          
!                                                                       
      I1 = IFIRST 
!     The number of unconverged intervals                               
      NINT = 0 
!     The last unconverged interval found                               
      PREV = 0 
                                                                        
      RGAP = WGAP( I1-OFFSET ) 
      DO 75 I = I1, ILAST 
      K = 2*I 
      II = I - OFFSET 
      LEFT = W( II ) - WERR( II ) 
      RIGHT = W( II ) + WERR( II ) 
      LGAP = RGAP 
      RGAP = WGAP( II ) 
      GAP = MIN( LGAP, RGAP ) 
                                                                        
!        Make sure that [LEFT,RIGHT] contains the desired eigenvalue    
!        Compute negcount from dstqds facto L+D+L+^T = L D L^T - LEFT   
!                                                                       
!        Do while( NEGCNT(LEFT).GT.I-1 )                                
!                                                                       
      BACK = WERR( II ) 
20    CONTINUE 
      NEGCNT = DLANEG( N, D, LLD, LEFT, PIVMIN, R ) 
      IF( NEGCNT.GT.I-1 ) THEN 
            LEFT = LEFT - BACK 
            BACK = TWO*BACK 
            GO TO 20 
      END IF 
!                                                                       
!        Do while( NEGCNT(RIGHT).LT.I )                                 
!        Compute negcount from dstqds facto L+D+L+^T = L D L^T - RIGHT  
!                                                                       
      BACK = WERR( II ) 
50    CONTINUE 
                                                                        
      NEGCNT = DLANEG( N, D, LLD, RIGHT, PIVMIN, R ) 
      IF( NEGCNT.LT.I ) THEN 
            RIGHT = RIGHT + BACK 
            BACK = TWO*BACK 
            GO TO 50 
      END IF 
      WIDTH = HALF*ABS( LEFT - RIGHT ) 
      TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
      CVRGD = MAX(RTOL1*GAP,RTOL2*TMP) 
      IF( WIDTH.LE.CVRGD .OR. WIDTH.LE.MNWDTH ) THEN 
!           This interval has already converged and does not need refine
!           (Note that the gaps might change through refining the       
!            eigenvalues, however, they can only get bigger.)           
!           Remove it from the list.                                    
            IWORK( K-1 ) = -1 
!           Make sure that I1 always points to the first unconverged int
            IF((I.EQ.I1).AND.(I.LT.ILAST)) I1 = I + 1 
            IF((PREV.GE.I1).AND.(I.LE.ILAST)) IWORK( 2*PREV-1 ) = I + 1 
      ELSE 
!           unconverged interval found                                  
            PREV = I 
            NINT = NINT + 1 
            IWORK( K-1 ) = I + 1 
            IWORK( K ) = NEGCNT 
      END IF 
      WORK( K-1 ) = LEFT 
      WORK( K ) = RIGHT 
75 END DO 
                                                                        
!                                                                       
!     Do while( NINT.GT.0 ), i.e. there are still unconverged intervals 
!     and while (ITER.LT.MAXITR)                                        
!                                                                       
      ITER = 0 
80 CONTINUE 
      PREV = I1 - 1 
      I = I1 
      OLNINT = NINT 
                                                                        
      DO 100 IP = 1, OLNINT 
      K = 2*I 
      II = I - OFFSET 
      RGAP = WGAP( II ) 
      LGAP = RGAP 
      IF(II.GT.1) LGAP = WGAP( II-1 ) 
      GAP = MIN( LGAP, RGAP ) 
      NEXT = IWORK( K-1 ) 
      LEFT = WORK( K-1 ) 
      RIGHT = WORK( K ) 
      MID = HALF*( LEFT + RIGHT ) 
                                                                        
!        semiwidth of interval                                          
      WIDTH = RIGHT - MID 
      TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
      CVRGD = MAX(RTOL1*GAP,RTOL2*TMP) 
      IF( ( WIDTH.LE.CVRGD ) .OR. ( WIDTH.LE.MNWDTH ).OR.            &
&       ( ITER.EQ.MAXITR ) )THEN                                   
!           reduce number of unconverged intervals                      
            NINT = NINT - 1 
!           Mark interval as converged.                                 
            IWORK( K-1 ) = 0 
            IF( I1.EQ.I ) THEN 
            I1 = NEXT 
            ELSE 
!              Prev holds the last unconverged interval previously exami
            IF(PREV.GE.I1) IWORK( 2*PREV-1 ) = NEXT 
            END IF 
            I = NEXT 
            GO TO 100 
      END IF 
      PREV = I 
!                                                                       
!        Perform one bisection step                                     
!                                                                       
      NEGCNT = DLANEG( N, D, LLD, MID, PIVMIN, R ) 
      IF( NEGCNT.LE.I-1 ) THEN 
            WORK( K-1 ) = MID 
      ELSE 
            WORK( K ) = MID 
      END IF 
      I = NEXT 
100 END DO 
      ITER = ITER + 1 
!     do another loop if there are still unconverged intervals          
!     However, in the last iteration, all intervals are accepted        
!     since this is the best we can do.                                 
      IF( ( NINT.GT.0 ).AND.(ITER.LE.MAXITR) ) GO TO 80 
!                                                                       
!                                                                       
!     At this point, all the intervals have converged                   
      DO 110 I = IFIRST, ILAST 
      K = 2*I 
      II = I - OFFSET 
!        All intervals marked by '0' have been refined.                 
      IF( IWORK( K-1 ).EQ.0 ) THEN 
            W( II ) = HALF*( WORK( K-1 )+WORK( K ) ) 
            WERR( II ) = WORK( K ) - W( II ) 
      END IF 
110 END DO 
!                                                                       
      DO 111 I = IFIRST+1, ILAST 
      K = 2*I 
      II = I - OFFSET 
      WGAP( II-1 ) = MAX( ZERO,                                      &
&                     W(II) - WERR (II) - W( II-1 ) - WERR( II-1 ))
111 END DO 
                                                                        
      RETURN 
!                                                                       
!     End of DLARRB                                                     
!                                                                       
      END                                           
!> \brief \b DLARRC computes the number of eigenvalues of the symmetric 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRC + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRC( JOBT, N, VL, VU, D, E, PIVMIN,               
!                                   EIGCNT, LCNT, RCNT, INFO )          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBT                                         
!       INTEGER            EIGCNT, INFO, LCNT, N, RCNT                  
!       DOUBLE PRECISION   PIVMIN, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Find the number of eigenvalues of the symmetric tridiagonal matrix T 
!> that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T       
!> if JOBT = 'L'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBT                                                      
!> \verbatim                                                            
!>          JOBT is CHARACTER*1                                         
!>          = 'T':  Compute Sturm count for matrix T.                   
!>          = 'L':  Compute Sturm count for matrix L D L^T.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>          The lower bound for the eigenvalues.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>          The upper bound for the eigenvalues.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          JOBT = 'T': The N diagonal elements of the tridiagonal matri
!>          JOBT = 'L': The N diagonal elements of the diagonal matrix D
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          JOBT = 'T': The N-1 offdiagonal elements of the matrix T.   
!>          JOBT = 'L': The N-1 offdiagonal elements of the matrix L.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] EIGCNT                                                   
!> \verbatim                                                            
!>          EIGCNT is INTEGER                                           
!>          The number of eigenvalues of the symmetric tridiagonal matri
!>          that are in the interval (VL,VU]                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] LCNT                                                     
!> \verbatim                                                            
!>          LCNT is INTEGER                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] RCNT                                                     
!> \verbatim                                                            
!>          RCNT is INTEGER                                             
!>          The left and right negcounts of the interval.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRC( JOBT, N, VL, VU, D, E, PIVMIN,                 &
&                            EIGCNT, LCNT, RCNT, INFO )            
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBT 
      INTEGER            EIGCNT, INFO, LCNT, N, RCNT 
      DOUBLE PRECISION   PIVMIN, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      LOGICAL            MATT 
      DOUBLE PRECISION   LPIVOT, RPIVOT, SL, SU, TMP, TMP2 
                                                                        
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
      LCNT = 0 
      RCNT = 0 
      EIGCNT = 0 
      MATT = LSAME( JOBT, 'T' ) 
                                                                        
                                                                        
      IF (MATT) THEN 
!        Sturm sequence count on T                                      
      LPIVOT = D( 1 ) - VL 
      RPIVOT = D( 1 ) - VU 
      IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
      ENDIF 
      IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
      ENDIF 
      DO 10 I = 1, N-1 
            TMP = E(I)**2 
            LPIVOT = ( D( I+1 )-VL ) - TMP/LPIVOT 
            RPIVOT = ( D( I+1 )-VU ) - TMP/RPIVOT 
            IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
            ENDIF 
            IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
            ENDIF 
10    CONTINUE 
      ELSE 
!        Sturm sequence count on L D L^T                                
      SL = -VL 
      SU = -VU 
      DO 20 I = 1, N - 1 
            LPIVOT = D( I ) + SL 
            RPIVOT = D( I ) + SU 
            IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
            ENDIF 
            IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
            ENDIF 
            TMP = E(I) * D(I) * E(I) 
!                                                                       
            TMP2 = TMP / LPIVOT 
            IF( TMP2.EQ.ZERO ) THEN 
            SL =  TMP - VL 
            ELSE 
            SL = SL*TMP2 - VL 
            END IF 
!                                                                       
            TMP2 = TMP / RPIVOT 
            IF( TMP2.EQ.ZERO ) THEN 
            SU =  TMP - VU 
            ELSE 
            SU = SU*TMP2 - VU 
            END IF 
20    CONTINUE 
      LPIVOT = D( N ) + SL 
      RPIVOT = D( N ) + SU 
      IF( LPIVOT.LE.ZERO ) THEN 
            LCNT = LCNT + 1 
      ENDIF 
      IF( RPIVOT.LE.ZERO ) THEN 
            RCNT = RCNT + 1 
      ENDIF 
      ENDIF 
      EIGCNT = RCNT - LCNT 
                                                                        
      RETURN 
!                                                                       
!     end of DLARRC                                                     
!                                                                       
!> \brief \b DLARRD computes the eigenvalues of a symmetric tridiagonal 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRD( RANGE, ORDER, N, VL, VU, IL, IU, GERS,       
!                           RELTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,   
!                           M, W, WERR, WL, WU, IBLOCK, INDEXW,         
!                           WORK, IWORK, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ORDER, RANGE                                 
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       DOUBLE PRECISION    PIVMIN, RELTOL, VL, VU, WL, WU              
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), INDEXW( * ),                    
!      $                   ISPLIT( * ), IWORK( * )                      
!       DOUBLE PRECISION   D( * ), E( * ), E2( * ),                     
!      $                   GERS( * ), W( * ), WERR( * ), WORK( * )      
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARRD computes the eigenvalues of a symmetric tridiagonal           
!> matrix T to suitable accuracy. This is an auxiliary code to be       
!> called from DSTEMR.                                                  
!> The user may ask for all eigenvalues, all eigenvalues                
!> in the half-open interval (VL, VU], or the IL-th through IU-th       
!> eigenvalues.                                                         
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ORDER                                                     
!> \verbatim                                                            
!>          ORDER is CHARACTER*1                                        
!>          = 'B': ("By Block") the eigenvalues will be grouped by      
!>                              split-off block (see IBLOCK, ISPLIT) and
!>                              ordered from smallest to largest within 
!>                              the block.                              
!>          = 'E': ("Entire matrix")                                    
!>                              the eigenvalues for the entire matrix   
!>                              will be ordered from smallest to        
!>                              largest.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GERS                                                      
!> \verbatim                                                            
!>          GERS is DOUBLE PRECISION array, dimension (2*N)             
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
!>          is (GERS(2*i-1), GERS(2*i)).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is DOUBLE PRECISION                                  
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than RELTOL times the larger (in                
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The (n-1) off-diagonal elements of the tridiagonal matrix T.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N-1)               
!>          The (n-1) squared off-diagonal elements of the tridiagonal m
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot allowed in the Sturm sequence for T.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NSPLIT                                                    
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of diagonal blocks in the matrix T.              
!>          1 <= NSPLIT <= N.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to ISPLIT(1),
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!>          (Only the first NSPLIT elements will actually be used, but  
!>          since the user cannot know a priori what value NSPLIT will  
!>          have, N words must be reserved for ISPLIT.)                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The actual number of eigenvalues found. 0 <= M <= N.        
!>          (See also the description of INFO=2,3.)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          On exit, the first M elements of W will contain the         
!>          eigenvalue approximations. DLARRD computes an interval      
!>          I_j = (a_j, b_j] that includes eigenvalue j. The eigenvalue 
      END                                           
!>          approximation is given as the interval midpoint             
!>          W(j)= ( a_j + b_j)/2. The corresponding error is bounded by 
!>          WERR(j) = abs( a_j - b_j)/2                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension (N)               
!>          The error bound on the corresponding eigenvalue approximatio
!>          in W.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WL                                                       
!> \verbatim                                                            
!>          WL is DOUBLE PRECISION                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WU                                                       
!> \verbatim                                                            
!>          WU is DOUBLE PRECISION                                      
!>          The interval (WL, WU] contains all the wanted eigenvalues.  
!>          If RANGE='V', then WL=VL and WU=VU.                         
!>          If RANGE='A', then WL and WU are the global Gerschgorin boun
!>                        on the spectrum.                              
!>          If RANGE='I', then WL and WU are computed by DLAEBZ from the
!>                        index range specified.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          At each row/column j where E(j) is zero or small, the       
!>          matrix T is considered to split into a block diagonal       
!>          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which 
!>          block (from 1 to the number of blocks) the eigenvalue W(i)  
!>          belongs.  (DLARRD may use the remaining N-M elements as     
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INDEXW                                                   
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= j and IBLOCK(i)=k imply that the    
!>          i-th eigenvalue W(i) is the j-th eigenvalue in block k.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (4*N)             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (3*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  some or all of the eigenvalues failed to converge or  
!>                were not computed:                                    
!>                =1 or 3: Bisection failed to converge for some        
!>                        eigenvalues; these eigenvalues are flagged by 
!>                        negative block number.  The effect is that the
!>                        eigenvalues may not be as accurate as the     
!>                        absolute and relative tolerances.  This is    
!>                        generally caused by unexpectedly inaccurate   
!>                        arithmetic.                                   
!>                =2 or 3: RANGE='I' only: Not all of the eigenvalues   
!>                        IL:IU were found.                             
!>                        Effect: M < IU+1-IL                           
!>                        Cause:  non-monotonic arithmetic, causing the 
!>                                Sturm sequence to be non-monotonic.   
!>                        Cure:   recalculate, using RANGE='A', and pick
!>                                out eigenvalues IL:IU.  In some cases,
!>                                increasing the PARAMETER "FUDGE" may  
!>                                make things work.                     
!>                = 4:    RANGE='I', and the Gershgorin interval        
!>                        initially used was too small.  No eigenvalues 
!>                        were computed.                                
!>                        Probable cause: your machine has sloppy       
!>                                        floating-point arithmetic.    
!>                        Cure: Increase the PARAMETER "FUDGE",         
!>                              recompile, and try again.               
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  FUDGE   DOUBLE PRECISION, default = 2                               
!>          A "fudge factor" to widen the Gershgorin intervals.  Ideally
!>          a value of 1 should work, but on machines with sloppy       
!>          arithmetic, this needs to be larger.  The default for       
!>          publicly released versions should be large enough to handle 
!>          the worst machine around.  Note that this has no effect     
!>          on accuracy of the solution.                                
!> \endverbatim                                                         
!>                                                                      
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     W. Kahan, University of California, Berkeley, USA \n             
!>     Beresford Parlett, University of California, Berkeley, USA \n    
!>     Jim Demmel, University of California, Berkeley, USA \n           
!>     Inderjit Dhillon, University of Texas, Austin, USA \n            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRD( RANGE, ORDER, N, VL, VU, IL, IU, GERS,         &
&                    RELTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,     &
&                    M, W, WERR, WL, WU, IBLOCK, INDEXW,           &
&                    WORK, IWORK, INFO )                           
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ORDER, RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      DOUBLE PRECISION    PIVMIN, RELTOL, VL, VU, WL, WU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), INDEXW( * ),                      &
&                   ISPLIT( * ), IWORK( * )                        
      DOUBLE PRECISION   D( * ), E( * ), E2( * ),                       &
&                   GERS( * ), W( * ), WERR( * ), WORK( * )        
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TWO, HALF, FUDGE 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,                   &
&                     TWO = 2.0D0, HALF = ONE/TWO,                 &
&                     FUDGE = TWO )                                
      INTEGER   ALLRNG, VALRNG, INDRNG 
      PARAMETER ( ALLRNG = 1, VALRNG = 2, INDRNG = 3 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            NCNVRG, TOOFEW 
      INTEGER            I, IB, IBEGIN, IDISCL, IDISCU, IE, IEND, IINFO,&
&                   IM, IN, IOFF, IOUT, IRANGE, ITMAX, ITMP1,      &
&                   ITMP2, IW, IWOFF, J, JBLK, JDISC, JE, JEE, NB, &
&                   NWL, NWU                                       
      DOUBLE PRECISION   ATOLI, EPS, GL, GU, RTOLI, TMP1, TMP2,         &
&                   TNORM, UFLOW, WKILL, WLU, WUL                  
                                                                        
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            IDUMMA( 1 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           LSAME, ILAENV, DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLAEBZ 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
      IRANGE = ALLRNG 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
      IRANGE = VALRNG 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
      IRANGE = INDRNG 
      ELSE 
      IRANGE = 0 
      END IF 
!                                                                       
!     Check for Errors                                                  
!                                                                       
      IF( IRANGE.LE.0 ) THEN 
      INFO = -1 
      ELSE IF( .NOT.(LSAME(ORDER,'B').OR.LSAME(ORDER,'E')) ) THEN 
      INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( IRANGE.EQ.VALRNG ) THEN 
      IF( VL.GE.VU )                                                 &
&      INFO = -5                                                   
      ELSE IF( IRANGE.EQ.INDRNG .AND.                                   &
&        ( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) ) THEN                 
      INFO = -6 
      ELSE IF( IRANGE.EQ.INDRNG .AND.                                   &
&        ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) ) THEN                
      INFO = -7 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      RETURN 
      END IF 
                                                                        
!     Initialize error flags                                            
      INFO = 0 
      NCNVRG = .FALSE. 
      TOOFEW = .FALSE. 
                                                                        
!     Quick return if possible                                          
      M = 0 
      IF( N.EQ.0 ) RETURN 
                                                                        
!     Simplification:                                                   
      IF( IRANGE.EQ.INDRNG .AND. IL.EQ.1 .AND. IU.EQ.N ) IRANGE = 1 
                                                                        
!     Get machine constants                                             
      EPS = DLAMCH( 'P' ) 
      UFLOW = DLAMCH( 'U' ) 
                                                                        
                                                                        
!     Special Case when N=1                                             
!     Treat case of 1x1 matrix for quick return                         
      IF( N.EQ.1 ) THEN 
      IF( (IRANGE.EQ.ALLRNG).OR.                                     &
&       ((IRANGE.EQ.VALRNG).AND.(D(1).GT.VL).AND.(D(1).LE.VU)).OR. &
&       ((IRANGE.EQ.INDRNG).AND.(IL.EQ.1).AND.(IU.EQ.1)) ) THEN    
            M = 1 
            W(1) = D(1) 
!           The computation error of the eigenvalue is zero             
            WERR(1) = ZERO 
            IBLOCK( 1 ) = 1 
            INDEXW( 1 ) = 1 
      ENDIF 
      RETURN 
      END IF 
                                                                        
!     NB is the minimum vector length for vector bisection, or 0        
!     if only scalar is to be done.                                     
      NB = ILAENV( 1, 'DSTEBZ', ' ', N, -1, -1, -1 ) 
      IF( NB.LE.1 ) NB = 0 
                                                                        
!     Find global spectral radius                                       
      GL = D(1) 
      GU = D(1) 
      DO 5 I = 1,N 
      GL =  MIN( GL, GERS( 2*I - 1)) 
      GU = MAX( GU, GERS(2*I) ) 
5 END DO 
!     Compute global Gerschgorin bounds and spectral diameter           
      TNORM = MAX( ABS( GL ), ABS( GU ) ) 
      GL = GL - FUDGE*TNORM*EPS*N - FUDGE*TWO*PIVMIN 
      GU = GU + FUDGE*TNORM*EPS*N + FUDGE*TWO*PIVMIN 
!     [JAN/28/2009] remove the line below since SPDIAM variable not use 
!     SPDIAM = GU - GL                                                  
!     Input arguments for DLAEBZ:                                       
!     The relative tolerance.  An interval (a,b] lies within            
!     "relative tolerance" if  b-a < RELTOL*max(|a|,|b|),               
      RTOLI = RELTOL 
!     Set the absolute tolerance for interval convergence to zero to for
!     interval convergence based on relative size of the interval.      
!     This is dangerous because intervals might not converge when RELTOL
!     small. But at least a very small number should be selected so that
!     strongly graded matrices, the code can get relatively accurate    
!     eigenvalues.                                                      
      ATOLI = FUDGE*TWO*UFLOW + FUDGE*TWO*PIVMIN 
                                                                        
      IF( IRANGE.EQ.INDRNG ) THEN 
                                                                        
!        RANGE='I': Compute an interval containing eigenvalues          
!        IL through IU. The initial interval [GL,GU] from the global    
!        Gerschgorin bounds GL and GU is refined by DLAEBZ.             
      ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /           &
&           LOG( TWO ) ) + 2                                       
      WORK( N+1 ) = GL 
      WORK( N+2 ) = GL 
      WORK( N+3 ) = GU 
      WORK( N+4 ) = GU 
      WORK( N+5 ) = GL 
      WORK( N+6 ) = GU 
      IWORK( 1 ) = -1 
      IWORK( 2 ) = -1 
      IWORK( 3 ) = N + 1 
      IWORK( 4 ) = N + 1 
      IWORK( 5 ) = IL - 1 
      IWORK( 6 ) = IU 
!                                                                       
      CALL DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN,      &
&         D, E, E2, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,    &
&                IWORK, W, IBLOCK, IINFO )                         
      IF( IINFO .NE. 0 ) THEN 
            INFO = IINFO 
            RETURN 
      END IF 
!        On exit, output intervals may not be ordered by ascending negco
      IF( IWORK( 6 ).EQ.IU ) THEN 
            WL = WORK( N+1 ) 
            WLU = WORK( N+3 ) 
            NWL = IWORK( 1 ) 
            WU = WORK( N+4 ) 
            WUL = WORK( N+2 ) 
            NWU = IWORK( 4 ) 
      ELSE 
            WL = WORK( N+2 ) 
            WLU = WORK( N+4 ) 
            NWL = IWORK( 2 ) 
            WU = WORK( N+3 ) 
            WUL = WORK( N+1 ) 
            NWU = IWORK( 3 ) 
      END IF 
!        On exit, the interval [WL, WLU] contains a value with negcount 
!        and [WUL, WU] contains a value with negcount NWU.              
      IF( NWL.LT.0 .OR. NWL.GE.N .OR. NWU.LT.1 .OR. NWU.GT.N ) THEN 
            INFO = 4 
            RETURN 
      END IF 
                                                                        
      ELSEIF( IRANGE.EQ.VALRNG ) THEN 
      WL = VL 
      WU = VU 
                                                                        
      ELSEIF( IRANGE.EQ.ALLRNG ) THEN 
      WL = GL 
      WU = GU 
      ENDIF 
                                                                        
                                                                        
                                                                        
!     Find Eigenvalues -- Loop Over blocks and recompute NWL and NWU.   
!     NWL accumulates the number of eigenvalues .le. WL,                
!     NWU accumulates the number of eigenvalues .le. WU                 
      M = 0 
      IEND = 0 
      INFO = 0 
      NWL = 0 
      NWU = 0 
!                                                                       
      DO 70 JBLK = 1, NSPLIT 
      IOFF = IEND 
      IBEGIN = IOFF + 1 
      IEND = ISPLIT( JBLK ) 
      IN = IEND - IOFF 
!                                                                       
      IF( IN.EQ.1 ) THEN 
!           1x1 block                                                   
            IF( WL.GE.D( IBEGIN )-PIVMIN )                              &
&         NWL = NWL + 1                                            
            IF( WU.GE.D( IBEGIN )-PIVMIN )                              &
&         NWU = NWU + 1                                            
            IF( IRANGE.EQ.ALLRNG .OR.                                   &
&           ( WL.LT.D( IBEGIN )-PIVMIN                             &
&             .AND. WU.GE. D( IBEGIN )-PIVMIN ) ) THEN             
            M = M + 1 
            W( M ) = D( IBEGIN ) 
            WERR(M) = ZERO 
!              The gap for a single block doesn't matter for the later  
!              algorithm and is assigned an arbitrary large value       
            IBLOCK( M ) = JBLK 
            INDEXW( M ) = 1 
            END IF 
                                                                        
!        Disabled 2x2 case because of a failure on the following matrix 
!        RANGE = 'I', IL = IU = 4                                       
!          Original Tridiagonal, d = [                                  
!           -0.150102010615740E+00                                      
!           -0.849897989384260E+00                                      
!           -0.128208148052635E-15                                      
!            0.128257718286320E-15                                      
!          ];                                                           
!          e = [                                                        
!           -0.357171383266986E+00                                      
!           -0.180411241501588E-15                                      
!           -0.175152352710251E-15                                      
!          ];                                                           
!                                                                       
!         ELSE IF( IN.EQ.2 ) THEN                                       
!*           2x2 block                                                  
!            DISC = SQRT( (HALF*(D(IBEGIN)-D(IEND)))**2 + E(IBEGIN)**2 )
!            TMP1 = HALF*(D(IBEGIN)+D(IEND))                            
!            L1 = TMP1 - DISC                                           
!            IF( WL.GE. L1-PIVMIN )                                     
!     $         NWL = NWL + 1                                           
!            IF( WU.GE. L1-PIVMIN )                                     
!     $         NWU = NWU + 1                                           
!            IF( IRANGE.EQ.ALLRNG .OR. ( WL.LT.L1-PIVMIN .AND. WU.GE.   
!     $          L1-PIVMIN ) ) THEN                                     
!               M = M + 1                                               
!               W( M ) = L1                                             
!*              The uncertainty of eigenvalues of a 2x2 matrix is very s
!               WERR( M ) = EPS * ABS( W( M ) ) * TWO                   
!               IBLOCK( M ) = JBLK                                      
!               INDEXW( M ) = 1                                         
!            ENDIF                                                      
!            L2 = TMP1 + DISC                                           
!            IF( WL.GE. L2-PIVMIN )                                     
!     $         NWL = NWL + 1                                           
!            IF( WU.GE. L2-PIVMIN )                                     
!     $         NWU = NWU + 1                                           
!            IF( IRANGE.EQ.ALLRNG .OR. ( WL.LT.L2-PIVMIN .AND. WU.GE.   
!     $          L2-PIVMIN ) ) THEN                                     
!               M = M + 1                                               
!               W( M ) = L2                                             
!*              The uncertainty of eigenvalues of a 2x2 matrix is very s
!               WERR( M ) = EPS * ABS( W( M ) ) * TWO                   
!               IBLOCK( M ) = JBLK                                      
!               INDEXW( M ) = 2                                         
!            ENDIF                                                      
      ELSE 
!           General Case - block of size IN >= 2                        
!           Compute local Gerschgorin interval and use it as the initial
!           interval for DLAEBZ                                         
            GU = D( IBEGIN ) 
            GL = D( IBEGIN ) 
            TMP1 = ZERO 
                                                                        
            DO 40 J = IBEGIN, IEND 
            GL =  MIN( GL, GERS( 2*J - 1)) 
            GU = MAX( GU, GERS(2*J) ) 
40       CONTINUE 
!           [JAN/28/2009]                                               
!           change SPDIAM by TNORM in lines 2 and 3 thereafter          
!           line 1: remove computation of SPDIAM (not useful anymore)   
!           SPDIAM = GU - GL                                            
!           GL = GL - FUDGE*SPDIAM*EPS*IN - FUDGE*PIVMIN                
!           GU = GU + FUDGE*SPDIAM*EPS*IN + FUDGE*PIVMIN                
            GL = GL - FUDGE*TNORM*EPS*IN - FUDGE*PIVMIN 
            GU = GU + FUDGE*TNORM*EPS*IN + FUDGE*PIVMIN 
!                                                                       
            IF( IRANGE.GT.1 ) THEN 
            IF( GU.LT.WL ) THEN 
!                 the local block contains none of the wanted eigenvalue
                  NWL = NWL + IN 
                  NWU = NWU + IN 
                  GO TO 70 
            END IF 
!              refine search interval if possible, only range (WL,WU] ma
            GL = MAX( GL, WL ) 
            GU = MIN( GU, WU ) 
            IF( GL.GE.GU )                                           &
&            GO TO 70                                              
            END IF 
                                                                        
!           Find negcount of initial interval boundaries GL and GU      
            WORK( N+1 ) = GL 
            WORK( N+IN+1 ) = GU 
            CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,     &
&                   D( IBEGIN ), E( IBEGIN ), E2( IBEGIN ),        &
&                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,     &
&                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
            IF( IINFO .NE. 0 ) THEN 
            INFO = IINFO 
            RETURN 
            END IF 
!                                                                       
            NWL = NWL + IWORK( 1 ) 
            NWU = NWU + IWORK( IN+1 ) 
            IWOFF = M - IWORK( 1 ) 
                                                                        
!           Compute Eigenvalues                                         
            ITMAX = INT( ( LOG( GU-GL+PIVMIN )-LOG( PIVMIN ) ) /        &
&              LOG( TWO ) ) + 2                                    
            CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN, &
&                   D( IBEGIN ), E( IBEGIN ), E2( IBEGIN ),        &
&                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,   &
&                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
            IF( IINFO .NE. 0 ) THEN 
            INFO = IINFO 
            RETURN 
            END IF 
!                                                                       
!           Copy eigenvalues into W and IBLOCK                          
!           Use -JBLK for block number for unconverged eigenvalues.     
!           Loop over the number of output intervals from DLAEBZ        
            DO 60 J = 1, IOUT 
!              eigenvalue approximation is middle point of interval     
            TMP1 = HALF*( WORK( J+N )+WORK( J+IN+N ) ) 
!              semi length of error interval                            
            TMP2 = HALF*ABS( WORK( J+N )-WORK( J+IN+N ) ) 
            IF( J.GT.IOUT-IINFO ) THEN 
!                 Flag non-convergence.                                 
                  NCNVRG = .TRUE. 
                  IB = -JBLK 
            ELSE 
                  IB = JBLK 
            END IF 
            DO 50 JE = IWORK( J ) + 1 + IWOFF,                       &
&                 IWORK( J+IN ) + IWOFF                            
                  W( JE ) = TMP1 
                  WERR( JE ) = TMP2 
                  INDEXW( JE ) = JE - IWOFF 
                  IBLOCK( JE ) = IB 
50          CONTINUE 
60       CONTINUE 
!                                                                       
            M = M + IM 
      END IF 
70 END DO 
                                                                        
!     If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU     
!     If NWL+1 < IL or NWU > IU, discard extra eigenvalues.             
      IF( IRANGE.EQ.INDRNG ) THEN 
      IDISCL = IL - 1 - NWL 
      IDISCU = NWU - IU 
!                                                                       
      IF( IDISCL.GT.0 ) THEN 
            IM = 0 
            DO 80 JE = 1, M 
!              Remove some of the smallest eigenvalues from the left so 
!              at the end IDISCL =0. Move all eigenvalues up to the left
            IF( W( JE ).LE.WLU .AND. IDISCL.GT.0 ) THEN 
                  IDISCL = IDISCL - 1 
            ELSE 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
            END IF 
80       CONTINUE 
            M = IM 
      END IF 
      IF( IDISCU.GT.0 ) THEN 
!           Remove some of the largest eigenvalues from the right so tha
!           at the end IDISCU =0. Move all eigenvalues up to the left.  
            IM=M+1 
            DO 81 JE = M, 1, -1 
            IF( W( JE ).GE.WUL .AND. IDISCU.GT.0 ) THEN 
                  IDISCU = IDISCU - 1 
            ELSE 
                  IM = IM - 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
            END IF 
81       CONTINUE 
            JEE = 0 
            DO 82 JE = IM, M 
            JEE = JEE + 1 
            W( JEE ) = W( JE ) 
            WERR( JEE ) = WERR( JE ) 
            INDEXW( JEE ) = INDEXW( JE ) 
            IBLOCK( JEE ) = IBLOCK( JE ) 
82       CONTINUE 
            M = M-IM+1 
      END IF 
                                                                        
      IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
!           Code to deal with effects of bad arithmetic. (If N(w) is    
!           monotone non-decreasing, this should never happen.)         
!           Some low eigenvalues to be discarded are not in (WL,WLU],   
!           or high eigenvalues to be discarded are not in (WUL,WU]     
!           so just kill off the smallest IDISCL/largest IDISCU         
!           eigenvalues, by marking the corresponding IBLOCK = 0        
            IF( IDISCL.GT.0 ) THEN 
            WKILL = WU 
            DO 100 JDISC = 1, IDISCL 
                  IW = 0 
                  DO 90 JE = 1, M 
                  IF( IBLOCK( JE ).NE.0 .AND.                        &
&                    ( W( JE ).LT.WKILL .OR. IW.EQ.0 ) ) THEN      
                        IW = JE 
                        WKILL = W( JE ) 
                  END IF 
90             CONTINUE 
                  IBLOCK( IW ) = 0 
100          CONTINUE 
            END IF 
            IF( IDISCU.GT.0 ) THEN 
            WKILL = WL 
            DO 120 JDISC = 1, IDISCU 
                  IW = 0 
                  DO 110 JE = 1, M 
                  IF( IBLOCK( JE ).NE.0 .AND.                        &
&                    ( W( JE ).GE.WKILL .OR. IW.EQ.0 ) ) THEN      
                        IW = JE 
                        WKILL = W( JE ) 
                  END IF 
110             CONTINUE 
                  IBLOCK( IW ) = 0 
120          CONTINUE 
            END IF 
!           Now erase all eigenvalues with IBLOCK set to zero           
            IM = 0 
            DO 130 JE = 1, M 
            IF( IBLOCK( JE ).NE.0 ) THEN 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  WERR( IM ) = WERR( JE ) 
                  INDEXW( IM ) = INDEXW( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
            END IF 
130       CONTINUE 
            M = IM 
      END IF 
      IF( IDISCL.LT.0 .OR. IDISCU.LT.0 ) THEN 
            TOOFEW = .TRUE. 
      END IF 
      END IF 
!                                                                       
      IF(( IRANGE.EQ.ALLRNG .AND. M.NE.N ).OR.                          &
&   ( IRANGE.EQ.INDRNG .AND. M.NE.IU-IL+1 ) ) THEN                 
      TOOFEW = .TRUE. 
      END IF 
                                                                        
!     If ORDER='B', do nothing the eigenvalues are already sorted by    
!        block.                                                         
!     If ORDER='E', sort the eigenvalues from smallest to largest       
                                                                        
      IF( LSAME(ORDER,'E') .AND. NSPLIT.GT.1 ) THEN 
      DO 150 JE = 1, M - 1 
            IE = 0 
            TMP1 = W( JE ) 
            DO 140 J = JE + 1, M 
            IF( W( J ).LT.TMP1 ) THEN 
                  IE = J 
                  TMP1 = W( J ) 
            END IF 
140       CONTINUE 
            IF( IE.NE.0 ) THEN 
            TMP2 = WERR( IE ) 
            ITMP1 = IBLOCK( IE ) 
            ITMP2 = INDEXW( IE ) 
            W( IE ) = W( JE ) 
            WERR( IE ) = WERR( JE ) 
            IBLOCK( IE ) = IBLOCK( JE ) 
            INDEXW( IE ) = INDEXW( JE ) 
            W( JE ) = TMP1 
            WERR( JE ) = TMP2 
            IBLOCK( JE ) = ITMP1 
            INDEXW( JE ) = ITMP2 
            END IF 
150    CONTINUE 
      END IF 
!                                                                       
      INFO = 0 
      IF( NCNVRG )                                                      &
&   INFO = INFO + 1                                                
      IF( TOOFEW )                                                      &
&   INFO = INFO + 2                                                
      RETURN 
!                                                                       
!     End of DLARRD                                                     
!                                                                       
!> \brief \b DLARRE given the tridiagonal matrix T, sets small off-diago
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRE + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRE( RANGE, N, VL, VU, IL, IU, D, E, E2,          
!                           RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M,    
!                           W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN,
!                           WORK, IWORK, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          RANGE                                        
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       DOUBLE PRECISION  PIVMIN, RTOL1, RTOL2, SPLTOL, VL, VU          
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ),        
!      $                   INDEXW( * )                                  
!       DOUBLE PRECISION   D( * ), E( * ), E2( * ), GERS( * ),          
!      $                   W( * ),WERR( * ), WGAP( * ), WORK( * )       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> To find the desired eigenvalues of a given real symmetric            
!> tridiagonal matrix T, DLARRE sets any "small" off-diagonal           
!> elements to zero, and for each unreduced block T_i, it finds         
!> (a) a suitable shift at one end of the block's spectrum,             
!> (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and    
!> (c) eigenvalues of each L_i D_i L_i^T.                               
!> The representations and eigenvalues found are then used by           
!> DSTEMR to compute the eigenvectors of T.                             
!> The accuracy varies depending on whether bisection is used to        
!> find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to  
!> conpute all and then discard any unwanted one.                       
!> As an added benefit, DLARRE also outputs the n                       
!> Gerschgorin intervals for the matrices L_i D_i L_i^T.                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] VL                                                    
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>          If RANGE='V', the lower bound for the eigenvalues.          
!>          Eigenvalues less than or equal to VL, or greater than VU,   
!>          will not be returned.  VL < VU.                             
!>          If RANGE='I' or ='A', DLARRE computes bounds on the desired 
!>          part of the spectrum.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] VU                                                    
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>          If RANGE='V', the upper bound for the eigenvalues.          
!>          Eigenvalues less than or equal to VL, or greater than VU,   
!>          will not be returned.  VL < VU.                             
!>          If RANGE='I' or ='A', DLARRE computes bounds on the desired 
!>          part of the spectrum.                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the N diagonal elements of the tridiagonal        
!>          matrix T.                                                   
!>          On exit, the N diagonal elements of the diagonal            
!>          matrices D_i.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) need not be set. 
!>          On exit, E contains the subdiagonal elements of the unit    
!>          bidiagonal matrices L_i. The entries E( ISPLIT( I ) ),      
!>          1 <= I <= NSPLIT, contain the base points sigma_i on output.
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E2                                                    
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N)                 
!>          On entry, the first (N-1) entries contain the SQUARES of the
!>          subdiagonal elements of the tridiagonal matrix T;           
!>          E2(N) need not be set.                                      
!>          On exit, the entries E2( ISPLIT( I ) ),                     
!>          1 <= I <= NSPLIT, have been set to zero                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is DOUBLE PRECISION                                   
!>           Parameters for bisection.                                  
!>           An interval [LEFT,RIGHT] has converged if                  
!>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPLTOL                                                    
!> \verbatim                                                            
!>          SPLTOL is DOUBLE PRECISION                                  
!>          The threshold for splitting.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of blocks T splits into. 1 <= NSPLIT <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to ISPLIT(1),    
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues (of all L_i D_i L_i^T)      
!>          found.                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          The first M elements contain the eigenvalues. The           
!>          eigenvalues of each of the blocks, L_i D_i L_i^T, are       
!>          sorted in ascending order ( DLARRE may use the              
!>          remaining N-M elements as workspace).                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension (N)               
!>          The error bound on the corresponding eigenvalue in W.       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WGAP                                                     
!> \verbatim                                                            
      END                                           
!>          WGAP is DOUBLE PRECISION array, dimension (N)               
!>          The separation from the right neighbor eigenvalue in W.     
!>          The gap is only with respect to the eigenvalues of the same 
!>          as each block has its own representation tree.              
!>          Exception: at the right end of a block we store the left gap
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The indices of the blocks (submatrices) associated with the 
!>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue   
!>          W(i) belongs to the first block from the top, =2 if W(i)    
!>          belongs to the second block, etc.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INDEXW                                                   
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the   
!>          i-th eigenvalue W(i) is the 10-th eigenvalue in block 2     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] GERS                                                     
!> \verbatim                                                            
!>          GERS is DOUBLE PRECISION array, dimension (2*N)             
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
!>          is (GERS(2*i-1), GERS(2*i)).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] PIVMIN                                                   
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (6*N)             
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (5*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          > 0:  A problem occurred in DLARRE.                         
!>          < 0:  One of the called subroutines signaled an internal pro
!>                Needs inspection of the corresponding parameter IINFO 
!>                for further information.                              
!>                                                                      
!>          =-1:  Problem in DLARRD.                                    
!>          = 2:  No base representation could be found in MAXTRY iterat
!>                Increasing MAXTRY and recompilation might be a remedy.
!>          =-3:  Problem in DLARRB when computing the refined root     
!>                representation for DLASQ2.                            
!>          =-4:  Problem in DLARRB when preforming bisection on the    
!>                desired part of the spectrum.                         
!>          =-5:  Problem in DLASQ2.                                    
!>          =-6:  Problem in DLASQ2.                                    
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The base representations are required to suffer very little         
!>  element growth and consequently define all their eigenvalues to     
!>  high relative accuracy.                                             
!> \endverbatim                                                         
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Beresford Parlett, University of California, Berkeley, USA \n    
!>     Jim Demmel, University of California, Berkeley, USA \n           
!>     Inderjit Dhillon, University of Texas, Austin, USA \n            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Christof Voemel, University of California, Berkeley, USA \n      
!>                                                                      
!  =====================================================================
      SUBROUTINE DLARRE( RANGE, N, VL, VU, IL, IU, D, E, E2,            &
&                    RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M,      &
&                    W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN,  &
&                    WORK, IWORK, INFO )                           
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      DOUBLE PRECISION  PIVMIN, RTOL1, RTOL2, SPLTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ),          &
&                   INDEXW( * )                                    
      DOUBLE PRECISION   D( * ), E( * ), E2( * ), GERS( * ),            &
&                   W( * ),WERR( * ), WGAP( * ), WORK( * )         
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   FAC, FOUR, FOURTH, FUDGE, HALF, HNDRD,         &
&                   MAXGROWTH, ONE, PERT, TWO, ZERO                
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,                   &
&                     TWO = 2.0D0, FOUR=4.0D0,                     &
&                     HNDRD = 100.0D0,                             &
&                     PERT = 8.0D0,                                &
&                     HALF = ONE/TWO, FOURTH = ONE/FOUR, FAC= HALF,&
&                     MAXGROWTH = 64.0D0, FUDGE = 2.0D0 )          
      INTEGER            MAXTRY, ALLRNG, INDRNG, VALRNG 
      PARAMETER          ( MAXTRY = 6, ALLRNG = 1, INDRNG = 2,          &
&                     VALRNG = 3 )                                 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            FORCEB, NOREP, USEDQD 
      INTEGER            CNT, CNT1, CNT2, I, IBEGIN, IDUM, IEND, IINFO, &
&                   IN, INDL, INDU, IRANGE, J, JBLK, MB, MM,       &
&                   WBEGIN, WEND                                   
      DOUBLE PRECISION   AVGAP, BSRTOL, CLWDTH, DMAX, DPIVOT, EABS,     &
&                   EMAX, EOLD, EPS, GL, GU, ISLEFT, ISRGHT, RTL,  &
&                   RTOL, S1, S2, SAFMIN, SGNDEF, SIGMA, SPDIAM,   &
&                   TAU, TMP, TMP1                                 
                                                                        
                                                                        
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            ISEED( 4 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      DOUBLE PRECISION            DLAMCH 
      EXTERNAL           DLAMCH, LSAME 
                                                                        
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY, DLARNV, DLARRA, DLARRB, DLARRC, DLARRD, &
&                   DLASQ2, DLARRK                                 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
                                                                        
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
                                                                        
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
      IRANGE = ALLRNG 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
      IRANGE = VALRNG 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
      IRANGE = INDRNG 
      END IF 
                                                                        
      M = 0 
                                                                        
!     Get machine constants                                             
      SAFMIN = DLAMCH( 'S' ) 
      EPS = DLAMCH( 'P' ) 
                                                                        
!     Set parameters                                                    
      RTL = SQRT(EPS) 
      BSRTOL = SQRT(EPS) 
                                                                        
!     Treat case of 1x1 matrix for quick return                         
      IF( N.EQ.1 ) THEN 
      IF( (IRANGE.EQ.ALLRNG).OR.                                     &
&       ((IRANGE.EQ.VALRNG).AND.(D(1).GT.VL).AND.(D(1).LE.VU)).OR. &
&       ((IRANGE.EQ.INDRNG).AND.(IL.EQ.1).AND.(IU.EQ.1)) ) THEN    
            M = 1 
            W(1) = D(1) 
!           The computation error of the eigenvalue is zero             
            WERR(1) = ZERO 
            WGAP(1) = ZERO 
            IBLOCK( 1 ) = 1 
            INDEXW( 1 ) = 1 
            GERS(1) = D( 1 ) 
            GERS(2) = D( 1 ) 
      ENDIF 
!        store the shift for the initial RRR, which is zero in this case
      E(1) = ZERO 
      RETURN 
      END IF 
                                                                        
!     General case: tridiagonal matrix of order > 1                     
!                                                                       
!     Init WERR, WGAP. Compute Gerschgorin intervals and spectral diamet
!     Compute maximum off-diagonal entry and pivmin.                    
      GL = D(1) 
      GU = D(1) 
      EOLD = ZERO 
      EMAX = ZERO 
      E(N) = ZERO 
      DO 5 I = 1,N 
      WERR(I) = ZERO 
      WGAP(I) = ZERO 
      EABS = ABS( E(I) ) 
      IF( EABS .GE. EMAX ) THEN 
            EMAX = EABS 
      END IF 
      TMP1 = EABS + EOLD 
      GERS( 2*I-1) = D(I) - TMP1 
      GL =  MIN( GL, GERS( 2*I - 1)) 
      GERS( 2*I ) = D(I) + TMP1 
      GU = MAX( GU, GERS(2*I) ) 
      EOLD  = EABS 
5 END DO 
!     The minimum pivot allowed in the Sturm sequence for T             
      PIVMIN = SAFMIN * MAX( ONE, EMAX**2 ) 
!     Compute spectral diameter. The Gerschgorin bounds give an         
!     estimate that is wrong by at most a factor of SQRT(2)             
      SPDIAM = GU - GL 
                                                                        
!     Compute splitting points                                          
      CALL DLARRA( N, D, E, E2, SPLTOL, SPDIAM,                         &
&                    NSPLIT, ISPLIT, IINFO )                       
                                                                        
!     Can force use of bisection instead of faster DQDS.                
!     Option left in the code for future multisection work.             
      FORCEB = .FALSE. 
                                                                        
!     Initialize USEDQD, DQDS should be used for ALLRNG unless someone  
!     explicitly wants bisection.                                       
      USEDQD = (( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB)) 
                                                                        
      IF( (IRANGE.EQ.ALLRNG) .AND. (.NOT. FORCEB) ) THEN 
!        Set interval [VL,VU] that contains all eigenvalues             
      VL = GL 
      VU = GU 
      ELSE 
!        We call DLARRD to find crude approximations to the eigenvalues 
!        in the desired range. In case IRANGE = INDRNG, we also obtain t
!        interval (VL,VU] that contains all the wanted eigenvalues.     
!        An interval [LEFT,RIGHT] has converged if                      
!        RIGHT-LEFT.LT.RTOL*MAX(ABS(LEFT),ABS(RIGHT))                   
!        DLARRD needs a WORK of size 4*N, IWORK of size 3*N             
      CALL DLARRD( RANGE, 'B', N, VL, VU, IL, IU, GERS,              &
&                    BSRTOL, D, E, E2, PIVMIN, NSPLIT, ISPLIT,     &
&                    MM, W, WERR, VL, VU, IBLOCK, INDEXW,          &
&                    WORK, IWORK, IINFO )                          
      IF( IINFO.NE.0 ) THEN 
            INFO = -1 
            RETURN 
      ENDIF 
!        Make sure that the entries M+1 to N in W, WERR, IBLOCK, INDEXW 
      DO 14 I = MM+1,N 
            W( I ) = ZERO 
            WERR( I ) = ZERO 
            IBLOCK( I ) = 0 
            INDEXW( I ) = 0 
14    CONTINUE 
      END IF 
                                                                        
                                                                        
!**                                                                     
!     Loop over unreduced blocks                                        
      IBEGIN = 1 
      WBEGIN = 1 
      DO 170 JBLK = 1, NSPLIT 
      IEND = ISPLIT( JBLK ) 
      IN = IEND - IBEGIN + 1 
                                                                        
!        1 X 1 block                                                    
      IF( IN.EQ.1 ) THEN 
            IF( (IRANGE.EQ.ALLRNG).OR.( (IRANGE.EQ.VALRNG).AND.         &
&         ( D( IBEGIN ).GT.VL ).AND.( D( IBEGIN ).LE.VU ) )        &
&        .OR. ( (IRANGE.EQ.INDRNG).AND.(IBLOCK(WBEGIN).EQ.JBLK))   &
&        ) THEN                                                    
            M = M + 1 
            W( M ) = D( IBEGIN ) 
            WERR(M) = ZERO 
!              The gap for a single block doesn't matter for the later  
!              algorithm and is assigned an arbitrary large value       
            WGAP(M) = ZERO 
            IBLOCK( M ) = JBLK 
            INDEXW( M ) = 1 
            WBEGIN = WBEGIN + 1 
            ENDIF 
!           E( IEND ) holds the shift for the initial RRR               
            E( IEND ) = ZERO 
            IBEGIN = IEND + 1 
            GO TO 170 
      END IF 
!                                                                       
!        Blocks of size larger than 1x1                                 
!                                                                       
!        E( IEND ) will hold the shift for the initial RRR, for now set 
      E( IEND ) = ZERO 
!                                                                       
!        Find local outer bounds GL,GU for the block                    
      GL = D(IBEGIN) 
      GU = D(IBEGIN) 
      DO 15 I = IBEGIN , IEND 
            GL = MIN( GERS( 2*I-1 ), GL ) 
            GU = MAX( GERS( 2*I ), GU ) 
15    CONTINUE 
      SPDIAM = GU - GL 
                                                                        
      IF(.NOT. ((IRANGE.EQ.ALLRNG).AND.(.NOT.FORCEB)) ) THEN 
!           Count the number of eigenvalues in the current block.       
            MB = 0 
            DO 20 I = WBEGIN,MM 
            IF( IBLOCK(I).EQ.JBLK ) THEN 
                  MB = MB+1 
            ELSE 
                  GOTO 21 
            ENDIF 
20       CONTINUE 
21       CONTINUE 
                                                                        
            IF( MB.EQ.0) THEN 
!              No eigenvalue in the current block lies in the desired ra
!              E( IEND ) holds the shift for the initial RRR            
            E( IEND ) = ZERO 
            IBEGIN = IEND + 1 
            GO TO 170 
            ELSE 
                                                                        
!              Decide whether dqds or bisection is more efficient       
            USEDQD = ( (MB .GT. FAC*IN) .AND. (.NOT.FORCEB) ) 
            WEND = WBEGIN + MB - 1 
!              Calculate gaps for the current block                     
!              In later stages, when representations for individual     
!              eigenvalues are different, we use SIGMA = E( IEND ).     
            SIGMA = ZERO 
            DO 30 I = WBEGIN, WEND - 1 
                  WGAP( I ) = MAX( ZERO,                                &
&                        W(I+1)-WERR(I+1) - (W(I)+WERR(I)) )       
30          CONTINUE 
            WGAP( WEND ) = MAX( ZERO,                                &
&                     VU - SIGMA - (W( WEND )+WERR( WEND )))       
!              Find local index of the first and last desired evalue.   
            INDL = INDEXW(WBEGIN) 
            INDU = INDEXW( WEND ) 
            ENDIF 
      ENDIF 
      IF(( (IRANGE.EQ.ALLRNG) .AND. (.NOT. FORCEB) ).OR.USEDQD) THEN 
!           Case of DQDS                                                
!           Find approximations to the extremal eigenvalues of the block
            CALL DLARRK( IN, 1, GL, GU, D(IBEGIN),                      &
&               E2(IBEGIN), PIVMIN, RTL, TMP, TMP1, IINFO )        
            IF( IINFO.NE.0 ) THEN 
            INFO = -1 
            RETURN 
            ENDIF 
            ISLEFT = MAX(GL, TMP - TMP1                                 &
&               - HNDRD * EPS* ABS(TMP - TMP1))                    
                                                                        
            CALL DLARRK( IN, IN, GL, GU, D(IBEGIN),                     &
&               E2(IBEGIN), PIVMIN, RTL, TMP, TMP1, IINFO )        
            IF( IINFO.NE.0 ) THEN 
            INFO = -1 
            RETURN 
            ENDIF 
            ISRGHT = MIN(GU, TMP + TMP1                                 &
&                 + HNDRD * EPS * ABS(TMP + TMP1))                 
!           Improve the estimate of the spectral diameter               
            SPDIAM = ISRGHT - ISLEFT 
      ELSE 
!           Case of bisection                                           
!           Find approximations to the wanted extremal eigenvalues      
            ISLEFT = MAX(GL, W(WBEGIN) - WERR(WBEGIN)                   &
&                  - HNDRD * EPS*ABS(W(WBEGIN)- WERR(WBEGIN) ))    
            ISRGHT = MIN(GU,W(WEND) + WERR(WEND)                        &
&                  + HNDRD * EPS * ABS(W(WEND)+ WERR(WEND)))       
      ENDIF 
                                                                        
                                                                        
!        Decide whether the base representation for the current block   
!        L_JBLK D_JBLK L_JBLK^T = T_JBLK - sigma_JBLK I                 
!        should be on the left or the right end of the current block.   
!        The strategy is to shift to the end which is "more populated"  
!        Furthermore, decide whether to use DQDS for the computation of 
!        the eigenvalue approximations at the end of DLARRE or bisection
!        dqds is chosen if all eigenvalues are desired or the number of 
!        eigenvalues to be computed is large compared to the blocksize. 
      IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
!           If all the eigenvalues have to be computed, we use dqd      
            USEDQD = .TRUE. 
!           INDL is the local index of the first eigenvalue to compute  
            INDL = 1 
            INDU = IN 
!           MB =  number of eigenvalues to compute                      
            MB = IN 
            WEND = WBEGIN + MB - 1 
!           Define 1/4 and 3/4 points of the spectrum                   
            S1 = ISLEFT + FOURTH * SPDIAM 
            S2 = ISRGHT - FOURTH * SPDIAM 
      ELSE 
!           DLARRD has computed IBLOCK and INDEXW for each eigenvalue   
!           approximation.                                              
!           choose sigma                                                
            IF( USEDQD ) THEN 
            S1 = ISLEFT + FOURTH * SPDIAM 
            S2 = ISRGHT - FOURTH * SPDIAM 
            ELSE 
            TMP = MIN(ISRGHT,VU) -  MAX(ISLEFT,VL) 
            S1 =  MAX(ISLEFT,VL) + FOURTH * TMP 
            S2 =  MIN(ISRGHT,VU) - FOURTH * TMP 
            ENDIF 
      ENDIF 
                                                                        
!        Compute the negcount at the 1/4 and 3/4 points                 
      IF(MB.GT.1) THEN 
            CALL DLARRC( 'T', IN, S1, S2, D(IBEGIN),                    &
&                    E(IBEGIN), PIVMIN, CNT, CNT1, CNT2, IINFO)    
      ENDIF 
                                                                        
      IF(MB.EQ.1) THEN 
            SIGMA = GL 
            SGNDEF = ONE 
      ELSEIF( CNT1 - INDL .GE. INDU - CNT2 ) THEN 
            IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
            SIGMA = MAX(ISLEFT,GL) 
            ELSEIF( USEDQD ) THEN 
!              use Gerschgorin bound as shift to get pos def matrix     
!              for dqds                                                 
            SIGMA = ISLEFT 
            ELSE 
!              use approximation of the first desired eigenvalue of the 
!              block as shift                                           
            SIGMA = MAX(ISLEFT,VL) 
            ENDIF 
            SGNDEF = ONE 
      ELSE 
            IF( ( IRANGE.EQ.ALLRNG ) .AND. (.NOT.FORCEB) ) THEN 
            SIGMA = MIN(ISRGHT,GU) 
            ELSEIF( USEDQD ) THEN 
!              use Gerschgorin bound as shift to get neg def matrix     
!              for dqds                                                 
            SIGMA = ISRGHT 
            ELSE 
!              use approximation of the first desired eigenvalue of the 
!              block as shift                                           
            SIGMA = MIN(ISRGHT,VU) 
            ENDIF 
            SGNDEF = -ONE 
      ENDIF 
                                                                        
                                                                        
!        An initial SIGMA has been chosen that will be used for computin
!        T - SIGMA I = L D L^T                                          
!        Define the increment TAU of the shift in case the initial shift
!        needs to be refined to obtain a factorization with not too much
!        element growth.                                                
      IF( USEDQD ) THEN 
!           The initial SIGMA was to the outer end of the spectrum      
!           the matrix is definite and we need not retreat.             
            TAU = SPDIAM*EPS*N + TWO*PIVMIN 
            TAU = MAX( TAU,TWO*EPS*ABS(SIGMA) ) 
      ELSE 
            IF(MB.GT.1) THEN 
            CLWDTH = W(WEND) + WERR(WEND) - W(WBEGIN) - WERR(WBEGIN) 
            AVGAP = ABS(CLWDTH / DBLE(WEND-WBEGIN)) 
            IF( SGNDEF.EQ.ONE ) THEN 
                  TAU = HALF*MAX(WGAP(WBEGIN),AVGAP) 
                  TAU = MAX(TAU,WERR(WBEGIN)) 
            ELSE 
                  TAU = HALF*MAX(WGAP(WEND-1),AVGAP) 
                  TAU = MAX(TAU,WERR(WEND)) 
            ENDIF 
            ELSE 
            TAU = WERR(WBEGIN) 
            ENDIF 
      ENDIF 
!                                                                       
      DO 80 IDUM = 1, MAXTRY 
!           Compute L D L^T factorization of tridiagonal matrix T - sigm
!           Store D in WORK(1:IN), L in WORK(IN+1:2*IN), and reciprocals
!           pivots in WORK(2*IN+1:3*IN)                                 
            DPIVOT = D( IBEGIN ) - SIGMA 
            WORK( 1 ) = DPIVOT 
            DMAX = ABS( WORK(1) ) 
            J = IBEGIN 
            DO 70 I = 1, IN - 1 
            WORK( 2*IN+I ) = ONE / WORK( I ) 
            TMP = E( J )*WORK( 2*IN+I ) 
            WORK( IN+I ) = TMP 
            DPIVOT = ( D( J+1 )-SIGMA ) - TMP*E( J ) 
            WORK( I+1 ) = DPIVOT 
            DMAX = MAX( DMAX, ABS(DPIVOT) ) 
            J = J + 1 
70       CONTINUE 
!           check for element growth                                    
            IF( DMAX .GT. MAXGROWTH*SPDIAM ) THEN 
            NOREP = .TRUE. 
            ELSE 
            NOREP = .FALSE. 
            ENDIF 
            IF( USEDQD .AND. .NOT.NOREP ) THEN 
!              Ensure the definiteness of the representation            
!              All entries of D (of L D L^T) must have the same sign    
            DO 71 I = 1, IN 
                  TMP = SGNDEF*WORK( I ) 
                  IF( TMP.LT.ZERO ) NOREP = .TRUE. 
71          CONTINUE 
            ENDIF 
            IF(NOREP) THEN 
!              Note that in the case of IRANGE=ALLRNG, we use the Gersch
!              shift which makes the matrix definite. So we should end u
!              here really only in the case of IRANGE = VALRNG or INDRNG
            IF( IDUM.EQ.MAXTRY-1 ) THEN 
                  IF( SGNDEF.EQ.ONE ) THEN 
!                    The fudged Gerschgorin shift should succeed        
                  SIGMA =                                            &
&                    GL - FUDGE*SPDIAM*EPS*N - FUDGE*TWO*PIVMIN    
                  ELSE 
                  SIGMA =                                            &
&                    GU + FUDGE*SPDIAM*EPS*N + FUDGE*TWO*PIVMIN    
                  END IF 
            ELSE 
                  SIGMA = SIGMA - SGNDEF * TAU 
                  TAU = TWO * TAU 
            END IF 
            ELSE 
!              an initial RRR is found                                  
            GO TO 83 
            END IF 
80    CONTINUE 
!        if the program reaches this point, no base representation could
!        found in MAXTRY iterations.                                    
      INFO = 2 
      RETURN 
                                                                        
83    CONTINUE 
!        At this point, we have found an initial base representation    
!        T - SIGMA I = L D L^T with not too much element growth.        
!        Store the shift.                                               
      E( IEND ) = SIGMA 
!        Store D and L.                                                 
      CALL DCOPY( IN, WORK, 1, D( IBEGIN ), 1 ) 
      CALL DCOPY( IN-1, WORK( IN+1 ), 1, E( IBEGIN ), 1 ) 
                                                                        
                                                                        
      IF(MB.GT.1 ) THEN 
!                                                                       
!           Perturb each entry of the base representation by a small    
!           (but random) relative amount to overcome difficulties with  
!           glued matrices.                                             
!                                                                       
            DO 122 I = 1, 4 
            ISEED( I ) = 1 
122       CONTINUE 
                                                                        
            CALL DLARNV(2, ISEED, 2*IN-1, WORK(1)) 
            DO 125 I = 1,IN-1 
            D(IBEGIN+I-1) = D(IBEGIN+I-1)*(ONE+EPS*PERT*WORK(I)) 
            E(IBEGIN+I-1) = E(IBEGIN+I-1)*(ONE+EPS*PERT*WORK(IN+I)) 
125       CONTINUE 
            D(IEND) = D(IEND)*(ONE+EPS*FOUR*WORK(IN)) 
!                                                                       
      ENDIF 
!                                                                       
!        Don't update the Gerschgorin intervals because keeping track   
!        of the updates would be too much work in DLARRV.               
!        We update W instead and use it to locate the proper Gerschgorin
!        intervals.                                                     
                                                                        
!        Compute the required eigenvalues of L D L' by bisection or dqds
      IF ( .NOT.USEDQD ) THEN 
!           If DLARRD has been used, shift the eigenvalue approximations
!           according to their representation. This is necessary for    
!           a uniform DLARRV since dqds computes eigenvalues of the     
!           shifted representation. In DLARRV, W will always hold the   
!           UNshifted eigenvalue approximation.                         
            DO 134 J=WBEGIN,WEND 
            W(J) = W(J) - SIGMA 
            WERR(J) = WERR(J) + ABS(W(J)) * EPS 
134       CONTINUE 
!           call DLARRB to reduce eigenvalue error of the approximations
!           from DLARRD                                                 
            DO 135 I = IBEGIN, IEND-1 
            WORK( I ) = D( I ) * E( I )**2 
135       CONTINUE 
!           use bisection to find EV from INDL to INDU                  
            CALL DLARRB(IN, D(IBEGIN), WORK(IBEGIN),                    &
&                  INDL, INDU, RTOL1, RTOL2, INDL-1,               &
&                  W(WBEGIN), WGAP(WBEGIN), WERR(WBEGIN),          &
&                  WORK( 2*N+1 ), IWORK, PIVMIN, SPDIAM,           &
&                  IN, IINFO )                                     
            IF( IINFO .NE. 0 ) THEN 
            INFO = -4 
            RETURN 
            END IF 
!           DLARRB computes all gaps correctly except for the last one  
!           Record distance to VU/GU                                    
            WGAP( WEND ) = MAX( ZERO,                                   &
&           ( VU-SIGMA ) - ( W( WEND ) + WERR( WEND ) ) )          
            DO 138 I = INDL, INDU 
            M = M + 1 
            IBLOCK(M) = JBLK 
            INDEXW(M) = I 
138       CONTINUE 
      ELSE 
!           Call dqds to get all eigs (and then possibly delete unwanted
!           eigenvalues).                                               
!           Note that dqds finds the eigenvalues of the L D L^T represen
!           of T to high relative accuracy. High relative accuracy      
!           might be lost when the shift of the RRR is subtracted to obt
!           the eigenvalues of T. However, T is not guaranteed to define
!           eigenvalues to high relative accuracy anyway.               
!           Set RTOL to the order of the tolerance used in DLASQ2       
!           This is an ESTIMATED error, the worst case bound is 4*N*EPS 
!           which is usually too large and requires unnecessary work to 
!           done by bisection when computing the eigenvectors           
            RTOL = LOG(DBLE(IN)) * FOUR * EPS 
            J = IBEGIN 
            DO 140 I = 1, IN - 1 
            WORK( 2*I-1 ) = ABS( D( J ) ) 
            WORK( 2*I ) = E( J )*E( J )*WORK( 2*I-1 ) 
            J = J + 1 
140       CONTINUE 
            WORK( 2*IN-1 ) = ABS( D( IEND ) ) 
            WORK( 2*IN ) = ZERO 
            CALL DLASQ2( IN, WORK, IINFO ) 
            IF( IINFO .NE. 0 ) THEN 
!              If IINFO = -5 then an index is part of a tight cluster   
!              and should be changed. The index is in IWORK(1) and the  
!              gap is in WORK(N+1)                                      
            INFO = -5 
            RETURN 
            ELSE 
!              Test that all eigenvalues are positive as expected       
            DO 149 I = 1, IN 
                  IF( WORK( I ).LT.ZERO ) THEN 
                  INFO = -6 
                  RETURN 
                  ENDIF 
149          CONTINUE 
            END IF 
            IF( SGNDEF.GT.ZERO ) THEN 
            DO 150 I = INDL, INDU 
                  M = M + 1 
                  W( M ) = WORK( IN-I+1 ) 
                  IBLOCK( M ) = JBLK 
                  INDEXW( M ) = I 
150          CONTINUE 
            ELSE 
            DO 160 I = INDL, INDU 
                  M = M + 1 
                  W( M ) = -WORK( I ) 
                  IBLOCK( M ) = JBLK 
                  INDEXW( M ) = I 
160          CONTINUE 
            END IF 
                                                                        
            DO 165 I = M - MB + 1, M 
!              the value of RTOL below should be the tolerance in DLASQ2
            WERR( I ) = RTOL * ABS( W(I) ) 
165       CONTINUE 
            DO 166 I = M - MB + 1, M - 1 
!              compute the right gap between the intervals              
            WGAP( I ) = MAX( ZERO,                                   &
&                          W(I+1)-WERR(I+1) - (W(I)+WERR(I)) )     
166       CONTINUE 
            WGAP( M ) = MAX( ZERO,                                      &
&           ( VU-SIGMA ) - ( W( M ) + WERR( M ) ) )                
      END IF 
!        proceed with next block                                        
      IBEGIN = IEND + 1 
      WBEGIN = WEND + 1 
170 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     end of DLARRE                                                     
!                                                                       
      END                                           
!> \brief \b DLARRF finds a new relatively robust representation such th
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRF( N, D, L, LD, CLSTRT, CLEND,                  
!                          W, WGAP, WERR,                               
!                          SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA,       
!                          DPLUS, LPLUS, WORK, INFO )                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            CLSTRT, CLEND, INFO, N                       
!       DOUBLE PRECISION   CLGAPL, CLGAPR, PIVMIN, SIGMA, SPDIAM        
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), DPLUS( * ), L( * ), LD( * ),         
!      $          LPLUS( * ), W( * ), WGAP( * ), WERR( * ), WORK( * )   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the initial representation L D L^T and its cluster of close    
!> eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ... 
!> W( CLEND ), DLARRF finds a new relatively robust representation      
!> L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the   
!> eigenvalues of L(+) D(+) L(+)^T is relatively isolated.              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix (subblock, if the matrix split).    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The N diagonal elements of the diagonal matrix D.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] L                                                         
!> \verbatim                                                            
!>          L is DOUBLE PRECISION array, dimension (N-1)                
!>          The (N-1) subdiagonal elements of the unit bidiagonal       
!>          matrix L.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LD                                                        
!> \verbatim                                                            
!>          LD is DOUBLE PRECISION array, dimension (N-1)               
!>          The (N-1) elements L(i)*D(i).                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLSTRT                                                    
!> \verbatim                                                            
!>          CLSTRT is INTEGER                                           
!>          The index of the first eigenvalue in the cluster.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLEND                                                     
!> \verbatim                                                            
!>          CLEND is INTEGER                                            
!>          The index of the last eigenvalue in the cluster.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] W                                                         
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension                      
!>          dimension is >=  (CLEND-CLSTRT+1)                           
!>          The eigenvalue APPROXIMATIONS of L D L^T in ascending order.
!>          W( CLSTRT ) through W( CLEND ) form the cluster of relativel
!>          close eigenalues.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is DOUBLE PRECISION array, dimension                   
!>          dimension is >=  (CLEND-CLSTRT+1)                           
!>          The separation from the right neighbor eigenvalue in W.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] WERR                                                      
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension                   
!>          dimension is  >=  (CLEND-CLSTRT+1)                          
!>          WERR contain the semiwidth of the uncertainty               
!>          interval of the corresponding eigenvalue APPROXIMATION in W 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is DOUBLE PRECISION                                  
!>          estimate of the spectral diameter obtained from the         
!>          Gerschgorin intervals                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLGAPL                                                    
!> \verbatim                                                            
!>          CLGAPL is DOUBLE PRECISION                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CLGAPR                                                    
!> \verbatim                                                            
!>          CLGAPR is DOUBLE PRECISION                                  
!>          absolute gap on each end of the cluster.                    
!>          Set by the calling routine to protect against shifts too clo
!>          to eigenvalues outside the cluster.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot allowed in the Sturm sequence.            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SIGMA                                                    
!> \verbatim                                                            
!>          SIGMA is DOUBLE PRECISION                                   
!>          The shift used to form L(+) D(+) L(+)^T.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DPLUS                                                    
!> \verbatim                                                            
!>          DPLUS is DOUBLE PRECISION array, dimension (N)              
!>          The N diagonal elements of the diagonal matrix D(+).        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] LPLUS                                                    
!> \verbatim                                                            
!>          LPLUS is DOUBLE PRECISION array, dimension (N-1)            
!>          The first (N-1) elements of LPLUS contain the subdiagonal   
!>          elements of the unit bidiagonal matrix L(+).                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (2*N)             
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Signals processing OK (=0) or failure (=1)                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRF( N, D, L, LD, CLSTRT, CLEND,                    &
&                   W, WGAP, WERR,                                 &
&                   SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA,         &
&                   DPLUS, LPLUS, WORK, INFO )                     
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            CLSTRT, CLEND, INFO, N 
      DOUBLE PRECISION   CLGAPL, CLGAPR, PIVMIN, SIGMA, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), DPLUS( * ), L( * ), LD( * ),           &
&          LPLUS( * ), W( * ), WGAP( * ), WERR( * ), WORK( * )     
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   FOUR, MAXGROWTH1, MAXGROWTH2, ONE, QUART, TWO 
      PARAMETER          ( ONE = 1.0D0, TWO = 2.0D0, FOUR = 4.0D0,      &
&                     QUART = 0.25D0,                              &
&                     MAXGROWTH1 = 8.D0,                           &
&                     MAXGROWTH2 = 8.D0 )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL   DORRR1, FORCER, NOFAIL, SAWNAN1, SAWNAN2, TRYRRR1 
      INTEGER            I, INDX, KTRY, KTRYMAX, SLEFT, SRIGHT, SHIFT 
      PARAMETER          ( KTRYMAX = 1, SLEFT = 1, SRIGHT = 2 ) 
      DOUBLE PRECISION   AVGAP, BESTSHIFT, CLWDTH, EPS, FACT, FAIL,     &
&                   FAIL2, GROWTHBOUND, LDELTA, LDMAX, LSIGMA,     &
&                   MAX1, MAX2, MINGAP, OLDP, PROD, RDELTA, RDMAX, &
&                   RRR1, RRR2, RSIGMA, S, SMLGROWTH, TMP, ZNM2    
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL DISNAN 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DISNAN, DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
      FACT = DBLE(2**KTRYMAX) 
      EPS = DLAMCH( 'Precision' ) 
      SHIFT = 0 
      FORCER = .FALSE. 
                                                                        
                                                                        
!     Note that we cannot guarantee that for any of the shifts tried,   
!     the factorization has a small or even moderate element growth.    
!     There could be Ritz values at both ends of the cluster and despite
!     backing off, there are examples where all factorizations tried    
!     (in IEEE mode, allowing zero pivots & infinities) have INFINITE   
!     element growth.                                                   
!     For this reason, we should use PIVMIN in this subroutine so that a
!     least the L D L^T factorization exists. It can be checked afterwar
!     whether the element growth caused bad residuals/orthogonality.    
                                                                        
!     Decide whether the code should accept the best among all          
!     representations despite large element growth or signal INFO=1     
!     Setting NOFAIL to .FALSE. for quick fix for bug 113               
      NOFAIL = .FALSE. 
!                                                                       
                                                                        
!     Compute the average gap length of the cluster                     
      CLWDTH = ABS(W(CLEND)-W(CLSTRT)) + WERR(CLEND) + WERR(CLSTRT) 
      AVGAP = CLWDTH / DBLE(CLEND-CLSTRT) 
      MINGAP = MIN(CLGAPL, CLGAPR) 
!     Initial values for shifts to both ends of cluster                 
      LSIGMA = MIN(W( CLSTRT ),W( CLEND )) - WERR( CLSTRT ) 
      RSIGMA = MAX(W( CLSTRT ),W( CLEND )) + WERR( CLEND ) 
                                                                        
!     Use a small fudge to make sure that we really shift to the outside
      LSIGMA = LSIGMA - ABS(LSIGMA)* FOUR * EPS 
      RSIGMA = RSIGMA + ABS(RSIGMA)* FOUR * EPS 
                                                                        
!     Compute upper bounds for how much to back off the initial shifts  
      LDMAX = QUART * MINGAP + TWO * PIVMIN 
      RDMAX = QUART * MINGAP + TWO * PIVMIN 
                                                                        
      LDELTA = MAX(AVGAP,WGAP( CLSTRT ))/FACT 
      RDELTA = MAX(AVGAP,WGAP( CLEND-1 ))/FACT 
!                                                                       
!     Initialize the record of the best representation found            
!                                                                       
      S = DLAMCH( 'S' ) 
      SMLGROWTH = ONE / S 
      FAIL = DBLE(N-1)*MINGAP/(SPDIAM*EPS) 
      FAIL2 = DBLE(N-1)*MINGAP/(SPDIAM*SQRT(EPS)) 
      BESTSHIFT = LSIGMA 
!                                                                       
!     while (KTRY <= KTRYMAX)                                           
      KTRY = 0 
      GROWTHBOUND = MAXGROWTH1*SPDIAM 
                                                                        
5 CONTINUE 
      SAWNAN1 = .FALSE. 
      SAWNAN2 = .FALSE. 
!     Ensure that we do not back off too much of the initial shifts     
      LDELTA = MIN(LDMAX,LDELTA) 
      RDELTA = MIN(RDMAX,RDELTA) 
                                                                        
!     Compute the element growth when shifting to both ends of the clust
!     accept the shift if there is no element growth at one of the two e
                                                                        
!     Left end                                                          
      S = -LSIGMA 
      DPLUS( 1 ) = D( 1 ) + S 
      IF(ABS(DPLUS(1)).LT.PIVMIN) THEN 
      DPLUS(1) = -PIVMIN 
!        Need to set SAWNAN1 because refined RRR test should not be used
!        in this case                                                   
      SAWNAN1 = .TRUE. 
      ENDIF 
      MAX1 = ABS( DPLUS( 1 ) ) 
      DO 6 I = 1, N - 1 
      LPLUS( I ) = LD( I ) / DPLUS( I ) 
      S = S*LPLUS( I )*L( I ) - LSIGMA 
      DPLUS( I+1 ) = D( I+1 ) + S 
      IF(ABS(DPLUS(I+1)).LT.PIVMIN) THEN 
            DPLUS(I+1) = -PIVMIN 
!           Need to set SAWNAN1 because refined RRR test should not be u
!           in this case                                                
            SAWNAN1 = .TRUE. 
      ENDIF 
      MAX1 = MAX( MAX1,ABS(DPLUS(I+1)) ) 
6 END DO 
      SAWNAN1 = SAWNAN1 .OR.  DISNAN( MAX1 ) 
                                                                        
      IF( FORCER .OR.                                                   &
&   (MAX1.LE.GROWTHBOUND .AND. .NOT.SAWNAN1 ) ) THEN               
      SIGMA = LSIGMA 
      SHIFT = SLEFT 
      GOTO 100 
      ENDIF 
                                                                        
!     Right end                                                         
      S = -RSIGMA 
      WORK( 1 ) = D( 1 ) + S 
      IF(ABS(WORK(1)).LT.PIVMIN) THEN 
      WORK(1) = -PIVMIN 
!        Need to set SAWNAN2 because refined RRR test should not be used
!        in this case                                                   
      SAWNAN2 = .TRUE. 
      ENDIF 
      MAX2 = ABS( WORK( 1 ) ) 
      DO 7 I = 1, N - 1 
      WORK( N+I ) = LD( I ) / WORK( I ) 
      S = S*WORK( N+I )*L( I ) - RSIGMA 
      WORK( I+1 ) = D( I+1 ) + S 
      IF(ABS(WORK(I+1)).LT.PIVMIN) THEN 
            WORK(I+1) = -PIVMIN 
!           Need to set SAWNAN2 because refined RRR test should not be u
!           in this case                                                
            SAWNAN2 = .TRUE. 
      ENDIF 
      MAX2 = MAX( MAX2,ABS(WORK(I+1)) ) 
7 END DO 
      SAWNAN2 = SAWNAN2 .OR.  DISNAN( MAX2 ) 
                                                                        
      IF( FORCER .OR.                                                   &
&   (MAX2.LE.GROWTHBOUND .AND. .NOT.SAWNAN2 ) ) THEN               
      SIGMA = RSIGMA 
      SHIFT = SRIGHT 
      GOTO 100 
      ENDIF 
!     If we are at this point, both shifts led to too much element growt
                                                                        
!     Record the better of the two shifts (provided it didn't lead to Na
      IF(SAWNAN1.AND.SAWNAN2) THEN 
!        both MAX1 and MAX2 are NaN                                     
      GOTO 50 
      ELSE 
      IF( .NOT.SAWNAN1 ) THEN 
            INDX = 1 
            IF(MAX1.LE.SMLGROWTH) THEN 
            SMLGROWTH = MAX1 
            BESTSHIFT = LSIGMA 
            ENDIF 
      ENDIF 
      IF( .NOT.SAWNAN2 ) THEN 
            IF(SAWNAN1 .OR. MAX2.LE.MAX1) INDX = 2 
            IF(MAX2.LE.SMLGROWTH) THEN 
            SMLGROWTH = MAX2 
            BESTSHIFT = RSIGMA 
            ENDIF 
      ENDIF 
      ENDIF 
                                                                        
!     If we are here, both the left and the right shift led to          
!     element growth. If the element growth is moderate, then           
!     we may still accept the representation, if it passes a            
!     refined test for RRR. This test supposes that no NaN occurred.    
!     Moreover, we use the refined RRR test only for isolated clusters. 
      IF((CLWDTH.LT.MINGAP/DBLE(128)) .AND.                             &
&   (MIN(MAX1,MAX2).LT.FAIL2)                                      &
&  .AND.(.NOT.SAWNAN1).AND.(.NOT.SAWNAN2)) THEN                    
      DORRR1 = .TRUE. 
      ELSE 
      DORRR1 = .FALSE. 
      ENDIF 
      TRYRRR1 = .TRUE. 
      IF( TRYRRR1 .AND. DORRR1 ) THEN 
      IF(INDX.EQ.1) THEN 
      TMP = ABS( DPLUS( N ) ) 
      ZNM2 = ONE 
      PROD = ONE 
      OLDP = ONE 
      DO 15 I = N-1, 1, -1 
            IF( PROD .LE. EPS ) THEN 
            PROD =                                                   &
&         ((DPLUS(I+1)*WORK(N+I+1))/(DPLUS(I)*WORK(N+I)))*OLDP     
            ELSE 
            PROD = PROD*ABS(WORK(N+I)) 
            END IF 
            OLDP = PROD 
            ZNM2 = ZNM2 + PROD**2 
            TMP = MAX( TMP, ABS( DPLUS( I ) * PROD )) 
15    CONTINUE 
      RRR1 = TMP/( SPDIAM * SQRT( ZNM2 ) ) 
      IF (RRR1.LE.MAXGROWTH2) THEN 
            SIGMA = LSIGMA 
            SHIFT = SLEFT 
            GOTO 100 
      ENDIF 
      ELSE IF(INDX.EQ.2) THEN 
      TMP = ABS( WORK( N ) ) 
      ZNM2 = ONE 
      PROD = ONE 
      OLDP = ONE 
      DO 16 I = N-1, 1, -1 
            IF( PROD .LE. EPS ) THEN 
            PROD = ((WORK(I+1)*LPLUS(I+1))/(WORK(I)*LPLUS(I)))*OLDP 
            ELSE 
            PROD = PROD*ABS(LPLUS(I)) 
            END IF 
            OLDP = PROD 
            ZNM2 = ZNM2 + PROD**2 
            TMP = MAX( TMP, ABS( WORK( I ) * PROD )) 
16    CONTINUE 
      RRR2 = TMP/( SPDIAM * SQRT( ZNM2 ) ) 
      IF (RRR2.LE.MAXGROWTH2) THEN 
            SIGMA = RSIGMA 
            SHIFT = SRIGHT 
            GOTO 100 
      ENDIF 
      END IF 
      ENDIF 
                                                                        
50 CONTINUE 
                                                                        
      IF (KTRY.LT.KTRYMAX) THEN 
!        If we are here, both shifts failed also the RRR test.          
!        Back off to the outside                                        
      LSIGMA = MAX( LSIGMA - LDELTA,                                 &
&     LSIGMA - LDMAX)                                              
      RSIGMA = MIN( RSIGMA + RDELTA,                                 &
&     RSIGMA + RDMAX )                                             
      LDELTA = TWO * LDELTA 
      RDELTA = TWO * RDELTA 
      KTRY = KTRY + 1 
      GOTO 5 
      ELSE 
!        None of the representations investigated satisfied our         
!        criteria. Take the best one we found.                          
      IF((SMLGROWTH.LT.FAIL).OR.NOFAIL) THEN 
            LSIGMA = BESTSHIFT 
            RSIGMA = BESTSHIFT 
            FORCER = .TRUE. 
            GOTO 5 
      ELSE 
            INFO = 1 
            RETURN 
      ENDIF 
      END IF 
                                                                        
100 CONTINUE 
      IF (SHIFT.EQ.SLEFT) THEN 
      ELSEIF (SHIFT.EQ.SRIGHT) THEN 
!        store new L and D back into DPLUS, LPLUS                       
      CALL DCOPY( N, WORK, 1, DPLUS, 1 ) 
      CALL DCOPY( N-1, WORK(N+1), 1, LPLUS, 1 ) 
      ENDIF 
                                                                        
      RETURN 
!                                                                       
!     End of DLARRF                                                     
!                                                                       
      END                                           
!> \brief \b DLARRJ performs refinement of the initial estimates of the 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRJ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRJ( N, D, E2, IFIRST, ILAST,                     
!                          RTOL, OFFSET, W, WERR, WORK, IWORK,          
!                          PIVMIN, SPDIAM, INFO )                       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IFIRST, ILAST, INFO, N, OFFSET               
!       DOUBLE PRECISION   PIVMIN, RTOL, SPDIAM                         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IWORK( * )                                   
!       DOUBLE PRECISION   D( * ), E2( * ), W( * ),                     
!      $                   WERR( * ), WORK( * )                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Given the initial eigenvalue approximations of T, DLARRJ             
!> does  bisection to refine the eigenvalues of T,                      
!> W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initi
!> guesses for these eigenvalues are input in W, the corresponding estim
!> of the error in these guesses in WERR. During bisection, intervals   
!> [left, right] are maintained by storing their mid-points and         
!> semi-widths in the arrays W and WERR respectively.                   
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The N diagonal elements of T.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N-1)               
!>          The Squares of the (N-1) subdiagonal elements of T.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IFIRST                                                    
!> \verbatim                                                            
!>          IFIRST is INTEGER                                           
!>          The index of the first eigenvalue to be computed.           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILAST                                                     
!> \verbatim                                                            
!>          ILAST is INTEGER                                            
!>          The index of the last eigenvalue to be computed.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL                                                      
!> \verbatim                                                            
!>          RTOL is DOUBLE PRECISION                                    
!>          Tolerance for the convergence of the bisection intervals.   
!>          An interval [LEFT,RIGHT] has converged if                   
!>          RIGHT-LEFT < RTOL*MAX(|LEFT|,|RIGHT|).                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OFFSET                                                    
!> \verbatim                                                            
!>          OFFSET is INTEGER                                           
!>          Offset for the arrays W and WERR, i.e., the IFIRST-OFFSET   
!>          through ILAST-OFFSET elements of these arrays are to be used
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are  
!>          estimates of the eigenvalues of L D L^T indexed IFIRST throu
!>          ILAST.                                                      
!>          On output, these estimates are refined.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension (N)               
!>          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET )
!>          the errors in the estimates of the corresponding elements in
!>          On output, these errors are refined.                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (2*N)             
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (2*N)                     
!>          Workspace.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot in the Sturm sequence for T.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SPDIAM                                                    
!> \verbatim                                                            
!>          SPDIAM is DOUBLE PRECISION                                  
!>          The spectral diameter of T.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          Error flag.                                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRJ( N, D, E2, IFIRST, ILAST,                       &
&                   RTOL, OFFSET, W, WERR, WORK, IWORK,            &
&                   PIVMIN, SPDIAM, INFO )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IFIRST, ILAST, INFO, N, OFFSET 
      DOUBLE PRECISION   PIVMIN, RTOL, SPDIAM 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IWORK( * ) 
      DOUBLE PRECISION   D( * ), E2( * ), W( * ),                       &
&                   WERR( * ), WORK( * )                           
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TWO, HALF 
      PARAMETER        ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0,        &
&                   HALF = 0.5D0 )                                 
      INTEGER   MAXITR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            CNT, I, I1, I2, II, ITER, J, K, NEXT, NINT,    &
&                   OLNINT, P, PREV, SAVI1                         
      DOUBLE PRECISION   DPLUS, FAC, LEFT, MID, RIGHT, S, TMP, WIDTH 
!                                                                       
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
      MAXITR = INT( ( LOG( SPDIAM+PIVMIN )-LOG( PIVMIN ) ) /            &
&           LOG( TWO ) ) + 2                                       
!                                                                       
!     Initialize unconverged intervals in [ WORK(2*I-1), WORK(2*I) ].   
!     The Sturm Count, Count( WORK(2*I-1) ) is arranged to be I-1, while
!     Count( WORK(2*I) ) is stored in IWORK( 2*I ). The integer IWORK( 2
!     for an unconverged interval is set to the index of the next unconv
!     interval, and is -1 or 0 for a converged interval. Thus a linked  
!     list of unconverged intervals is set up.                          
!                                                                       
                                                                        
      I1 = IFIRST 
      I2 = ILAST 
!     The number of unconverged intervals                               
      NINT = 0 
!     The last unconverged interval found                               
      PREV = 0 
      DO 75 I = I1, I2 
      K = 2*I 
      II = I - OFFSET 
      LEFT = W( II ) - WERR( II ) 
      MID = W(II) 
      RIGHT = W( II ) + WERR( II ) 
      WIDTH = RIGHT - MID 
      TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
                                                                        
!        The following test prevents the test of converged intervals    
      IF( WIDTH.LT.RTOL*TMP ) THEN 
!           This interval has already converged and does not need refine
!           (Note that the gaps might change through refining the       
!            eigenvalues, however, they can only get bigger.)           
!           Remove it from the list.                                    
            IWORK( K-1 ) = -1 
!           Make sure that I1 always points to the first unconverged int
            IF((I.EQ.I1).AND.(I.LT.I2)) I1 = I + 1 
            IF((PREV.GE.I1).AND.(I.LE.I2)) IWORK( 2*PREV-1 ) = I + 1 
      ELSE 
!           unconverged interval found                                  
            PREV = I 
!           Make sure that [LEFT,RIGHT] contains the desired eigenvalue 
!                                                                       
!           Do while( CNT(LEFT).GT.I-1 )                                
!                                                                       
            FAC = ONE 
20       CONTINUE 
            CNT = 0 
            S = LEFT 
            DPLUS = D( 1 ) - S 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
            DO 30 J = 2, N 
            DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
30       CONTINUE 
            IF( CNT.GT.I-1 ) THEN 
            LEFT = LEFT - WERR( II )*FAC 
            FAC = TWO*FAC 
            GO TO 20 
            END IF 
!                                                                       
!           Do while( CNT(RIGHT).LT.I )                                 
!                                                                       
            FAC = ONE 
50       CONTINUE 
            CNT = 0 
            S = RIGHT 
            DPLUS = D( 1 ) - S 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
            DO 60 J = 2, N 
            DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
60       CONTINUE 
            IF( CNT.LT.I ) THEN 
            RIGHT = RIGHT + WERR( II )*FAC 
            FAC = TWO*FAC 
            GO TO 50 
            END IF 
            NINT = NINT + 1 
            IWORK( K-1 ) = I + 1 
            IWORK( K ) = CNT 
      END IF 
      WORK( K-1 ) = LEFT 
      WORK( K ) = RIGHT 
75 END DO 
                                                                        
                                                                        
      SAVI1 = I1 
!                                                                       
!     Do while( NINT.GT.0 ), i.e. there are still unconverged intervals 
!     and while (ITER.LT.MAXITR)                                        
!                                                                       
      ITER = 0 
80 CONTINUE 
      PREV = I1 - 1 
      I = I1 
      OLNINT = NINT 
                                                                        
      DO 100 P = 1, OLNINT 
      K = 2*I 
      II = I - OFFSET 
      NEXT = IWORK( K-1 ) 
      LEFT = WORK( K-1 ) 
      RIGHT = WORK( K ) 
      MID = HALF*( LEFT + RIGHT ) 
                                                                        
!        semiwidth of interval                                          
      WIDTH = RIGHT - MID 
      TMP = MAX( ABS( LEFT ), ABS( RIGHT ) ) 
                                                                        
      IF( ( WIDTH.LT.RTOL*TMP ) .OR.                                 &
&      (ITER.EQ.MAXITR) )THEN                                      
!           reduce number of unconverged intervals                      
            NINT = NINT - 1 
!           Mark interval as converged.                                 
            IWORK( K-1 ) = 0 
            IF( I1.EQ.I ) THEN 
            I1 = NEXT 
            ELSE 
!              Prev holds the last unconverged interval previously exami
            IF(PREV.GE.I1) IWORK( 2*PREV-1 ) = NEXT 
            END IF 
            I = NEXT 
            GO TO 100 
      END IF 
      PREV = I 
!                                                                       
!        Perform one bisection step                                     
!                                                                       
      CNT = 0 
      S = MID 
      DPLUS = D( 1 ) - S 
      IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
      DO 90 J = 2, N 
            DPLUS = D( J ) - S - E2( J-1 )/DPLUS 
            IF( DPLUS.LT.ZERO ) CNT = CNT + 1 
90    CONTINUE 
      IF( CNT.LE.I-1 ) THEN 
            WORK( K-1 ) = MID 
      ELSE 
            WORK( K ) = MID 
      END IF 
      I = NEXT 
                                                                        
100 END DO 
      ITER = ITER + 1 
!     do another loop if there are still unconverged intervals          
!     However, in the last iteration, all intervals are accepted        
!     since this is the best we can do.                                 
      IF( ( NINT.GT.0 ).AND.(ITER.LE.MAXITR) ) GO TO 80 
!                                                                       
!                                                                       
!     At this point, all the intervals have converged                   
      DO 110 I = SAVI1, ILAST 
      K = 2*I 
      II = I - OFFSET 
!        All intervals marked by '0' have been refined.                 
      IF( IWORK( K-1 ).EQ.0 ) THEN 
            W( II ) = HALF*( WORK( K-1 )+WORK( K ) ) 
            WERR( II ) = WORK( K ) - W( II ) 
      END IF 
110 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     End of DLARRJ                                                     
!                                                                       
      END                                           
!> \brief \b DLARRK computes one eigenvalue of a symmetric tridiagonal m
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRK + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRK( N, IW, GL, GU,                               
!                           D, E2, PIVMIN, RELTOL, W, WERR, INFO)       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER   INFO, IW, N                                           
!       DOUBLE PRECISION    PIVMIN, RELTOL, GL, GU, W, WERR             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), E2( * )                              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARRK computes one eigenvalue of a symmetric tridiagonal            
!> matrix T to suitable accuracy. This is an auxiliary code to be       
!> called from DSTEMR.                                                  
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IW                                                        
!> \verbatim                                                            
!>          IW is INTEGER                                               
!>          The index of the eigenvalues to be returned.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GL                                                        
!> \verbatim                                                            
!>          GL is DOUBLE PRECISION                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GU                                                        
!> \verbatim                                                            
!>          GU is DOUBLE PRECISION                                      
!>          An upper and a lower bound on the eigenvalue.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E2                                                        
!> \verbatim                                                            
!>          E2 is DOUBLE PRECISION array, dimension (N-1)               
!>          The (n-1) squared off-diagonal elements of the tridiagonal m
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot allowed in the Sturm sequence for T.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RELTOL                                                    
!> \verbatim                                                            
!>          RELTOL is DOUBLE PRECISION                                  
!>          The minimum relative width of an interval.  When an interval
!>          is narrower than RELTOL times the larger (in                
!>          magnitude) endpoint, then it is considered to be            
!>          sufficiently small, i.e., converged.  Note: this should     
!>          always be at least radix*machine epsilon.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WERR                                                     
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION                                    
!>          The error bound on the corresponding eigenvalue approximatio
!>          in W.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:       Eigenvalue converged                             
!>          = -1:      Eigenvalue did NOT converge                      
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  FUDGE   DOUBLE PRECISION, default = 2                               
!>          A "fudge factor" to widen the Gershgorin intervals.         
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRK( N, IW, GL, GU,                                 &
&                    D, E2, PIVMIN, RELTOL, W, WERR, INFO)         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER   INFO, IW, N 
      DOUBLE PRECISION    PIVMIN, RELTOL, GL, GU, W, WERR 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), E2( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   FUDGE, HALF, TWO, ZERO 
      PARAMETER          ( HALF = 0.5D0, TWO = 2.0D0,                   &
&                     FUDGE = TWO, ZERO = 0.0D0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER   I, IT, ITMAX, NEGCNT 
      DOUBLE PRECISION   ATOLI, EPS, LEFT, MID, RIGHT, RTOLI, TMP1,     &
&                   TMP2, TNORM                                    
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL   DLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      INFO = 0 
      RETURN 
      END IF 
!                                                                       
!     Get machine constants                                             
      EPS = DLAMCH( 'P' ) 
                                                                        
      TNORM = MAX( ABS( GL ), ABS( GU ) ) 
      RTOLI = RELTOL 
      ATOLI = FUDGE*TWO*PIVMIN 
                                                                        
      ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /              &
&           LOG( TWO ) ) + 2                                       
                                                                        
      INFO = -1 
                                                                        
      LEFT = GL - FUDGE*TNORM*EPS*N - FUDGE*TWO*PIVMIN 
      RIGHT = GU + FUDGE*TNORM*EPS*N + FUDGE*TWO*PIVMIN 
      IT = 0 
                                                                        
10 CONTINUE 
!                                                                       
!     Check if interval converged or maximum number of iterations reache
!                                                                       
      TMP1 = ABS( RIGHT - LEFT ) 
      TMP2 = MAX( ABS(RIGHT), ABS(LEFT) ) 
      IF( TMP1.LT.MAX( ATOLI, PIVMIN, RTOLI*TMP2 ) ) THEN 
      INFO = 0 
      GOTO 30 
      ENDIF 
      IF(IT.GT.ITMAX)                                                   &
&   GOTO 30                                                        
                                                                        
!                                                                       
!     Count number of negative pivots for mid-point                     
!                                                                       
      IT = IT + 1 
      MID = HALF * (LEFT + RIGHT) 
      NEGCNT = 0 
      TMP1 = D( 1 ) - MID 
      IF( ABS( TMP1 ).LT.PIVMIN )                                       &
&   TMP1 = -PIVMIN                                                 
      IF( TMP1.LE.ZERO )                                                &
&   NEGCNT = NEGCNT + 1                                            
!                                                                       
      DO 20 I = 2, N 
      TMP1 = D( I ) - E2( I-1 ) / TMP1 - MID 
      IF( ABS( TMP1 ).LT.PIVMIN )                                    &
&      TMP1 = -PIVMIN                                              
      IF( TMP1.LE.ZERO )                                             &
&      NEGCNT = NEGCNT + 1                                         
20 END DO 
                                                                        
      IF(NEGCNT.GE.IW) THEN 
      RIGHT = MID 
      ELSE 
      LEFT = MID 
      ENDIF 
      GOTO 10 
                                                                        
30 CONTINUE 
!                                                                       
!     Converged or maximum number of iterations reached                 
!                                                                       
      W = HALF * (LEFT + RIGHT) 
      WERR = HALF * ABS( RIGHT - LEFT ) 
                                                                        
      RETURN 
!                                                                       
!     End of DLARRK                                                     
!                                                                       
      END                                           
!> \brief \b DLARRR performs tests to decide whether the symmetric tridi
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRR( N, D, E, INFO )                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N, INFO                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Perform tests to decide whether the symmetric tridiagonal matrix T   
!> warrants expensive computations which guarantee high relative accurac
!> in the eigenvalues.                                                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix. N > 0.                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The N diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the first (N-1) entries contain the subdiagonal   
!>          elements of the tridiagonal matrix T; E(N) is set to ZERO.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          INFO = 0(default) : the matrix warrants computations preserv
!>                              relative accuracy.                      
!>          INFO = 1          : the matrix warrants computations guarant
!>                              only absolute accuracy.                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRR( N, D, E, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N, INFO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), E( * ) 
!     ..                                                                
!                                                                       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, RELCOND 
      PARAMETER          ( ZERO = 0.0D0,                                &
&                     RELCOND = 0.999D0 )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I 
      LOGICAL            YESREL 
      DOUBLE PRECISION   EPS, SAFMIN, SMLNUM, RMIN, TMP, TMP2,          &
&          OFFDIG, OFFDIG2                                         
                                                                        
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      INFO = 0 
      RETURN 
      END IF 
!                                                                       
!     As a default, do NOT go for relative-accuracy preserving computati
      INFO = 1 
                                                                        
      SAFMIN = DLAMCH( 'Safe minimum' ) 
      EPS = DLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      RMIN = SQRT( SMLNUM ) 
                                                                        
!     Tests for relative accuracy                                       
!                                                                       
!     Test for scaled diagonal dominance                                
!     Scale the diagonal entries to one and check whether the sum of the
!     off-diagonals is less than one                                    
!                                                                       
!     The sdd relative error bounds have a 1/(1- 2*x) factor in them,   
!     x = max(OFFDIG + OFFDIG2), so when x is close to 1/2, no relative 
!     accuracy is promised.  In the notation of the code fragment below,
!     1/(1 - (OFFDIG + OFFDIG2)) is the condition number.               
!     We don't think it is worth going into "sdd mode" unless the relati
!     condition number is reasonable, not 1/macheps.                    
!     The threshold should be compatible with other thresholds used in t
!     code. We set  OFFDIG + OFFDIG2 <= .999 =: RELCOND, it corresponds 
!     to losing at most 3 decimal digits: 1 / (1 - (OFFDIG + OFFDIG2)) <
!     instead of the current OFFDIG + OFFDIG2 < 1                       
!                                                                       
      YESREL = .TRUE. 
      OFFDIG = ZERO 
      TMP = SQRT(ABS(D(1))) 
      IF (TMP.LT.RMIN) YESREL = .FALSE. 
      IF(.NOT.YESREL) GOTO 11 
      DO 10 I = 2, N 
      TMP2 = SQRT(ABS(D(I))) 
      IF (TMP2.LT.RMIN) YESREL = .FALSE. 
      IF(.NOT.YESREL) GOTO 11 
      OFFDIG2 = ABS(E(I-1))/(TMP*TMP2) 
      IF(OFFDIG+OFFDIG2.GE.RELCOND) YESREL = .FALSE. 
      IF(.NOT.YESREL) GOTO 11 
      TMP = TMP2 
      OFFDIG = OFFDIG2 
10 END DO 
11 CONTINUE 
                                                                        
      IF( YESREL ) THEN 
      INFO = 0 
      RETURN 
      ELSE 
      ENDIF 
!                                                                       
                                                                        
!                                                                       
!     *** MORE TO BE IMPLEMENTED ***                                    
!                                                                       
                                                                        
!                                                                       
!     Test if the lower bidiagonal matrix L from T = L D L^T            
!     (zero shift facto) is well conditioned                            
!                                                                       
                                                                        
!                                                                       
!     Test if the upper bidiagonal matrix U from T = U D U^T            
!     (zero shift facto) is well conditioned.                           
!     In this case, the matrix needs to be flipped and, at the end      
!     of the eigenvector computation, the flip needs to be applied      
!     to the computed eigenvectors (and the support)                    
!                                                                       
                                                                        
!                                                                       
      RETURN 
!                                                                       
!     END OF DLARRR                                                     
!                                                                       
!> \brief \b DLARRV computes the eigenvectors of the tridiagonal matrix 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARRV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,                     
!                          ISPLIT, M, DOL, DOU, MINRGP,                 
!                          RTOL1, RTOL2, W, WERR, WGAP,                 
!                          IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,        
!                          WORK, IWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            DOL, DOU, INFO, LDZ, M, N                    
!       DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),       
!      $                   ISUPPZ( * ), IWORK( * )                      
!       DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),
!      $                   WGAP( * ), WORK( * )                         
!       DOUBLE PRECISION  Z( LDZ, * )                                   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARRV computes the eigenvectors of the tridiagonal matrix           
!> T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D 
!> The input eigenvalues should have been computed by DLARRE.           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>          Lower bound of the interval that contains the desired       
!>          eigenvalues. VL < VU. Needed to compute gaps on the left or 
!>          end of the extremal eigenvalues in the desired RANGE.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>          Upper bound of the interval that contains the desired       
!>          eigenvalues. VL < VU.                                       
!>          Note: VU is currently not used by this implementation of DLA
!>          passed to DLARRV because it could be used compute gaps on th
!>          of the extremal eigenvalues. However, with not much initial 
!>          LAMBDA and VU, the formula can lead to an overestimation of 
!>          and thus to inadequately early RQI 'convergence'. This is cu
!>          prevented this by forcing a small right gap. And so it turns
!>          is currently not used by this implementation of DLARRV.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the N diagonal elements of the diagonal matrix D. 
!>          On exit, D may be overwritten.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] L                                                     
!> \verbatim                                                            
!>          L is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the (N-1) subdiagonal elements of the unit        
!>          bidiagonal matrix L are in elements 1 to N-1 of L           
!>          (if the matrix is not split.) At the end of each block      
!>          is stored the corresponding shift as given by DLARRE.       
!>          On exit, L is overwritten.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PIVMIN                                                    
!> \verbatim                                                            
!>          PIVMIN is DOUBLE PRECISION                                  
!>          The minimum pivot allowed in the Sturm sequence.            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into blocks.     
!>          The first block consists of rows/columns 1 to               
!>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1       
!>          through ISPLIT( 2 ), etc.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of input eigenvalues.  0 <= M <= N.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DOL                                                       
!> \verbatim                                                            
!>          DOL is INTEGER                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DOU                                                       
!> \verbatim                                                            
!>          DOU is INTEGER                                              
!>          If the user wants to compute only selected eigenvectors from
!>          the eigenvalues supplied, he can specify an index range DOL:
!>          Or else the setting DOL=1, DOU=M should be applied.         
!>          Note that DOL and DOU refer to the order in which the eigenv
!>          are stored in W.                                            
!>          If the user wants to compute only selected eigenpairs, then 
!>          the columns DOL-1 to DOU+1 of the eigenvector space Z contai
!>          computed eigenvectors. All other columns of Z are set to zer
!> \endverbatim                                                         
!>                                                                      
!> \param[in] MINRGP                                                    
!> \verbatim                                                            
!>          MINRGP is DOUBLE PRECISION                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL1                                                     
!> \verbatim                                                            
!>          RTOL1 is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RTOL2                                                     
!> \verbatim                                                            
!>          RTOL2 is DOUBLE PRECISION                                   
!>           Parameters for bisection.                                  
!>           An interval [LEFT,RIGHT] has converged if                  
!>           RIGHT-LEFT < MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] W                                                     
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          The first M elements of W contain the APPROXIMATE eigenvalue
!>          which eigenvectors are to be computed.  The eigenvalues     
!>          should be grouped by split-off block and ordered from       
!>          smallest to largest within the block ( The output array     
!>          W from DLARRE is expected here ). Furthermore, they are with
!>          respect to the shift of the corresponding root representatio
!>          for their block. On exit, W holds the eigenvalues of the    
!>          UNshifted matrix.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WERR                                                  
!> \verbatim                                                            
!>          WERR is DOUBLE PRECISION array, dimension (N)               
!>          The first M elements contain the semiwidth of the uncertaint
!>          interval of the corresponding eigenvalue in W               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] WGAP                                                  
!> \verbatim                                                            
!>          WGAP is DOUBLE PRECISION array, dimension (N)               
!>          The separation from the right neighbor eigenvalue in W.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IBLOCK                                                    
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The indices of the blocks (submatrices) associated with the 
!>          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue   
!>          W(i) belongs to the first block from the top, =2 if W(i)    
!>          belongs to the second block, etc.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INDEXW                                                    
!> \verbatim                                                            
!>          INDEXW is INTEGER array, dimension (N)                      
!>          The indices of the eigenvalues within each block (submatrix)
!>          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the   
!>          i-th eigenvalue W(i) is the 10-th eigenvalue in the second b
!> \endverbatim                                                         
!>                                                                      
!> \param[in] GERS                                                      
!> \verbatim                                                            
!>          GERS is DOUBLE PRECISION array, dimension (2*N)             
!>          The N Gerschgorin intervals (the i-th Gerschgorin interval  
      END                                           
!>          is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals shoul
!>          be computed from the original UNshifted matrix.             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M) )     
!>          If INFO = 0, the first M columns of Z contain the           
!>          orthonormal eigenvectors of the matrix T                    
!>          corresponding to the input eigenvalues, with the i-th       
!>          column of Z holding the eigenvector associated with W(i).   
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', LDZ >= max(1,N).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The I-th eigenvector  
!>          is nonzero only in elements ISUPPZ( 2*I-1 ) through         
!>          ISUPPZ( 2*I ).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (12*N)            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (7*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>                                                                      
!>          > 0:  A problem occurred in DLARRV.                         
!>          < 0:  One of the called subroutines signaled an internal pro
!>                Needs inspection of the corresponding parameter IINFO 
!>                for further information.                              
!>                                                                      
!>          =-1:  Problem in DLARRB when refining a child's eigenvalues.
!>          =-2:  Problem in DLARRF when computing the RRR of a child.  
!>                When a child is inside a tight cluster, it can be diff
!>                to find an RRR. A partial remedy from the user's point
!>                view is to make the parameter MINRGP smaller and recom
!>                However, as the orthogonality of the computed vectors 
!>                proportional to 1/MINRGP, the user should be aware tha
!>                he might be trading in precision when he decreases MIN
!>          =-3:  Problem in DLARRB when refining a single eigenvalue   
!>                after the Rayleigh correction was rejected.           
!>          = 5:  The Rayleigh Quotient Iteration failed to converge to 
!>                full accuracy in MAXITR steps.                        
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DLARRV( N, VL, VU, D, L, PIVMIN,                       &
&                   ISPLIT, M, DOL, DOU, MINRGP,                   &
&                   RTOL1, RTOL2, W, WERR, WGAP,                   &
&                   IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ,          &
&                   WORK, IWORK, INFO )                            
!                                                                       
!  -- LAPACK auxiliary routine (version 3.8.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            DOL, DOU, INFO, LDZ, M, N 
      DOUBLE PRECISION   MINRGP, PIVMIN, RTOL1, RTOL2, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), INDEXW( * ), ISPLIT( * ),         &
&                   ISUPPZ( * ), IWORK( * )                        
      DOUBLE PRECISION   D( * ), GERS( * ), L( * ), W( * ), WERR( * ),  &
&                   WGAP( * ), WORK( * )                           
      DOUBLE PRECISION  Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            MAXITR 
      PARAMETER          ( MAXITR = 10 ) 
      DOUBLE PRECISION   ZERO, ONE, TWO, THREE, FOUR, HALF 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,                   &
&                     TWO = 2.0D0, THREE = 3.0D0,                  &
&                     FOUR = 4.0D0, HALF = 0.5D0)                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ESKIP, NEEDBS, STP2II, TRYRQC, USEDBS, USEDRQ 
      INTEGER            DONE, I, IBEGIN, IDONE, IEND, II, IINDC1,      &
&                   IINDC2, IINDR, IINDWK, IINFO, IM, IN, INDEIG,  &
&                   INDLD, INDLLD, INDWRK, ISUPMN, ISUPMX, ITER,   &
&                   ITMP1, J, JBLK, K, MINIWSIZE, MINWSIZE, NCLUS, &
&                   NDEPTH, NEGCNT, NEWCLS, NEWFST, NEWFTT, NEWLST,&
&                   NEWSIZ, OFFSET, OLDCLS, OLDFST, OLDIEN, OLDLST,&
&                   OLDNCL, P, PARITY, Q, WBEGIN, WEND, WINDEX,    &
&                   WINDMN, WINDPL, ZFROM, ZTO, ZUSEDL, ZUSEDU,    &
&                   ZUSEDW                                         
      DOUBLE PRECISION   BSTRES, BSTW, EPS, FUDGE, GAP, GAPTOL, GL, GU, &
&                   LAMBDA, LEFT, LGAP, MINGMA, NRMINV, RESID,     &
&                   RGAP, RIGHT, RQCORR, RQTOL, SAVGAP, SGNDEF,    &
&                   SIGMA, SPDIAM, SSIGMA, TAU, TMP, TOL, ZTZ      
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY, DLAR1V, DLARRB, DLARRF, DLASET,         &
&                   DSCAL                                          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, DBLE, MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!     ..                                                                
                                                                        
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
!     The first N entries of WORK are reserved for the eigenvalues      
      INDLD = N+1 
      INDLLD= 2*N+1 
      INDWRK= 3*N+1 
      MINWSIZE = 12 * N 
                                                                        
      DO 5 I= 1,MINWSIZE 
      WORK( I ) = ZERO 
5 END DO 
                                                                        
!     IWORK(IINDR+1:IINDR+N) hold the twist indices R for the           
!     factorization used to compute the FP vector                       
      IINDR = 0 
!     IWORK(IINDC1+1:IINC2+N) are used to store the clusters of the curr
!     layer and the one above.                                          
      IINDC1 = N 
      IINDC2 = 2*N 
      IINDWK = 3*N + 1 
                                                                        
      MINIWSIZE = 7 * N 
      DO 10 I= 1,MINIWSIZE 
      IWORK( I ) = 0 
10 END DO 
                                                                        
      ZUSEDL = 1 
      IF(DOL.GT.1) THEN 
!        Set lower bound for use of Z                                   
      ZUSEDL = DOL-1 
      ENDIF 
      ZUSEDU = M 
      IF(DOU.LT.M) THEN 
!        Set lower bound for use of Z                                   
      ZUSEDU = DOU+1 
      ENDIF 
!     The width of the part of Z that is used                           
      ZUSEDW = ZUSEDU - ZUSEDL + 1 
                                                                        
                                                                        
      CALL DLASET( 'Full', N, ZUSEDW, ZERO, ZERO,                       &
&                    Z(1,ZUSEDL), LDZ )                            
                                                                        
      EPS = DLAMCH( 'Precision' ) 
      RQTOL = TWO * EPS 
!                                                                       
!     Set expert flags for standard code.                               
      TRYRQC = .TRUE. 
                                                                        
      IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
      ELSE 
!        Only selected eigenpairs are computed. Since the other evalues 
!        are not refined by RQ iteration, bisection has to compute to fu
!        accuracy.                                                      
      RTOL1 = FOUR * EPS 
      RTOL2 = FOUR * EPS 
      ENDIF 
                                                                        
!     The entries WBEGIN:WEND in W, WERR, WGAP correspond to the        
!     desired eigenvalues. The support of the nonzero eigenvector       
!     entries is contained in the interval IBEGIN:IEND.                 
!     Remark that if k eigenpairs are desired, then the eigenvectors    
!     are stored in k contiguous columns of Z.                          
                                                                        
!     DONE is the number of eigenvectors already computed               
      DONE = 0 
      IBEGIN = 1 
      WBEGIN = 1 
      DO 170 JBLK = 1, IBLOCK( M ) 
      IEND = ISPLIT( JBLK ) 
      SIGMA = L( IEND ) 
!        Find the eigenvectors of the submatrix indexed IBEGIN          
!        through IEND.                                                  
      WEND = WBEGIN - 1 
15    CONTINUE 
      IF( WEND.LT.M ) THEN 
            IF( IBLOCK( WEND+1 ).EQ.JBLK ) THEN 
            WEND = WEND + 1 
            GO TO 15 
            END IF 
      END IF 
      IF( WEND.LT.WBEGIN ) THEN 
            IBEGIN = IEND + 1 
            GO TO 170 
      ELSEIF( (WEND.LT.DOL).OR.(WBEGIN.GT.DOU) ) THEN 
            IBEGIN = IEND + 1 
            WBEGIN = WEND + 1 
            GO TO 170 
      END IF 
                                                                        
!        Find local spectral diameter of the block                      
      GL = GERS( 2*IBEGIN-1 ) 
      GU = GERS( 2*IBEGIN ) 
      DO 20 I = IBEGIN+1 , IEND 
            GL = MIN( GERS( 2*I-1 ), GL ) 
            GU = MAX( GERS( 2*I ), GU ) 
20    CONTINUE 
      SPDIAM = GU - GL 
                                                                        
!        OLDIEN is the last index of the previous block                 
      OLDIEN = IBEGIN - 1 
!        Calculate the size of the current block                        
      IN = IEND - IBEGIN + 1 
!        The number of eigenvalues in the current block                 
      IM = WEND - WBEGIN + 1 
                                                                        
!        This is for a 1x1 block                                        
      IF( IBEGIN.EQ.IEND ) THEN 
            DONE = DONE+1 
            Z( IBEGIN, WBEGIN ) = ONE 
            ISUPPZ( 2*WBEGIN-1 ) = IBEGIN 
            ISUPPZ( 2*WBEGIN ) = IBEGIN 
            W( WBEGIN ) = W( WBEGIN ) + SIGMA 
            WORK( WBEGIN ) = W( WBEGIN ) 
            IBEGIN = IEND + 1 
            WBEGIN = WBEGIN + 1 
            GO TO 170 
      END IF 
                                                                        
!        The desired (shifted) eigenvalues are stored in W(WBEGIN:WEND) 
!        Note that these can be approximations, in this case, the corres
!        entries of WERR give the size of the uncertainty interval.     
!        The eigenvalue approximations will be refined when necessary as
!        high relative accuracy is required for the computation of the  
!        corresponding eigenvectors.                                    
      CALL DCOPY( IM, W( WBEGIN ), 1,                                &
&                   WORK( WBEGIN ), 1 )                            
                                                                        
!        We store in W the eigenvalue approximations w.r.t. the original
!        matrix T.                                                      
      DO 30 I=1,IM 
            W(WBEGIN+I-1) = W(WBEGIN+I-1)+SIGMA 
30    CONTINUE 
                                                                        
                                                                        
!        NDEPTH is the current depth of the representation tree         
      NDEPTH = 0 
!        PARITY is either 1 or 0                                        
      PARITY = 1 
!        NCLUS is the number of clusters for the next level of the      
!        representation tree, we start with NCLUS = 1 for the root      
      NCLUS = 1 
      IWORK( IINDC1+1 ) = 1 
      IWORK( IINDC1+2 ) = IM 
                                                                        
!        IDONE is the number of eigenvectors already computed in the cur
!        block                                                          
      IDONE = 0 
!        loop while( IDONE.LT.IM )                                      
!        generate the representation tree for the current block and     
!        compute the eigenvectors                                       
40    CONTINUE 
      IF( IDONE.LT.IM ) THEN 
!           This is a crude protection against infinitely deep trees    
            IF( NDEPTH.GT.M ) THEN 
            INFO = -2 
            RETURN 
            ENDIF 
!           breadth first processing of the current level of the represe
!           tree: OLDNCL = number of clusters on current level          
            OLDNCL = NCLUS 
!           reset NCLUS to count the number of child clusters           
            NCLUS = 0 
!                                                                       
            PARITY = 1 - PARITY 
            IF( PARITY.EQ.0 ) THEN 
            OLDCLS = IINDC1 
            NEWCLS = IINDC2 
            ELSE 
            OLDCLS = IINDC2 
            NEWCLS = IINDC1 
            END IF 
!           Process the clusters on the current level                   
            DO 150 I = 1, OLDNCL 
            J = OLDCLS + 2*I 
!              OLDFST, OLDLST = first, last index of current cluster.   
!                               cluster indices start with 1 and are rel
!                               to WBEGIN when accessing W, WGAP, WERR, 
            OLDFST = IWORK( J-1 ) 
            OLDLST = IWORK( J ) 
            IF( NDEPTH.GT.0 ) THEN 
!                 Retrieve relatively robust representation (RRR) of clu
!                 that has been computed at the previous level          
!                 The RRR is stored in Z and overwritten once the eigenv
!                 have been computed or when the cluster is refined     
                                                                        
                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
!                    Get representation from location of the leftmost ev
!                    of the cluster                                     
                  J = WBEGIN + OLDFST - 1 
                  ELSE 
                  IF(WBEGIN+OLDFST-1.LT.DOL) THEN 
!                       Get representation from the left end of Z array 
                        J = DOL - 1 
                  ELSEIF(WBEGIN+OLDFST-1.GT.DOU) THEN 
!                       Get representation from the right end of Z array
                        J = DOU 
                  ELSE 
                        J = WBEGIN + OLDFST - 1 
                  ENDIF 
                  ENDIF 
                  CALL DCOPY( IN, Z( IBEGIN, J ), 1, D( IBEGIN ), 1 ) 
                  CALL DCOPY( IN-1, Z( IBEGIN, J+1 ), 1, L( IBEGIN ),   &
&               1 )                                                
                  SIGMA = Z( IEND, J+1 ) 
                                                                        
!                 Set the corresponding entries in Z to zero            
                  CALL DLASET( 'Full', IN, 2, ZERO, ZERO,               &
&                         Z( IBEGIN, J), LDZ )                     
            END IF 
                                                                        
!              Compute DL and DLL of current RRR                        
            DO 50 J = IBEGIN, IEND-1 
                  TMP = D( J )*L( J ) 
                  WORK( INDLD-1+J ) = TMP 
                  WORK( INDLLD-1+J ) = TMP*L( J ) 
50          CONTINUE 
                                                                        
            IF( NDEPTH.GT.0 ) THEN 
!                 P and Q are index of the first and last eigenvalue to 
!                 within the current block                              
                  P = INDEXW( WBEGIN-1+OLDFST ) 
                  Q = INDEXW( WBEGIN-1+OLDLST ) 
!                 Offset for the arrays WORK, WGAP and WERR, i.e., the P
!                 through the Q-OFFSET elements of these arrays are to b
!                  OFFSET = P-OLDFST                                    
                  OFFSET = INDEXW( WBEGIN ) - 1 
!                 perform limited bisection (if necessary) to get approx
!                 eigenvalues to the precision needed.                  
                  CALL DLARRB( IN, D( IBEGIN ),                         &
&                         WORK(INDLLD+IBEGIN-1),                   &
&                         P, Q, RTOL1, RTOL2, OFFSET,              &
&                         WORK(WBEGIN),WGAP(WBEGIN),WERR(WBEGIN),  &
&                         WORK( INDWRK ), IWORK( IINDWK ),         &
&                         PIVMIN, SPDIAM, IN, IINFO )              
                  IF( IINFO.NE.0 ) THEN 
                  INFO = -1 
                  RETURN 
                  ENDIF 
!                 We also recompute the extremal gaps. W holds all eigen
!                 of the unshifted matrix and must be used for computati
!                 of WGAP, the entries of WORK might stem from RRRs with
!                 different shifts. The gaps from WBEGIN-1+OLDFST to    
!                 WBEGIN-1+OLDLST are correctly computed in DLARRB.     
!                 However, we only allow the gaps to become greater sinc
!                 this is what should happen when we decrease WERR      
                  IF( OLDFST.GT.1) THEN 
                  WGAP( WBEGIN+OLDFST-2 ) =                          &
&             MAX(WGAP(WBEGIN+OLDFST-2),                           &
&                 W(WBEGIN+OLDFST-1)-WERR(WBEGIN+OLDFST-1)         &
&                 - W(WBEGIN+OLDFST-2)-WERR(WBEGIN+OLDFST-2) )     
                  ENDIF 
                  IF( WBEGIN + OLDLST -1 .LT. WEND ) THEN 
                  WGAP( WBEGIN+OLDLST-1 ) =                          &
&               MAX(WGAP(WBEGIN+OLDLST-1),                         &
&                   W(WBEGIN+OLDLST)-WERR(WBEGIN+OLDLST)           &
&                   - W(WBEGIN+OLDLST-1)-WERR(WBEGIN+OLDLST-1) )   
                  ENDIF 
!                 Each time the eigenvalues in WORK get refined, we stor
!                 the newly found approximation with all shifts applied 
                  DO 53 J=OLDFST,OLDLST 
                  W(WBEGIN+J-1) = WORK(WBEGIN+J-1)+SIGMA 
53             CONTINUE 
            END IF 
                                                                        
!              Process the current node.                                
            NEWFST = OLDFST 
            DO 140 J = OLDFST, OLDLST 
                  IF( J.EQ.OLDLST ) THEN 
!                    we are at the right end of the cluster, this is als
!                    boundary of the child cluster                      
                  NEWLST = J 
                  ELSE IF ( WGAP( WBEGIN + J -1).GE.                    &
&                    MINRGP* ABS( WORK(WBEGIN + J -1) ) ) THEN     
!                    the right relative gap is big enough, the child clu
!                    (NEWFST,..,NEWLST) is well separated from the follo
                  NEWLST = J 
                  ELSE 
!                    inside a child cluster, the relative gap is not    
!                    big enough.                                        
                  GOTO 140 
                  END IF 
                                                                        
!                 Compute size of child cluster found                   
                  NEWSIZ = NEWLST - NEWFST + 1 
                                                                        
!                 NEWFTT is the place in Z where the new RRR or the comp
!                 eigenvector is to be stored                           
                  IF((DOL.EQ.1).AND.(DOU.EQ.M)) THEN 
!                    Store representation at location of the leftmost ev
!                    of the cluster                                     
                  NEWFTT = WBEGIN + NEWFST - 1 
                  ELSE 
                  IF(WBEGIN+NEWFST-1.LT.DOL) THEN 
!                       Store representation at the left end of Z array 
                        NEWFTT = DOL - 1 
                  ELSEIF(WBEGIN+NEWFST-1.GT.DOU) THEN 
!                       Store representation at the right end of Z array
                        NEWFTT = DOU 
                  ELSE 
                        NEWFTT = WBEGIN + NEWFST - 1 
                  ENDIF 
                  ENDIF 
                                                                        
                  IF( NEWSIZ.GT.1) THEN 
!                                                                       
!                    Current child is not a singleton but a cluster.    
!                    Compute and store new representation of child.     
!                                                                       
!                                                                       
!                    Compute left and right cluster gap.                
!                                                                       
!                    LGAP and RGAP are not computed from WORK because   
!                    the eigenvalue approximations may stem from RRRs   
!                    different shifts. However, W hold all eigenvalues  
!                    of the unshifted matrix. Still, the entries in WGAP
!                    have to be computed from WORK since the entries    
!                    in W might be of the same order so that gaps are no
!                    exhibited correctly for very close eigenvalues.    
                  IF( NEWFST.EQ.1 ) THEN 
                        LGAP = MAX( ZERO,                               &
&                       W(WBEGIN)-WERR(WBEGIN) - VL )              
                  ELSE 
                        LGAP = WGAP( WBEGIN+NEWFST-2 ) 
                  ENDIF 
                  RGAP = WGAP( WBEGIN+NEWLST-1 ) 
!                                                                       
!                    Compute left- and rightmost eigenvalue of child    
!                    to high precision in order to shift as close       
!                    as possible and obtain as large relative gaps      
!                    as possible                                        
!                                                                       
                  DO 55 K =1,2 
                        IF(K.EQ.1) THEN 
                        P = INDEXW( WBEGIN-1+NEWFST ) 
                        ELSE 
                        P = INDEXW( WBEGIN-1+NEWLST ) 
                        ENDIF 
                        OFFSET = INDEXW( WBEGIN ) - 1 
                        CALL DLARRB( IN, D(IBEGIN),                     &
&                       WORK( INDLLD+IBEGIN-1 ),P,P,               &
&                       RQTOL, RQTOL, OFFSET,                      &
&                       WORK(WBEGIN),WGAP(WBEGIN),                 &
&                       WERR(WBEGIN),WORK( INDWRK ),               &
&                       IWORK( IINDWK ), PIVMIN, SPDIAM,           &
&                       IN, IINFO )                                
55                CONTINUE 
!                                                                       
                  IF((WBEGIN+NEWLST-1.LT.DOL).OR.                    &
&                  (WBEGIN+NEWFST-1.GT.DOU)) THEN                  
!                       if the cluster contains no desired eigenvalues  
!                       skip the computation of that branch of the rep. 
!                                                                       
!                       We could skip before the refinement of the extre
!                       eigenvalues of the child, but then the represent
!                       tree could be different from the one when nothin
!                       skipped. For this reason we skip at this place. 
                        IDONE = IDONE + NEWLST - NEWFST + 1 
                        GOTO 139 
                  ENDIF 
!                                                                       
!                    Compute RRR of child cluster.                      
!                    Note that the new RRR is stored in Z               
!                                                                       
!                    DLARRF needs LWORK = 2*N                           
                  CALL DLARRF( IN, D( IBEGIN ), L( IBEGIN ),         &
&                         WORK(INDLD+IBEGIN-1),                    &
&                         NEWFST, NEWLST, WORK(WBEGIN),            &
&                         WGAP(WBEGIN), WERR(WBEGIN),              &
&                         SPDIAM, LGAP, RGAP, PIVMIN, TAU,         &
&                         Z(IBEGIN, NEWFTT),Z(IBEGIN, NEWFTT+1),   &
&                         WORK( INDWRK ), IINFO )                  
                  IF( IINFO.EQ.0 ) THEN 
!                       a new RRR for the cluster was found by DLARRF   
!                       update shift and store it                       
                        SSIGMA = SIGMA + TAU 
                        Z( IEND, NEWFTT+1 ) = SSIGMA 
!                       WORK() are the midpoints and WERR() the semi-wid
!                       Note that the entries in W are unchanged.       
                        DO 116 K = NEWFST, NEWLST 
                        FUDGE =                                      &
&                          THREE*EPS*ABS(WORK(WBEGIN+K-1))         
                        WORK( WBEGIN + K - 1 ) =                     &
&                          WORK( WBEGIN + K - 1) - TAU             
                        FUDGE = FUDGE +                              &
&                          FOUR*EPS*ABS(WORK(WBEGIN+K-1))          
!                          Fudge errors                                 
                        WERR( WBEGIN + K - 1 ) =                     &
&                          WERR( WBEGIN + K - 1 ) + FUDGE          
!                          Gaps are not fudged. Provided that WERR is sm
!                          when eigenvalues are close, a zero gap indica
!                          that a new representation is needed for resol
!                          the cluster. A fudge could lead to a wrong de
!                          of judging eigenvalues 'separated' which in  
!                          reality are not. This could have a negative i
!                          on the orthogonality of the computed eigenvec
116                   CONTINUE 
                                                                        
                        NCLUS = NCLUS + 1 
                        K = NEWCLS + 2*NCLUS 
                        IWORK( K-1 ) = NEWFST 
                        IWORK( K ) = NEWLST 
                  ELSE 
                        INFO = -2 
                        RETURN 
                  ENDIF 
                  ELSE 
!                                                                       
!                    Compute eigenvector of singleton                   
!                                                                       
                  ITER = 0 
!                                                                       
                  TOL = FOUR * LOG(DBLE(IN)) * EPS 
!                                                                       
                  K = NEWFST 
                  WINDEX = WBEGIN + K - 1 
                  WINDMN = MAX(WINDEX - 1,1) 
                  WINDPL = MIN(WINDEX + 1,M) 
                  LAMBDA = WORK( WINDEX ) 
                  DONE = DONE + 1 
!                    Check if eigenvector computation is to be skipped  
                  IF((WINDEX.LT.DOL).OR.                             &
&                  (WINDEX.GT.DOU)) THEN                           
                        ESKIP = .TRUE. 
                        GOTO 125 
                  ELSE 
                        ESKIP = .FALSE. 
                  ENDIF 
                  LEFT = WORK( WINDEX ) - WERR( WINDEX ) 
                  RIGHT = WORK( WINDEX ) + WERR( WINDEX ) 
                  INDEIG = INDEXW( WINDEX ) 
!                    Note that since we compute the eigenpairs for a chi
!                    all eigenvalue approximations are w.r.t the same sh
!                    In this case, the entries in WORK should be used fo
!                    computing the gaps since they exhibit even very sma
!                    differences in the eigenvalues, as opposed to the  
!                    entries in W which might "look" the same.          
                                                                        
                  IF( K .EQ. 1) THEN 
!                       In the case RANGE='I' and with not much initial 
!                       accuracy in LAMBDA and VL, the formula          
!                       LGAP = MAX( ZERO, (SIGMA - VL) + LAMBDA )       
!                       can lead to an overestimation of the left gap an
!                       thus to inadequately early RQI 'convergence'.   
!                       Prevent this by forcing a small left gap.       
                        LGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT)) 
                  ELSE 
                        LGAP = WGAP(WINDMN) 
                  ENDIF 
                  IF( K .EQ. IM) THEN 
!                       In the case RANGE='I' and with not much initial 
!                       accuracy in LAMBDA and VU, the formula          
!                       can lead to an overestimation of the right gap a
!                       thus to inadequately early RQI 'convergence'.   
!                       Prevent this by forcing a small right gap.      
                        RGAP = EPS*MAX(ABS(LEFT),ABS(RIGHT)) 
                  ELSE 
                        RGAP = WGAP(WINDEX) 
                  ENDIF 
                  GAP = MIN( LGAP, RGAP ) 
                  IF(( K .EQ. 1).OR.(K .EQ. IM)) THEN 
!                       The eigenvector support can become wrong        
!                       because significant entries could be cut off due
!                       large GAPTOL parameter in LAR1V. Prevent this.  
                        GAPTOL = ZERO 
                  ELSE 
                        GAPTOL = GAP * EPS 
                  ENDIF 
                  ISUPMN = IN 
                  ISUPMX = 1 
!                    Update WGAP so that it holds the minimum gap       
!                    to the left or the right. This is crucial in the   
!                    case where bisection is used to ensure that the    
!                    eigenvalue is refined up to the required precision.
!                    The correct value is restored afterwards.          
                  SAVGAP = WGAP(WINDEX) 
                  WGAP(WINDEX) = GAP 
!                    We want to use the Rayleigh Quotient Correction    
!                    as often as possible since it converges quadratical
!                    when we are close enough to the desired eigenvalue.
!                    However, the Rayleigh Quotient can have the wrong s
!                    and lead us away from the desired eigenvalue. In th
!                    case, the best we can do is to use bisection.      
                  USEDBS = .FALSE. 
                  USEDRQ = .FALSE. 
!                    Bisection is initially turned off unless it is forc
                  NEEDBS =  .NOT.TRYRQC 
120                CONTINUE 
!                    Check if bisection should be used to refine eigenva
                  IF(NEEDBS) THEN 
!                       Take the bisection as new iterate               
                        USEDBS = .TRUE. 
                        ITMP1 = IWORK( IINDR+WINDEX ) 
                        OFFSET = INDEXW( WBEGIN ) - 1 
                        CALL DLARRB( IN, D(IBEGIN),                     &
&                       WORK(INDLLD+IBEGIN-1),INDEIG,INDEIG,       &
&                       ZERO, TWO*EPS, OFFSET,                     &
&                       WORK(WBEGIN),WGAP(WBEGIN),                 &
&                       WERR(WBEGIN),WORK( INDWRK ),               &
&                       IWORK( IINDWK ), PIVMIN, SPDIAM,           &
&                       ITMP1, IINFO )                             
                        IF( IINFO.NE.0 ) THEN 
                        INFO = -3 
                        RETURN 
                        ENDIF 
                        LAMBDA = WORK( WINDEX ) 
!                       Reset twist index from inaccurate LAMBDA to     
!                       force computation of true MINGMA                
                        IWORK( IINDR+WINDEX ) = 0 
                  ENDIF 
!                    Given LAMBDA, compute the eigenvector.             
                  CALL DLAR1V( IN, 1, IN, LAMBDA, D( IBEGIN ),       &
&                    L( IBEGIN ), WORK(INDLD+IBEGIN-1),            &
&                    WORK(INDLLD+IBEGIN-1),                        &
&                    PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),          &
&                    .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,             &
&                    IWORK( IINDR+WINDEX ), ISUPPZ( 2*WINDEX-1 ),  &
&                    NRMINV, RESID, RQCORR, WORK( INDWRK ) )       
                  IF(ITER .EQ. 0) THEN 
                        BSTRES = RESID 
                        BSTW = LAMBDA 
                  ELSEIF(RESID.LT.BSTRES) THEN 
                        BSTRES = RESID 
                        BSTW = LAMBDA 
                  ENDIF 
                  ISUPMN = MIN(ISUPMN,ISUPPZ( 2*WINDEX-1 )) 
                  ISUPMX = MAX(ISUPMX,ISUPPZ( 2*WINDEX )) 
                  ITER = ITER + 1 
                                                                        
!                    sin alpha <= |resid|/gap                           
!                    Note that both the residual and the gap are        
!                    proportional to the matrix, so ||T|| doesn't play  
!                    a role in the quotient                             
                                                                        
!                                                                       
!                    Convergence test for Rayleigh-Quotient iteration   
!                    (omitted when Bisection has been used)             
!                                                                       
                  IF( RESID.GT.TOL*GAP .AND. ABS( RQCORR ).GT.       &
&                    RQTOL*ABS( LAMBDA ) .AND. .NOT. USEDBS)       &
&                    THEN                                          
!                       We need to check that the RQCORR update doesn't 
!                       move the eigenvalue away from the desired one an
!                       towards a neighbor. -> protection with bisection
                        IF(INDEIG.LE.NEGCNT) THEN 
!                          The wanted eigenvalue lies to the left       
                        SGNDEF = -ONE 
                        ELSE 
!                          The wanted eigenvalue lies to the right      
                        SGNDEF = ONE 
                        ENDIF 
!                       We only use the RQCORR if it improves the       
!                       the iterate reasonably.                         
                        IF( ( RQCORR*SGNDEF.GE.ZERO )                   &
&                       .AND.( LAMBDA + RQCORR.LE. RIGHT)          &
&                       .AND.( LAMBDA + RQCORR.GE. LEFT)           &
&                       ) THEN                                     
                        USEDRQ = .TRUE. 
!                          Store new midpoint of bisection interval in W
                        IF(SGNDEF.EQ.ONE) THEN 
!                             The current LAMBDA is on the left of the t
!                             eigenvalue                                
                              LEFT = LAMBDA 
!                             We prefer to assume that the error estimat
!                             is correct. We could make the interval not
!                             as a bracket but to be modified if the RQC
!                             chooses to. In this case, the RIGHT side s
!                             be modified as follows:                   
!                              RIGHT = MAX(RIGHT, LAMBDA + RQCORR)      
                        ELSE 
!                             The current LAMBDA is on the right of the 
!                             eigenvalue                                
                              RIGHT = LAMBDA 
!                             See comment about assuming the error estim
!                             correct above.                            
!                              LEFT = MIN(LEFT, LAMBDA + RQCORR)        
                        ENDIF 
                        WORK( WINDEX ) =                             &
&                       HALF * (RIGHT + LEFT)                      
!                          Take RQCORR since it has the correct sign and
!                          improves the iterate reasonably              
                        LAMBDA = LAMBDA + RQCORR 
!                          Update width of error interval               
                        WERR( WINDEX ) =                             &
&                             HALF * (RIGHT-LEFT)                  
                        ELSE 
                        NEEDBS = .TRUE. 
                        ENDIF 
                        IF(RIGHT-LEFT.LT.RQTOL*ABS(LAMBDA)) THEN 
!                             The eigenvalue is computed to bisection ac
!                             compute eigenvector and stop              
                        USEDBS = .TRUE. 
                        GOTO 120 
                        ELSEIF( ITER.LT.MAXITR ) THEN 
                        GOTO 120 
                        ELSEIF( ITER.EQ.MAXITR ) THEN 
                        NEEDBS = .TRUE. 
                        GOTO 120 
                        ELSE 
                        INFO = 5 
                        RETURN 
                        END IF 
                  ELSE 
                        STP2II = .FALSE. 
      IF(USEDRQ .AND. USEDBS .AND.                                    &
&                     BSTRES.LE.RESID) THEN                        
                        LAMBDA = BSTW 
                        STP2II = .TRUE. 
                        ENDIF 
                        IF (STP2II) THEN 
!                          improve error angle by second step           
                        CALL DLAR1V( IN, 1, IN, LAMBDA,              &
&                          D( IBEGIN ), L( IBEGIN ),               &
&                          WORK(INDLD+IBEGIN-1),                   &
&                          WORK(INDLLD+IBEGIN-1),                  &
&                          PIVMIN, GAPTOL, Z( IBEGIN, WINDEX ),    &
&                          .NOT.USEDBS, NEGCNT, ZTZ, MINGMA,       &
&                          IWORK( IINDR+WINDEX ),                  &
&                          ISUPPZ( 2*WINDEX-1 ),                   &
&                          NRMINV, RESID, RQCORR, WORK( INDWRK ) ) 
                        ENDIF 
                        WORK( WINDEX ) = LAMBDA 
                  END IF 
!                                                                       
!                    Compute FP-vector support w.r.t. whole matrix      
!                                                                       
                  ISUPPZ( 2*WINDEX-1 ) = ISUPPZ( 2*WINDEX-1 )+OLDIEN 
                  ISUPPZ( 2*WINDEX ) = ISUPPZ( 2*WINDEX )+OLDIEN 
                  ZFROM = ISUPPZ( 2*WINDEX-1 ) 
                  ZTO = ISUPPZ( 2*WINDEX ) 
                  ISUPMN = ISUPMN + OLDIEN 
                  ISUPMX = ISUPMX + OLDIEN 
!                    Ensure vector is ok if support in the RQI has chang
                  IF(ISUPMN.LT.ZFROM) THEN 
                        DO 122 II = ISUPMN,ZFROM-1 
                        Z( II, WINDEX ) = ZERO 
122                   CONTINUE 
                  ENDIF 
                  IF(ISUPMX.GT.ZTO) THEN 
                        DO 123 II = ZTO+1,ISUPMX 
                        Z( II, WINDEX ) = ZERO 
123                   CONTINUE 
                  ENDIF 
                  CALL DSCAL( ZTO-ZFROM+1, NRMINV,                   &
&                       Z( ZFROM, WINDEX ), 1 )                    
125                CONTINUE 
!                    Update W                                           
                  W( WINDEX ) = LAMBDA+SIGMA 
!                    Recompute the gaps on the left and right           
!                    But only allow them to become larger and not       
!                    smaller (which can only happen through "bad"       
!                    cancellation and doesn't reflect the theory        
!                    where the initial gaps are underestimated due      
!                    to WERR being too crude.)                          
                  IF(.NOT.ESKIP) THEN 
                        IF( K.GT.1) THEN 
                        WGAP( WINDMN ) = MAX( WGAP(WINDMN),          &
&                          W(WINDEX)-WERR(WINDEX)                  &
&                          - W(WINDMN)-WERR(WINDMN) )              
                        ENDIF 
                        IF( WINDEX.LT.WEND ) THEN 
                        WGAP( WINDEX ) = MAX( SAVGAP,                &
&                          W( WINDPL )-WERR( WINDPL )              &
&                          - W( WINDEX )-WERR( WINDEX) )           
                        ENDIF 
                  ENDIF 
                  IDONE = IDONE + 1 
                  ENDIF 
!                 here ends the code for the current child              
!                                                                       
139             CONTINUE 
!                 Proceed to any remaining child nodes                  
                  NEWFST = J + 1 
140          CONTINUE 
150       CONTINUE 
            NDEPTH = NDEPTH + 1 
            GO TO 40 
      END IF 
      IBEGIN = IEND + 1 
      WBEGIN = WEND + 1 
170 END DO 
!                                                                       
                                                                        
      RETURN 
!                                                                       
!     End of DLARRV                                                     
!                                                                       
      END                                           
!> \brief \b DLARUV returns a vector of n random real numbers from a uni
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLARUV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLARUV( ISEED, N, X )                                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            N                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISEED( 4 )                                   
!       DOUBLE PRECISION   X( N )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLARUV returns a vector of n random real numbers from a uniform (0,1)
!> distribution (n <= 128).                                             
!>                                                                      
!> This is an auxiliary routine called by DLARNV and ZLARNV.            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in,out] ISEED                                                 
!> \verbatim                                                            
!>          ISEED is INTEGER array, dimension (4)                       
!>          On entry, the seed of the random number generator; the array
!>          elements must be between 0 and 4095, and ISEED(4) must be   
!>          odd.                                                        
!>          On exit, the seed is updated.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of random numbers to be generated. N <= 128.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] X                                                        
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension (N)                  
!>          The generated random numbers.                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  This routine uses a multiplicative congruential method with modulus 
!>  2**48 and multiplier 33952834046453 (see G.S.Fishman,               
!>  'Multiplicative congruential random number generators with modulus  
!>  2**b: an exhaustive analysis for b = 32 and a partial analysis for  
!>  b = 48', Math. Comp. 189, pp 331-344, 1990).                        
!>                                                                      
!>  48-bit integers are stored in 4 integer array elements with 12 bits 
!>  per element. Hence the routine is portable across machines with     
!>  integers of 32 bits or more.                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLARUV( ISEED, N, X ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISEED( 4 ) 
      DOUBLE PRECISION   X( N ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D0 ) 
      INTEGER            LV, IPW2 
      DOUBLE PRECISION   R 
      PARAMETER          ( LV = 128, IPW2 = 4096, R = ONE / IPW2 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, I1, I2, I3, I4, IT1, IT2, IT3, IT4, J 
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            MM( LV, 4 ) 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          DBLE, MIN, MOD 
!     ..                                                                
!     .. Data statements ..                                             
      DATA               ( MM( 1, J ), J = 1, 4 ) / 494, 322, 2508,     &
&                   2549 /                                         
      DATA               ( MM( 2, J ), J = 1, 4 ) / 2637, 789, 3754,    &
&                   1145 /                                         
      DATA               ( MM( 3, J ), J = 1, 4 ) / 255, 1440, 1766,    &
&                   2253 /                                         
      DATA               ( MM( 4, J ), J = 1, 4 ) / 2008, 752, 3572,    &
&                   305 /                                          
      DATA               ( MM( 5, J ), J = 1, 4 ) / 1253, 2859, 2893,   &
&                   3301 /                                         
      DATA               ( MM( 6, J ), J = 1, 4 ) / 3344, 123, 307,     &
&                   1065 /                                         
      DATA               ( MM( 7, J ), J = 1, 4 ) / 4084, 1848, 1297,   &
&                   3133 /                                         
      DATA               ( MM( 8, J ), J = 1, 4 ) / 1739, 643, 3966,    &
&                   2913 /                                         
      DATA               ( MM( 9, J ), J = 1, 4 ) / 3143, 2405, 758,    &
&                   3285 /                                         
      DATA               ( MM( 10, J ), J = 1, 4 ) / 3468, 2638, 2598,  &
&                   1241 /                                         
      DATA               ( MM( 11, J ), J = 1, 4 ) / 688, 2344, 3406,   &
&                   1197 /                                         
      DATA               ( MM( 12, J ), J = 1, 4 ) / 1657, 46, 2922,    &
&                   3729 /                                         
      DATA               ( MM( 13, J ), J = 1, 4 ) / 1238, 3814, 1038,  &
&                   2501 /                                         
      DATA               ( MM( 14, J ), J = 1, 4 ) / 3166, 913, 2934,   &
&                   1673 /                                         
      DATA               ( MM( 15, J ), J = 1, 4 ) / 1292, 3649, 2091,  &
&                   541 /                                          
      DATA               ( MM( 16, J ), J = 1, 4 ) / 3422, 339, 2451,   &
&                   2753 /                                         
      DATA               ( MM( 17, J ), J = 1, 4 ) / 1270, 3808, 1580,  &
&                   949 /                                          
      DATA               ( MM( 18, J ), J = 1, 4 ) / 2016, 822, 1958,   &
&                   2361 /                                         
      DATA               ( MM( 19, J ), J = 1, 4 ) / 154, 2832, 2055,   &
&                   1165 /                                         
      DATA               ( MM( 20, J ), J = 1, 4 ) / 2862, 3078, 1507,  &
&                   4081 /                                         
      DATA               ( MM( 21, J ), J = 1, 4 ) / 697, 3633, 1078,   &
&                   2725 /                                         
      DATA               ( MM( 22, J ), J = 1, 4 ) / 1706, 2970, 3273,  &
&                   3305 /                                         
      DATA               ( MM( 23, J ), J = 1, 4 ) / 491, 637, 17,      &
&                   3069 /                                         
      DATA               ( MM( 24, J ), J = 1, 4 ) / 931, 2249, 854,    &
&                   3617 /                                         
      DATA               ( MM( 25, J ), J = 1, 4 ) / 1444, 2081, 2916,  &
&                   3733 /                                         
      DATA               ( MM( 26, J ), J = 1, 4 ) / 444, 4019, 3971,   &
&                   409 /                                          
      DATA               ( MM( 27, J ), J = 1, 4 ) / 3577, 1478, 2889,  &
&                   2157 /                                         
      DATA               ( MM( 28, J ), J = 1, 4 ) / 3944, 242, 3831,   &
&                   1361 /                                         
      DATA               ( MM( 29, J ), J = 1, 4 ) / 2184, 481, 2621,   &
&                   3973 /                                         
      DATA               ( MM( 30, J ), J = 1, 4 ) / 1661, 2075, 1541,  &
&                   1865 /                                         
      DATA               ( MM( 31, J ), J = 1, 4 ) / 3482, 4058, 893,   &
&                   2525 /                                         
      DATA               ( MM( 32, J ), J = 1, 4 ) / 657, 622, 736,     &
&                   1409 /                                         
      DATA               ( MM( 33, J ), J = 1, 4 ) / 3023, 3376, 3992,  &
&                   3445 /                                         
      DATA               ( MM( 34, J ), J = 1, 4 ) / 3618, 812, 787,    &
&                   3577 /                                         
      DATA               ( MM( 35, J ), J = 1, 4 ) / 1267, 234, 2125,   &
&                   77 /                                           
      DATA               ( MM( 36, J ), J = 1, 4 ) / 1828, 641, 2364,   &
&                   3761 /                                         
      DATA               ( MM( 37, J ), J = 1, 4 ) / 164, 4005, 2460,   &
&                   2149 /                                         
      DATA               ( MM( 38, J ), J = 1, 4 ) / 3798, 1122, 257,   &
&                   1449 /                                         
      DATA               ( MM( 39, J ), J = 1, 4 ) / 3087, 3135, 1574,  &
&                   3005 /                                         
      DATA               ( MM( 40, J ), J = 1, 4 ) / 2400, 2640, 3912,  &
&                   225 /                                          
      DATA               ( MM( 41, J ), J = 1, 4 ) / 2870, 2302, 1216,  &
&                   85 /                                           
      DATA               ( MM( 42, J ), J = 1, 4 ) / 3876, 40, 3248,    &
&                   3673 /                                         
      DATA               ( MM( 43, J ), J = 1, 4 ) / 1905, 1832, 3401,  &
&                   3117 /                                         
      DATA               ( MM( 44, J ), J = 1, 4 ) / 1593, 2247, 2124,  &
&                   3089 /                                         
      DATA               ( MM( 45, J ), J = 1, 4 ) / 1797, 2034, 2762,  &
&                   1349 /                                         
      DATA               ( MM( 46, J ), J = 1, 4 ) / 1234, 2637, 149,   &
&                   2057 /                                         
      DATA               ( MM( 47, J ), J = 1, 4 ) / 3460, 1287, 2245,  &
&                   413 /                                          
      DATA               ( MM( 48, J ), J = 1, 4 ) / 328, 1691, 166,    &
&                   65 /                                           
      DATA               ( MM( 49, J ), J = 1, 4 ) / 2861, 496, 466,    &
&                   1845 /                                         
      DATA               ( MM( 50, J ), J = 1, 4 ) / 1950, 1597, 4018,  &
&                   697 /                                          
      DATA               ( MM( 51, J ), J = 1, 4 ) / 617, 2394, 1399,   &
&                   3085 /                                         
      DATA               ( MM( 52, J ), J = 1, 4 ) / 2070, 2584, 190,   &
&                   3441 /                                         
      DATA               ( MM( 53, J ), J = 1, 4 ) / 3331, 1843, 2879,  &
&                   1573 /                                         
      DATA               ( MM( 54, J ), J = 1, 4 ) / 769, 336, 153,     &
&                   3689 /                                         
      DATA               ( MM( 55, J ), J = 1, 4 ) / 1558, 1472, 2320,  &
&                   2941 /                                         
      DATA               ( MM( 56, J ), J = 1, 4 ) / 2412, 2407, 18,    &
&                   929 /                                          
      DATA               ( MM( 57, J ), J = 1, 4 ) / 2800, 433, 712,    &
&                   533 /                                          
      DATA               ( MM( 58, J ), J = 1, 4 ) / 189, 2096, 2159,   &
&                   2841 /                                         
      DATA               ( MM( 59, J ), J = 1, 4 ) / 287, 1761, 2318,   &
&                   4077 /                                         
      DATA               ( MM( 60, J ), J = 1, 4 ) / 2045, 2810, 2091,  &
&                   721 /                                          
      DATA               ( MM( 61, J ), J = 1, 4 ) / 1227, 566, 3443,   &
&                   2821 /                                         
      DATA               ( MM( 62, J ), J = 1, 4 ) / 2838, 442, 1510,   &
&                   2249 /                                         
      DATA               ( MM( 63, J ), J = 1, 4 ) / 209, 41, 449,      &
&                   2397 /                                         
      DATA               ( MM( 64, J ), J = 1, 4 ) / 2770, 1238, 1956,  &
&                   2817 /                                         
      DATA               ( MM( 65, J ), J = 1, 4 ) / 3654, 1086, 2201,  &
&                   245 /                                          
      DATA               ( MM( 66, J ), J = 1, 4 ) / 3993, 603, 3137,   &
&                   1913 /                                         
      DATA               ( MM( 67, J ), J = 1, 4 ) / 192, 840, 3399,    &
&                   1997 /                                         
      DATA               ( MM( 68, J ), J = 1, 4 ) / 2253, 3168, 1321,  &
&                   3121 /                                         
      DATA               ( MM( 69, J ), J = 1, 4 ) / 3491, 1499, 2271,  &
&                   997 /                                          
      DATA               ( MM( 70, J ), J = 1, 4 ) / 2889, 1084, 3667,  &
&                   1833 /                                         
      DATA               ( MM( 71, J ), J = 1, 4 ) / 2857, 3438, 2703,  &
&                   2877 /                                         
      DATA               ( MM( 72, J ), J = 1, 4 ) / 2094, 2408, 629,   &
&                   1633 /                                         
      DATA               ( MM( 73, J ), J = 1, 4 ) / 1818, 1589, 2365,  &
&                   981 /                                          
      DATA               ( MM( 74, J ), J = 1, 4 ) / 688, 2391, 2431,   &
&                   2009 /                                         
      DATA               ( MM( 75, J ), J = 1, 4 ) / 1407, 288, 1113,   &
&                   941 /                                          
      DATA               ( MM( 76, J ), J = 1, 4 ) / 634, 26, 3922,     &
&                   2449 /                                         
      DATA               ( MM( 77, J ), J = 1, 4 ) / 3231, 512, 2554,   &
&                   197 /                                          
      DATA               ( MM( 78, J ), J = 1, 4 ) / 815, 1456, 184,    &
&                   2441 /                                         
      DATA               ( MM( 79, J ), J = 1, 4 ) / 3524, 171, 2099,   &
&                   285 /                                          
      DATA               ( MM( 80, J ), J = 1, 4 ) / 1914, 1677, 3228,  &
&                   1473 /                                         
      DATA               ( MM( 81, J ), J = 1, 4 ) / 516, 2657, 4012,   &
&                   2741 /                                         
      DATA               ( MM( 82, J ), J = 1, 4 ) / 164, 2270, 1921,   &
&                   3129 /                                         
      DATA               ( MM( 83, J ), J = 1, 4 ) / 303, 2587, 3452,   &
&                   909 /                                          
      DATA               ( MM( 84, J ), J = 1, 4 ) / 2144, 2961, 3901,  &
&                   2801 /                                         
      DATA               ( MM( 85, J ), J = 1, 4 ) / 3480, 1970, 572,   &
&                   421 /                                          
      DATA               ( MM( 86, J ), J = 1, 4 ) / 119, 1817, 3309,   &
&                   4073 /                                         
      DATA               ( MM( 87, J ), J = 1, 4 ) / 3357, 676, 3171,   &
&                   2813 /                                         
      DATA               ( MM( 88, J ), J = 1, 4 ) / 837, 1410, 817,    &
&                   2337 /                                         
      DATA               ( MM( 89, J ), J = 1, 4 ) / 2826, 3723, 3039,  &
&                   1429 /                                         
      DATA               ( MM( 90, J ), J = 1, 4 ) / 2332, 2803, 1696,  &
&                   1177 /                                         
      DATA               ( MM( 91, J ), J = 1, 4 ) / 2089, 3185, 1256,  &
&                   1901 /                                         
      DATA               ( MM( 92, J ), J = 1, 4 ) / 3780, 184, 3715,   &
&                   81 /                                           
      DATA               ( MM( 93, J ), J = 1, 4 ) / 1700, 663, 2077,   &
&                   1669 /                                         
      DATA               ( MM( 94, J ), J = 1, 4 ) / 3712, 499, 3019,   &
&                   2633 /                                         
      DATA               ( MM( 95, J ), J = 1, 4 ) / 150, 3784, 1497,   &
&                   2269 /                                         
      DATA               ( MM( 96, J ), J = 1, 4 ) / 2000, 1631, 1101,  &
&                   129 /                                          
      DATA               ( MM( 97, J ), J = 1, 4 ) / 3375, 1925, 717,   &
&                   1141 /                                         
      DATA               ( MM( 98, J ), J = 1, 4 ) / 1621, 3912, 51,    &
&                   249 /                                          
      DATA               ( MM( 99, J ), J = 1, 4 ) / 3090, 1398, 981,   &
&                   3917 /                                         
      DATA               ( MM( 100, J ), J = 1, 4 ) / 3765, 1349, 1978, &
&                   2481 /                                         
      DATA               ( MM( 101, J ), J = 1, 4 ) / 1149, 1441, 1813, &
&                   3941 /                                         
      DATA               ( MM( 102, J ), J = 1, 4 ) / 3146, 2224, 3881, &
&                   2217 /                                         
      DATA               ( MM( 103, J ), J = 1, 4 ) / 33, 2411, 76,     &
&                   2749 /                                         
      DATA               ( MM( 104, J ), J = 1, 4 ) / 3082, 1907, 3846, &
&                   3041 /                                         
      DATA               ( MM( 105, J ), J = 1, 4 ) / 2741, 3192, 3694, &
&                   1877 /                                         
      DATA               ( MM( 106, J ), J = 1, 4 ) / 359, 2786, 1682,  &
&                   345 /                                          
      DATA               ( MM( 107, J ), J = 1, 4 ) / 3316, 382, 124,   &
&                   2861 /                                         
      DATA               ( MM( 108, J ), J = 1, 4 ) / 1749, 37, 1660,   &
&                   1809 /                                         
      DATA               ( MM( 109, J ), J = 1, 4 ) / 185, 759, 3997,   &
&                   3141 /                                         
      DATA               ( MM( 110, J ), J = 1, 4 ) / 2784, 2948, 479,  &
&                   2825 /                                         
      DATA               ( MM( 111, J ), J = 1, 4 ) / 2202, 1862, 1141, &
&                   157 /                                          
      DATA               ( MM( 112, J ), J = 1, 4 ) / 2199, 3802, 886,  &
&                   2881 /                                         
      DATA               ( MM( 113, J ), J = 1, 4 ) / 1364, 2423, 3514, &
&                   3637 /                                         
      DATA               ( MM( 114, J ), J = 1, 4 ) / 1244, 2051, 1301, &
&                   1465 /                                         
      DATA               ( MM( 115, J ), J = 1, 4 ) / 2020, 2295, 3604, &
&                   2829 /                                         
      DATA               ( MM( 116, J ), J = 1, 4 ) / 3160, 1332, 1888, &
&                   2161 /                                         
      DATA               ( MM( 117, J ), J = 1, 4 ) / 2785, 1832, 1836, &
&                   3365 /                                         
      DATA               ( MM( 118, J ), J = 1, 4 ) / 2772, 2405, 1990, &
&                   361 /                                          
      DATA               ( MM( 119, J ), J = 1, 4 ) / 1217, 3638, 2058, &
&                   2685 /                                         
      DATA               ( MM( 120, J ), J = 1, 4 ) / 1822, 3661, 692,  &
&                   3745 /                                         
      DATA               ( MM( 121, J ), J = 1, 4 ) / 1245, 327, 1194,  &
&                   2325 /                                         
      DATA               ( MM( 122, J ), J = 1, 4 ) / 2252, 3660, 20,   &
&                   3609 /                                         
      DATA               ( MM( 123, J ), J = 1, 4 ) / 3904, 716, 3285,  &
&                   3821 /                                         
      DATA               ( MM( 124, J ), J = 1, 4 ) / 2774, 1842, 2046, &
&                   3537 /                                         
      DATA               ( MM( 125, J ), J = 1, 4 ) / 997, 3987, 2107,  &
&                   517 /                                          
      DATA               ( MM( 126, J ), J = 1, 4 ) / 2573, 1368, 3508, &
&                   3017 /                                         
      DATA               ( MM( 127, J ), J = 1, 4 ) / 1148, 1848, 3525, &
&                   2141 /                                         
      DATA               ( MM( 128, J ), J = 1, 4 ) / 545, 2366, 3801,  &
&                   1537 /                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      I1 = ISEED( 1 ) 
      I2 = ISEED( 2 ) 
      I3 = ISEED( 3 ) 
      I4 = ISEED( 4 ) 
!                                                                       
      DO 10 I = 1, MIN( N, LV ) 
!                                                                       
20    CONTINUE 
!                                                                       
!        Multiply the seed by i-th power of the multiplier modulo 2**48 
!                                                                       
      IT4 = I4*MM( I, 4 ) 
      IT3 = IT4 / IPW2 
      IT4 = IT4 - IPW2*IT3 
      IT3 = IT3 + I3*MM( I, 4 ) + I4*MM( I, 3 ) 
      IT2 = IT3 / IPW2 
      IT3 = IT3 - IPW2*IT2 
      IT2 = IT2 + I2*MM( I, 4 ) + I3*MM( I, 3 ) + I4*MM( I, 2 ) 
      IT1 = IT2 / IPW2 
      IT2 = IT2 - IPW2*IT1 
      IT1 = IT1 + I1*MM( I, 4 ) + I2*MM( I, 3 ) + I3*MM( I, 2 ) +    &
&         I4*MM( I, 1 )                                            
      IT1 = MOD( IT1, IPW2 ) 
!                                                                       
!        Convert 48-bit integer to a real number in the interval (0,1)  
!                                                                       
      X( I ) = R*( DBLE( IT1 )+R*( DBLE( IT2 )+R*( DBLE( IT3 )+R*    &
&            DBLE( IT4 ) ) ) )                                     
!                                                                       
      IF (X( I ).EQ.1.0D0) THEN 
!           If a real number has n bits of precision, and the first     
!           n bits of the 48-bit integer above happen to be all 1 (which
!           will occur about once every 2**n calls), then X( I ) will   
!           be rounded to exactly 1.0.                                  
!           Since X( I ) is not supposed to return exactly 0.0 or 1.0,  
!           the statistically correct thing to do in this situation is  
!           simply to iterate again.                                    
!           N.B. the case X( I ) = 0.0 should not be possible.          
            I1 = I1 + 2 
            I2 = I2 + 2 
            I3 = I3 + 2 
            I4 = I4 + 2 
            GOTO 20 
      END IF 
!                                                                       
10 END DO 
!                                                                       
!     Return final value of seed                                        
!                                                                       
      ISEED( 1 ) = IT1 
      ISEED( 2 ) = IT2 
      ISEED( 3 ) = IT3 
      ISEED( 4 ) = IT4 
      RETURN 
!                                                                       
!     End of DLARUV                                                     
!                                                                       
      END                                           
!> \brief \b DLASCL multiplies a general rectangular matrix by a real sc
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASCL + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          TYPE                                         
!       INTEGER            INFO, KL, KU, LDA, M, N                      
!       DOUBLE PRECISION   CFROM, CTO                                   
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASCL multiplies the M by N real matrix A by the real scalar        
!> CTO/CFROM.  This is done without over/underflow as long as the final 
!> result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
!> A may be full, upper triangular, lower triangular, upper Hessenberg, 
!> or banded.                                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] TYPE                                                      
!> \verbatim                                                            
!>          TYPE is CHARACTER*1                                         
!>          TYPE indices the storage type of the input matrix.          
!>          = 'G':  A is a full matrix.                                 
!>          = 'L':  A is a lower triangular matrix.                     
!>          = 'U':  A is an upper triangular matrix.                    
!>          = 'H':  A is an upper Hessenberg matrix.                    
!>          = 'B':  A is a symmetric band matrix with lower bandwidth KL
!>                  and upper bandwidth KU and with the only the lower  
!>                  half stored.                                        
!>          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
!>                  and upper bandwidth KU and with the only the upper  
!>                  half stored.                                        
!>          = 'Z':  A is a band matrix with lower bandwidth KL and upper
!>                  bandwidth KU. See DGBTRF for storage details.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] KL                                                        
!> \verbatim                                                            
!>          KL is INTEGER                                               
!>          The lower bandwidth of A.  Referenced only if TYPE = 'B',   
!>          'Q' or 'Z'.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] KU                                                        
!> \verbatim                                                            
!>          KU is INTEGER                                               
!>          The upper bandwidth of A.  Referenced only if TYPE = 'B',   
!>          'Q' or 'Z'.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CFROM                                                     
!> \verbatim                                                            
!>          CFROM is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CTO                                                       
!> \verbatim                                                            
!>          CTO is DOUBLE PRECISION                                     
!>                                                                      
!>          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed 
!>          without over/underflow if the final result CTO*A(I,J)/CFROM 
!>          can be represented without over/underflow.  CFROM must be   
!>          nonzero.                                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.  M >= 0.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          The matrix to be multiplied by CTO/CFROM.  See TYPE for the 
!>          storage type.                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If TYPE = 'G', 'L', 'U', 'H', LDA >= max(1,M);              
!>             TYPE = 'B', LDA >= KL+1;                                 
!>             TYPE = 'Q', LDA >= KU+1;                                 
!>             TYPE = 'Z', LDA >= 2*KL+KU+1.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          0  - successful exit                                        
!>          <0 - if INFO = -i, the i-th argument had an illegal value.  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          TYPE 
      INTEGER            INFO, KL, KU, LDA, M, N 
      DOUBLE PRECISION   CFROM, CTO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            DONE 
      INTEGER            I, ITYPE, J, K1, K2, K3, K4 
      DOUBLE PRECISION   BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME, DISNAN 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           LSAME, DLAMCH, DISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
!                                                                       
      IF( LSAME( TYPE, 'G' ) ) THEN 
      ITYPE = 0 
      ELSE IF( LSAME( TYPE, 'L' ) ) THEN 
      ITYPE = 1 
      ELSE IF( LSAME( TYPE, 'U' ) ) THEN 
      ITYPE = 2 
      ELSE IF( LSAME( TYPE, 'H' ) ) THEN 
      ITYPE = 3 
      ELSE IF( LSAME( TYPE, 'B' ) ) THEN 
      ITYPE = 4 
      ELSE IF( LSAME( TYPE, 'Q' ) ) THEN 
      ITYPE = 5 
      ELSE IF( LSAME( TYPE, 'Z' ) ) THEN 
      ITYPE = 6 
      ELSE 
      ITYPE = -1 
      END IF 
!                                                                       
      IF( ITYPE.EQ.-1 ) THEN 
      INFO = -1 
      ELSE IF( CFROM.EQ.ZERO .OR. DISNAN(CFROM) ) THEN 
      INFO = -4 
      ELSE IF( DISNAN(CTO) ) THEN 
      INFO = -5 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -6 
      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.             &
&         ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN                       
      INFO = -7 
      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN 
      INFO = -9 
      ELSE IF( ITYPE.GE.4 ) THEN 
      IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN 
            INFO = -2 
      ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.                 &
&            ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )   &
&             THEN                                                 
            INFO = -3 
      ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.                 &
&            ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.                 &
&            ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN          
            INFO = -9 
      END IF 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DLASCL', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 )                                          &
&   RETURN                                                         
!                                                                       
!     Get machine parameters                                            
!                                                                       
      SMLNUM = DLAMCH( 'S' ) 
      BIGNUM = ONE / SMLNUM 
!                                                                       
      CFROMC = CFROM 
      CTOC = CTO 
!                                                                       
10 CONTINUE 
      CFROM1 = CFROMC*SMLNUM 
      IF( CFROM1.EQ.CFROMC ) THEN 
!        CFROMC is an inf.  Multiply by a correctly signed zero for     
!        finite CTOC, or a NaN if CTOC is infinite.                     
      MUL = CTOC / CFROMC 
      DONE = .TRUE. 
      CTO1 = CTOC 
      ELSE 
      CTO1 = CTOC / BIGNUM 
      IF( CTO1.EQ.CTOC ) THEN 
!           CTOC is either 0 or an inf.  In both cases, CTOC itself     
!           serves as the correct multiplication factor.                
            MUL = CTOC 
            DONE = .TRUE. 
            CFROMC = ONE 
      ELSE IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN 
            MUL = SMLNUM 
            DONE = .FALSE. 
            CFROMC = CFROM1 
      ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN 
            MUL = BIGNUM 
            DONE = .FALSE. 
            CTOC = CTO1 
      ELSE 
            MUL = CTOC / CFROMC 
            DONE = .TRUE. 
      END IF 
      END IF 
!                                                                       
      IF( ITYPE.EQ.0 ) THEN 
!                                                                       
!        Full matrix                                                    
!                                                                       
      DO 30 J = 1, N 
            DO 20 I = 1, M 
            A( I, J ) = A( I, J )*MUL 
20       CONTINUE 
30    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.1 ) THEN 
!                                                                       
!        Lower triangular matrix                                        
!                                                                       
      DO 50 J = 1, N 
            DO 40 I = J, M 
            A( I, J ) = A( I, J )*MUL 
40       CONTINUE 
50    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.2 ) THEN 
!                                                                       
!        Upper triangular matrix                                        
!                                                                       
      DO 70 J = 1, N 
            DO 60 I = 1, MIN( J, M ) 
            A( I, J ) = A( I, J )*MUL 
60       CONTINUE 
70    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.3 ) THEN 
!                                                                       
!        Upper Hessenberg matrix                                        
!                                                                       
      DO 90 J = 1, N 
            DO 80 I = 1, MIN( J+1, M ) 
            A( I, J ) = A( I, J )*MUL 
80       CONTINUE 
90    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.4 ) THEN 
!                                                                       
!        Lower half of a symmetric band matrix                          
!                                                                       
      K3 = KL + 1 
      K4 = N + 1 
      DO 110 J = 1, N 
            DO 100 I = 1, MIN( K3, K4-J ) 
            A( I, J ) = A( I, J )*MUL 
100       CONTINUE 
110    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.5 ) THEN 
!                                                                       
!        Upper half of a symmetric band matrix                          
!                                                                       
      K1 = KU + 2 
      K3 = KU + 1 
      DO 130 J = 1, N 
            DO 120 I = MAX( K1-J, 1 ), K3 
            A( I, J ) = A( I, J )*MUL 
120       CONTINUE 
130    CONTINUE 
!                                                                       
      ELSE IF( ITYPE.EQ.6 ) THEN 
!                                                                       
!        Band matrix                                                    
!                                                                       
      K1 = KL + KU + 2 
      K2 = KL + 1 
      K3 = 2*KL + KU + 1 
      K4 = KL + KU + 1 + M 
      DO 150 J = 1, N 
            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J ) 
            A( I, J ) = A( I, J )*MUL 
140       CONTINUE 
150    CONTINUE 
!                                                                       
      END IF 
!                                                                       
      IF( .NOT.DONE )                                                   &
&   GO TO 10                                                       
!                                                                       
      RETURN 
!                                                                       
!     End of DLASCL                                                     
!                                                                       
      END                                           
!> \brief \b DLASET initializes the off-diagonal elements and the diagon
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASET + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASET( UPLO, M, N, ALPHA, BETA, A, LDA )            
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            LDA, M, N                                    
!       DOUBLE PRECISION   ALPHA, BETA                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASET initializes an m-by-n matrix A to BETA on the diagonal and    
!> ALPHA on the offdiagonals.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies the part of the matrix A to be set.               
!>          = 'U':      Upper triangular part is set; the strictly lower
!>                      triangular part of A is not changed.            
!>          = 'L':      Lower triangular part is set; the strictly upper
!>                      triangular part of A is not changed.            
!>          Otherwise:  All of the matrix A is set.                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.  M >= 0.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION                                   
!>          The constant to which the offdiagonal elements are to be set
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is DOUBLE PRECISION                                    
!>          The constant to which the diagonal elements are to be set.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] A                                                        
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          On exit, the leading m-by-n submatrix of A is set as follows
!>                                                                      
!>          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,          
!>          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,          
!>          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,    
!>                                                                      
!>          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,M).     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLASET( UPLO, M, N, ALPHA, BETA, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            LDA, M, N 
      DOUBLE PRECISION   ALPHA, BETA 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, J 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( LSAME( UPLO, 'U' ) ) THEN 
!                                                                       
!        Set the strictly upper triangular or trapezoidal part of the   
!        array to ALPHA.                                                
!                                                                       
      DO 20 J = 2, N 
            DO 10 I = 1, MIN( J-1, M ) 
            A( I, J ) = ALPHA 
10       CONTINUE 
20    CONTINUE 
!                                                                       
      ELSE IF( LSAME( UPLO, 'L' ) ) THEN 
!                                                                       
!        Set the strictly lower triangular or trapezoidal part of the   
!        array to ALPHA.                                                
!                                                                       
      DO 40 J = 1, MIN( M, N ) 
            DO 30 I = J + 1, M 
            A( I, J ) = ALPHA 
30       CONTINUE 
40    CONTINUE 
!                                                                       
      ELSE 
!                                                                       
!        Set the leading m-by-n submatrix to ALPHA.                     
!                                                                       
      DO 60 J = 1, N 
            DO 50 I = 1, M 
            A( I, J ) = ALPHA 
50       CONTINUE 
60    CONTINUE 
      END IF 
!                                                                       
!     Set the first min(M,N) diagonal elements to BETA.                 
!                                                                       
      DO 70 I = 1, MIN( M, N ) 
      A( I, I ) = BETA 
70 END DO 
!                                                                       
      RETURN 
!                                                                       
!     End of DLASET                                                     
!                                                                       
      END                                           
!> \brief \b DLASQ2 computes all the eigenvalues of the symmetric positi
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASQ2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASQ2( N, Z, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASQ2 computes all the eigenvalues of the symmetric positive        
!> definite tridiagonal matrix associated with the qd array Z to high   
!> relative accuracy are computed to high relative accuracy, in the     
!> absence of denormalization, underflow and overflow.                  
!>                                                                      
!> To see the relation of Z to the tridiagonal matrix, let L be a       
!> unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and      
!> let U be an upper bidiagonal matrix with 1's above and diagonal      
!> Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the          
!> symmetric tridiagonal to which it is similar.                        
!>                                                                      
!> Note : DLASQ2 defines a logical variable, IEEE, which is true        
!> on machines which follow ieee-754 floating-point standard in their   
!> handling of infinities and NaNs, and false otherwise. This variable  
!> is passed to DLASQ3.                                                 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>        The number of rows and columns in the matrix. N >= 0.         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension ( 4*N )              
!>        On entry Z holds the qd array. On exit, entries 1 to N hold   
!>        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the     
!>        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If    
!>        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )  
!>        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of     
!>        shifts that failed.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>        = 0: successful exit                                          
!>        < 0: if the i-th argument is a scalar and had an illegal      
!>             value, then INFO = -i, if the i-th argument is an        
!>             array and the j-entry had an illegal value, then         
!>             INFO = -(i*100+j)                                        
!>        > 0: the algorithm failed                                     
!>              = 1, a split was marked by a positive value in E        
!>              = 2, current block of Z not diagonalized after 100*N    
!>                   iterations (in inner while loop).  On exit Z holds 
!>                   a qd array with the same eigenvalues as the given Z
!>              = 3, termination criterion of outer while loop not met  
!>                   (program created more than N unreduced blocks)     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Local Variables: I0:N0 defines a current unreduced segment of Z.    
!>  The shifts are accumulated in SIGMA. Iteration count is in ITER.    
!>  Ping-pong is controlled by PP (alternates between 0 and 1).         
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLASQ2( N, Z, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   CBIAS 
      PARAMETER          ( CBIAS = 1.50D0 ) 
      DOUBLE PRECISION   ZERO, HALF, ONE, TWO, FOUR, HUNDRD 
      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5D0, ONE = 1.0D0,     &
&                     TWO = 2.0D0, FOUR = 4.0D0, HUNDRD = 100.0D0 )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            IEEE 
      INTEGER            I0, I1, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, &
&                   K, KMIN, N0, N1, NBIG, NDIV, NFAIL, PP, SPLT,  &
&                   TTYPE                                          
      DOUBLE PRECISION   D, DEE, DEEMIN, DESIG, DMIN, DMIN1, DMIN2, DN, &
&                   DN1, DN2, E, EMAX, EMIN, EPS, G, OLDEMN, QMAX, &
&                   QMIN, S, SAFMIN, SIGMA, T, TAU, TEMP, TOL,     &
&                   TOL2, TRACE, ZMAX, TEMPE, TEMPQ                
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLASQ3, DLASRT, XERBLA 
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            ILAENV 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH, ILAENV 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments.                                         
!     (in case DLASQ2 is not called by DLASQ1)                          
!                                                                       
      INFO = 0 
      EPS = DLAMCH( 'Precision' ) 
      SAFMIN = DLAMCH( 'Safe minimum' ) 
      TOL = EPS*HUNDRD 
      TOL2 = TOL**2 
!                                                                       
      IF( N.LT.0 ) THEN 
      INFO = -1 
      CALL XERBLA( 'DLASQ2', 1 ) 
      RETURN 
      ELSE IF( N.EQ.0 ) THEN 
      RETURN 
      ELSE IF( N.EQ.1 ) THEN 
!                                                                       
!        1-by-1 case.                                                   
!                                                                       
      IF( Z( 1 ).LT.ZERO ) THEN 
            INFO = -201 
            CALL XERBLA( 'DLASQ2', 2 ) 
      END IF 
      RETURN 
      ELSE IF( N.EQ.2 ) THEN 
!                                                                       
!        2-by-2 case.                                                   
!                                                                       
      IF( Z( 2 ).LT.ZERO .OR. Z( 3 ).LT.ZERO ) THEN 
            INFO = -2 
            CALL XERBLA( 'DLASQ2', 2 ) 
            RETURN 
      ELSE IF( Z( 3 ).GT.Z( 1 ) ) THEN 
            D = Z( 3 ) 
            Z( 3 ) = Z( 1 ) 
            Z( 1 ) = D 
      END IF 
      Z( 5 ) = Z( 1 ) + Z( 2 ) + Z( 3 ) 
      IF( Z( 2 ).GT.Z( 3 )*TOL2 ) THEN 
            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) ) 
            S = Z( 3 )*( Z( 2 ) / T ) 
            IF( S.LE.T ) THEN 
            S = Z( 3 )*( Z( 2 ) / ( T*( ONE+SQRT( ONE+S / T ) ) ) ) 
            ELSE 
            S = Z( 3 )*( Z( 2 ) / ( T+SQRT( T )*SQRT( T+S ) ) ) 
            END IF 
            T = Z( 1 ) + ( S+Z( 2 ) ) 
            Z( 3 ) = Z( 3 )*( Z( 1 ) / T ) 
            Z( 1 ) = T 
      END IF 
      Z( 2 ) = Z( 3 ) 
      Z( 6 ) = Z( 2 ) + Z( 1 ) 
      RETURN 
      END IF 
!                                                                       
!     Check for negative data and compute sums of q's and e's.          
!                                                                       
      Z( 2*N ) = ZERO 
      EMIN = Z( 2 ) 
      QMAX = ZERO 
      ZMAX = ZERO 
      D = ZERO 
      E = ZERO 
!                                                                       
      DO 10 K = 1, 2*( N-1 ), 2 
      IF( Z( K ).LT.ZERO ) THEN 
            INFO = -( 200+K ) 
            CALL XERBLA( 'DLASQ2', 2 ) 
            RETURN 
      ELSE IF( Z( K+1 ).LT.ZERO ) THEN 
            INFO = -( 200+K+1 ) 
            CALL XERBLA( 'DLASQ2', 2 ) 
            RETURN 
      END IF 
      D = D + Z( K ) 
      E = E + Z( K+1 ) 
      QMAX = MAX( QMAX, Z( K ) ) 
      EMIN = MIN( EMIN, Z( K+1 ) ) 
      ZMAX = MAX( QMAX, ZMAX, Z( K+1 ) ) 
10 END DO 
      IF( Z( 2*N-1 ).LT.ZERO ) THEN 
      INFO = -( 200+2*N-1 ) 
      CALL XERBLA( 'DLASQ2', 2 ) 
      RETURN 
      END IF 
      D = D + Z( 2*N-1 ) 
      QMAX = MAX( QMAX, Z( 2*N-1 ) ) 
      ZMAX = MAX( QMAX, ZMAX ) 
!                                                                       
!     Check for diagonality.                                            
!                                                                       
      IF( E.EQ.ZERO ) THEN 
      DO 20 K = 2, N 
            Z( K ) = Z( 2*K-1 ) 
20    CONTINUE 
      CALL DLASRT( 'D', N, Z, IINFO ) 
      Z( 2*N-1 ) = D 
      RETURN 
      END IF 
!                                                                       
      TRACE = D + E 
!                                                                       
!     Check for zero data.                                              
!                                                                       
      IF( TRACE.EQ.ZERO ) THEN 
      Z( 2*N-1 ) = ZERO 
      RETURN 
      END IF 
!                                                                       
!     Check whether the machine is IEEE conformable.                    
!                                                                       
      IEEE = ILAENV( 10, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.         &
&       ILAENV( 11, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1               
!                                                                       
!     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...). 
!                                                                       
      DO 30 K = 2*N, 2, -2 
      Z( 2*K ) = ZERO 
      Z( 2*K-1 ) = Z( K ) 
      Z( 2*K-2 ) = ZERO 
      Z( 2*K-3 ) = Z( K-1 ) 
30 END DO 
!                                                                       
      I0 = 1 
      N0 = N 
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( CBIAS*Z( 4*I0-3 ).LT.Z( 4*N0-3 ) ) THEN 
      IPN4 = 4*( I0+N0 ) 
      DO 40 I4 = 4*I0, 2*( I0+N0-1 ), 4 
            TEMP = Z( I4-3 ) 
            Z( I4-3 ) = Z( IPN4-I4-3 ) 
            Z( IPN4-I4-3 ) = TEMP 
            TEMP = Z( I4-1 ) 
            Z( I4-1 ) = Z( IPN4-I4-5 ) 
            Z( IPN4-I4-5 ) = TEMP 
40    CONTINUE 
      END IF 
!                                                                       
!     Initial split checking via dqd and Li's test.                     
!                                                                       
      PP = 0 
!                                                                       
      DO 80 K = 1, 2 
!                                                                       
      D = Z( 4*N0+PP-3 ) 
      DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4 
            IF( Z( I4-1 ).LE.TOL2*D ) THEN 
            Z( I4-1 ) = -ZERO 
            D = Z( I4-3 ) 
            ELSE 
            D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) ) 
            END IF 
50    CONTINUE 
!                                                                       
!        dqd maps Z to ZZ plus Li's test.                               
!                                                                       
      EMIN = Z( 4*I0+PP+1 ) 
      D = Z( 4*I0+PP-3 ) 
      DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4 
            Z( I4-2*PP-2 ) = D + Z( I4-1 ) 
            IF( Z( I4-1 ).LE.TOL2*D ) THEN 
            Z( I4-1 ) = -ZERO 
            Z( I4-2*PP-2 ) = D 
            Z( I4-2*PP ) = ZERO 
            D = Z( I4+1 ) 
            ELSE IF( SAFMIN*Z( I4+1 ).LT.Z( I4-2*PP-2 ) .AND.           &
&               SAFMIN*Z( I4-2*PP-2 ).LT.Z( I4+1 ) ) THEN          
            TEMP = Z( I4+1 ) / Z( I4-2*PP-2 ) 
            Z( I4-2*PP ) = Z( I4-1 )*TEMP 
            D = D*TEMP 
            ELSE 
            Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) / Z( I4-2*PP-2 ) ) 
            D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) ) 
            END IF 
            EMIN = MIN( EMIN, Z( I4-2*PP ) ) 
60    CONTINUE 
      Z( 4*N0-PP-2 ) = D 
!                                                                       
!        Now find qmax.                                                 
!                                                                       
      QMAX = Z( 4*I0-PP-2 ) 
      DO 70 I4 = 4*I0 - PP + 2, 4*N0 - PP - 2, 4 
            QMAX = MAX( QMAX, Z( I4 ) ) 
70    CONTINUE 
!                                                                       
!        Prepare for the next iteration on K.                           
!                                                                       
      PP = 1 - PP 
80 END DO 
!                                                                       
!     Initialise variables to pass to DLASQ3.                           
!                                                                       
      TTYPE = 0 
      DMIN1 = ZERO 
      DMIN2 = ZERO 
      DN    = ZERO 
      DN1   = ZERO 
      DN2   = ZERO 
      G     = ZERO 
      TAU   = ZERO 
!                                                                       
      ITER = 2 
      NFAIL = 0 
      NDIV = 2*( N0-I0 ) 
!                                                                       
      DO 160 IWHILA = 1, N + 1 
      IF( N0.LT.1 )                                                  &
&      GO TO 170                                                   
!                                                                       
!        While array unfinished do                                      
!                                                                       
!        E(N0) holds the value of SIGMA when submatrix in I0:N0         
!        splits from the rest of the array, but is negated.             
!                                                                       
      DESIG = ZERO 
      IF( N0.EQ.N ) THEN 
            SIGMA = ZERO 
      ELSE 
            SIGMA = -Z( 4*N0-1 ) 
      END IF 
      IF( SIGMA.LT.ZERO ) THEN 
            INFO = 1 
            RETURN 
      END IF 
!                                                                       
!        Find last unreduced submatrix's top index I0, find QMAX and    
!        EMIN. Find Gershgorin-type bound if Q's much greater than E's. 
!                                                                       
      EMAX = ZERO 
      IF( N0.GT.I0 ) THEN 
            EMIN = ABS( Z( 4*N0-5 ) ) 
      ELSE 
            EMIN = ZERO 
      END IF 
      QMIN = Z( 4*N0-3 ) 
      QMAX = QMIN 
      DO 90 I4 = 4*N0, 8, -4 
            IF( Z( I4-5 ).LE.ZERO )                                     &
&         GO TO 100                                                
            IF( QMIN.GE.FOUR*EMAX ) THEN 
            QMIN = MIN( QMIN, Z( I4-3 ) ) 
            EMAX = MAX( EMAX, Z( I4-5 ) ) 
            END IF 
            QMAX = MAX( QMAX, Z( I4-7 )+Z( I4-5 ) ) 
            EMIN = MIN( EMIN, Z( I4-5 ) ) 
90    CONTINUE 
      I4 = 4 
!                                                                       
100    CONTINUE 
      I0 = I4 / 4 
      PP = 0 
!                                                                       
      IF( N0-I0.GT.1 ) THEN 
            DEE = Z( 4*I0-3 ) 
            DEEMIN = DEE 
            KMIN = I0 
            DO 110 I4 = 4*I0+1, 4*N0-3, 4 
            DEE = Z( I4 )*( DEE /( DEE+Z( I4-2 ) ) ) 
            IF( DEE.LE.DEEMIN ) THEN 
                  DEEMIN = DEE 
                  KMIN = ( I4+3 )/4 
            END IF 
110       CONTINUE 
            IF( (KMIN-I0)*2.LT.N0-KMIN .AND.                            &
&         DEEMIN.LE.HALF*Z(4*N0-3) ) THEN                          
            IPN4 = 4*( I0+N0 ) 
            PP = 2 
            DO 120 I4 = 4*I0, 2*( I0+N0-1 ), 4 
                  TEMP = Z( I4-3 ) 
                  Z( I4-3 ) = Z( IPN4-I4-3 ) 
                  Z( IPN4-I4-3 ) = TEMP 
                  TEMP = Z( I4-2 ) 
                  Z( I4-2 ) = Z( IPN4-I4-2 ) 
                  Z( IPN4-I4-2 ) = TEMP 
                  TEMP = Z( I4-1 ) 
                  Z( I4-1 ) = Z( IPN4-I4-5 ) 
                  Z( IPN4-I4-5 ) = TEMP 
                  TEMP = Z( I4 ) 
                  Z( I4 ) = Z( IPN4-I4-4 ) 
                  Z( IPN4-I4-4 ) = TEMP 
120          CONTINUE 
            END IF 
      END IF 
!                                                                       
!        Put -(initial shift) into DMIN.                                
!                                                                       
      DMIN = -MAX( ZERO, QMIN-TWO*SQRT( QMIN )*SQRT( EMAX ) ) 
!                                                                       
!        Now I0:N0 is unreduced.                                        
!        PP = 0 for ping, PP = 1 for pong.                              
!        PP = 2 indicates that flipping was applied to the Z array and  
!               and that the tests for deflation upon entry in DLASQ3   
!               should not be performed.                                
!                                                                       
      NBIG = 100*( N0-I0+1 ) 
      DO 140 IWHILB = 1, NBIG 
            IF( I0.GT.N0 )                                              &
&         GO TO 150                                                
!                                                                       
!           While submatrix unfinished take a good dqds step.           
!                                                                       
            CALL DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,&
&                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,&
&                   DN2, G, TAU )                                  
!                                                                       
            PP = 1 - PP 
!                                                                       
!           When EMIN is very small check for splits.                   
!                                                                       
            IF( PP.EQ.0 .AND. N0-I0.GE.3 ) THEN 
            IF( Z( 4*N0 ).LE.TOL2*QMAX .OR.                          &
&             Z( 4*N0-1 ).LE.TOL2*SIGMA ) THEN                     
                  SPLT = I0 - 1 
                  QMAX = Z( 4*I0-3 ) 
                  EMIN = Z( 4*I0-1 ) 
                  OLDEMN = Z( 4*I0 ) 
                  DO 130 I4 = 4*I0, 4*( N0-3 ), 4 
                  IF( Z( I4 ).LE.TOL2*Z( I4-3 ) .OR.                 &
&                   Z( I4-1 ).LE.TOL2*SIGMA ) THEN                 
                        Z( I4-1 ) = -SIGMA 
                        SPLT = I4 / 4 
                        QMAX = ZERO 
                        EMIN = Z( I4+3 ) 
                        OLDEMN = Z( I4+4 ) 
                  ELSE 
                        QMAX = MAX( QMAX, Z( I4+1 ) ) 
                        EMIN = MIN( EMIN, Z( I4-1 ) ) 
                        OLDEMN = MIN( OLDEMN, Z( I4 ) ) 
                  END IF 
130             CONTINUE 
                  Z( 4*N0-1 ) = EMIN 
                  Z( 4*N0 ) = OLDEMN 
                  I0 = SPLT + 1 
            END IF 
            END IF 
!                                                                       
140    CONTINUE 
!                                                                       
      INFO = 2 
!                                                                       
!        Maximum number of iterations exceeded, restore the shift       
!        SIGMA and place the new d's and e's in a qd array.             
!        This might need to be done for several blocks                  
!                                                                       
      I1 = I0 
      N1 = N0 
145    CONTINUE 
      TEMPQ = Z( 4*I0-3 ) 
      Z( 4*I0-3 ) = Z( 4*I0-3 ) + SIGMA 
      DO K = I0+1, N0 
            TEMPE = Z( 4*K-5 ) 
            Z( 4*K-5 ) = Z( 4*K-5 ) * (TEMPQ / Z( 4*K-7 )) 
            TEMPQ = Z( 4*K-3 ) 
            Z( 4*K-3 ) = Z( 4*K-3 ) + SIGMA + TEMPE - Z( 4*K-5 ) 
      END DO 
!                                                                       
!        Prepare to do this on the previous block if there is one       
!                                                                       
      IF( I1.GT.1 ) THEN 
            N1 = I1-1 
            DO WHILE( ( I1.GE.2 ) .AND. ( Z(4*I1-5).GE.ZERO ) ) 
            I1 = I1 - 1 
            END DO 
            SIGMA = -Z(4*N1-1) 
            GO TO 145 
      END IF 
                                                                        
      DO K = 1, N 
            Z( 2*K-1 ) = Z( 4*K-3 ) 
!                                                                       
!        Only the block 1..N0 is unfinished.  The rest of the e's       
!        must be essentially zero, although sometimes other data        
!        has been stored in them.                                       
!                                                                       
            IF( K.LT.N0 ) THEN 
            Z( 2*K ) = Z( 4*K-1 ) 
            ELSE 
            Z( 2*K ) = 0 
            END IF 
      END DO 
      RETURN 
!                                                                       
!        end IWHILB                                                     
!                                                                       
150    CONTINUE 
!                                                                       
160 END DO 
!                                                                       
      INFO = 3 
      RETURN 
!                                                                       
!     end IWHILA                                                        
!                                                                       
170 CONTINUE 
!                                                                       
!     Move q's to the front.                                            
!                                                                       
      DO 180 K = 2, N 
      Z( K ) = Z( 4*K-3 ) 
180 END DO 
!                                                                       
!     Sort and compute sum of eigenvalues.                              
!                                                                       
      CALL DLASRT( 'D', N, Z, IINFO ) 
!                                                                       
      E = ZERO 
      DO 190 K = N, 1, -1 
      E = E + Z( K ) 
190 END DO 
!                                                                       
!     Store trace, sum(eigenvalues) and information on performance.     
!                                                                       
      Z( 2*N+1 ) = TRACE 
      Z( 2*N+2 ) = E 
      Z( 2*N+3 ) = DBLE( ITER ) 
      Z( 2*N+4 ) = DBLE( NDIV ) / DBLE( N**2 ) 
      Z( 2*N+5 ) = HUNDRD*NFAIL / DBLE( ITER ) 
      RETURN 
!                                                                       
!     End of DLASQ2                                                     
!                                                                       
      END                                           
!> \brief \b DLASQ3 checks for deflation, computes a shift and calls dqd
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASQ3 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAI
!                          ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN
!                          DN2, G, TAU )                                
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            IEEE                                         
!       INTEGER            I0, ITER, N0, NDIV, NFAIL, PP                
!       DOUBLE PRECISION   DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, G,  
!      $                   QMAX, SIGMA, TAU                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.  
!> In case of failure it changes shifts, and tries again until output   
!> is positive.                                                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>         First index.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] N0                                                    
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>         Last index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Z                                                     
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension ( 4*N0 )             
!>         Z holds the qd array.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] PP                                                    
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>         PP=0 for ping, PP=1 for pong.                                
!>         PP=2 indicates that flipping was applied to the Z array      
!>         and that the initial tests for deflation should not be       
!>         performed.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is DOUBLE PRECISION                                    
!>         Minimum value of d.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] SIGMA                                                    
!> \verbatim                                                            
!>          SIGMA is DOUBLE PRECISION                                   
!>         Sum of shifts used in current segment.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DESIG                                                 
!> \verbatim                                                            
!>          DESIG is DOUBLE PRECISION                                   
!>         Lower order part of SIGMA                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] QMAX                                                      
!> \verbatim                                                            
!>          QMAX is DOUBLE PRECISION                                    
!>         Maximum value of q.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NFAIL                                                 
!> \verbatim                                                            
!>          NFAIL is INTEGER                                            
!>         Increment NFAIL by 1 each time the shift was too big.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] ITER                                                  
!> \verbatim                                                            
!>          ITER is INTEGER                                             
!>         Increment ITER by 1 for each iteration.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] NDIV                                                  
!> \verbatim                                                            
!>          NDIV is INTEGER                                             
!>         Increment NDIV by 1 for each division.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IEEE                                                      
!> \verbatim                                                            
!>          IEEE is LOGICAL                                             
!>         Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TTYPE                                                 
!> \verbatim                                                            
!>          TTYPE is INTEGER                                            
!>         Shift type.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DMIN1                                                 
!> \verbatim                                                            
!>          DMIN1 is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DMIN2                                                 
!> \verbatim                                                            
!>          DMIN2 is DOUBLE PRECISION                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN                                                    
!> \verbatim                                                            
!>          DN is DOUBLE PRECISION                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN1                                                   
!> \verbatim                                                            
!>          DN1 is DOUBLE PRECISION                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DN2                                                   
!> \verbatim                                                            
!>          DN2 is DOUBLE PRECISION                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] G                                                     
!> \verbatim                                                            
!>          G is DOUBLE PRECISION                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TAU                                                   
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION                                     
!>                                                                      
!>         These are passed as arguments in order to save their values  
!>         between calls to DLASQ3.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,&
&                   ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,&
&                   DN2, G, TAU )                                  
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE 
      INTEGER            I0, ITER, N0, NDIV, NFAIL, PP 
      DOUBLE PRECISION   DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, G,    &
&                   QMAX, SIGMA, TAU                               
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   CBIAS 
      PARAMETER          ( CBIAS = 1.50D0 ) 
      DOUBLE PRECISION   ZERO, QURTR, HALF, ONE, TWO, HUNDRD 
      PARAMETER          ( ZERO = 0.0D0, QURTR = 0.250D0, HALF = 0.5D0, &
&                     ONE = 1.0D0, TWO = 2.0D0, HUNDRD = 100.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IPN4, J4, N0IN, NN, TTYPE 
      DOUBLE PRECISION   EPS, S, T, TEMP, TOL, TOL2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLASQ4, DLASQ5, DLASQ6 
!     ..                                                                
!     .. External Function ..                                           
      DOUBLE PRECISION   DLAMCH 
      LOGICAL            DISNAN 
      EXTERNAL           DISNAN, DLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      N0IN = N0 
      EPS = DLAMCH( 'Precision' ) 
      TOL = EPS*HUNDRD 
      TOL2 = TOL**2 
!                                                                       
!     Check for deflation.                                              
!                                                                       
10 CONTINUE 
!                                                                       
      IF( N0.LT.I0 )                                                    &
&   RETURN                                                         
      IF( N0.EQ.I0 )                                                    &
&   GO TO 20                                                       
      NN = 4*N0 + PP 
      IF( N0.EQ.( I0+1 ) )                                              &
&   GO TO 40                                                       
!                                                                       
!     Check whether E(N0-1) is negligible, 1 eigenvalue.                
!                                                                       
      IF( Z( NN-5 ).GT.TOL2*( SIGMA+Z( NN-3 ) ) .AND.                   &
&    Z( NN-2*PP-4 ).GT.TOL2*Z( NN-7 ) )                            &
&   GO TO 30                                                       
!                                                                       
20 CONTINUE 
!                                                                       
      Z( 4*N0-3 ) = Z( 4*N0+PP-3 ) + SIGMA 
      N0 = N0 - 1 
      GO TO 10 
!                                                                       
!     Check  whether E(N0-2) is negligible, 2 eigenvalues.              
!                                                                       
30 CONTINUE 
!                                                                       
      IF( Z( NN-9 ).GT.TOL2*SIGMA .AND.                                 &
&    Z( NN-2*PP-8 ).GT.TOL2*Z( NN-11 ) )                           &
&   GO TO 50                                                       
!                                                                       
40 CONTINUE 
!                                                                       
      IF( Z( NN-3 ).GT.Z( NN-7 ) ) THEN 
      S = Z( NN-3 ) 
      Z( NN-3 ) = Z( NN-7 ) 
      Z( NN-7 ) = S 
      END IF 
      T = HALF*( ( Z( NN-7 )-Z( NN-3 ) )+Z( NN-5 ) ) 
      IF( Z( NN-5 ).GT.Z( NN-3 )*TOL2.AND.T.NE.ZERO ) THEN 
      S = Z( NN-3 )*( Z( NN-5 ) / T ) 
      IF( S.LE.T ) THEN 
            S = Z( NN-3 )*( Z( NN-5 ) /                                 &
&          ( T*( ONE+SQRT( ONE+S / T ) ) ) )                       
      ELSE 
            S = Z( NN-3 )*( Z( NN-5 ) / ( T+SQRT( T )*SQRT( T+S ) ) ) 
      END IF 
      T = Z( NN-7 ) + ( S+Z( NN-5 ) ) 
      Z( NN-3 ) = Z( NN-3 )*( Z( NN-7 ) / T ) 
      Z( NN-7 ) = T 
      END IF 
      Z( 4*N0-7 ) = Z( NN-7 ) + SIGMA 
      Z( 4*N0-3 ) = Z( NN-3 ) + SIGMA 
      N0 = N0 - 2 
      GO TO 10 
!                                                                       
50 CONTINUE 
      IF( PP.EQ.2 )                                                     &
&   PP = 0                                                         
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( DMIN.LE.ZERO .OR. N0.LT.N0IN ) THEN 
      IF( CBIAS*Z( 4*I0+PP-3 ).LT.Z( 4*N0+PP-3 ) ) THEN 
            IPN4 = 4*( I0+N0 ) 
            DO 60 J4 = 4*I0, 2*( I0+N0-1 ), 4 
            TEMP = Z( J4-3 ) 
            Z( J4-3 ) = Z( IPN4-J4-3 ) 
            Z( IPN4-J4-3 ) = TEMP 
            TEMP = Z( J4-2 ) 
            Z( J4-2 ) = Z( IPN4-J4-2 ) 
            Z( IPN4-J4-2 ) = TEMP 
            TEMP = Z( J4-1 ) 
            Z( J4-1 ) = Z( IPN4-J4-5 ) 
            Z( IPN4-J4-5 ) = TEMP 
            TEMP = Z( J4 ) 
            Z( J4 ) = Z( IPN4-J4-4 ) 
            Z( IPN4-J4-4 ) = TEMP 
60       CONTINUE 
            IF( N0-I0.LE.4 ) THEN 
            Z( 4*N0+PP-1 ) = Z( 4*I0+PP-1 ) 
            Z( 4*N0-PP ) = Z( 4*I0-PP ) 
            END IF 
            DMIN2 = MIN( DMIN2, Z( 4*N0+PP-1 ) ) 
            Z( 4*N0+PP-1 ) = MIN( Z( 4*N0+PP-1 ), Z( 4*I0+PP-1 ),       &
&                            Z( 4*I0+PP+3 ) )                      
            Z( 4*N0-PP ) = MIN( Z( 4*N0-PP ), Z( 4*I0-PP ),             &
&                          Z( 4*I0-PP+4 ) )                        
            QMAX = MAX( QMAX, Z( 4*I0+PP-3 ), Z( 4*I0+PP+1 ) ) 
            DMIN = -ZERO 
      END IF 
      END IF 
!                                                                       
!     Choose a shift.                                                   
!                                                                       
      CALL DLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1,    &
&             DN2, TAU, TTYPE, G )                                 
!                                                                       
!     Call dqds until DMIN > 0.                                         
!                                                                       
70 CONTINUE 
!                                                                       
      CALL DLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN,   &
&             DN1, DN2, IEEE, EPS )                                
!                                                                       
      NDIV = NDIV + ( N0-I0+2 ) 
      ITER = ITER + 1 
!                                                                       
!     Check status.                                                     
!                                                                       
      IF( DMIN.GE.ZERO .AND. DMIN1.GE.ZERO ) THEN 
!                                                                       
!        Success.                                                       
!                                                                       
      GO TO 90 
!                                                                       
      ELSE IF( DMIN.LT.ZERO .AND. DMIN1.GT.ZERO .AND.                   &
&         Z( 4*( N0-1 )-PP ).LT.TOL*( SIGMA+DN1 ) .AND.            &
&         ABS( DN ).LT.TOL*SIGMA ) THEN                            
!                                                                       
!        Convergence hidden by negative DN.                             
!                                                                       
      Z( 4*( N0-1 )-PP+2 ) = ZERO 
      DMIN = ZERO 
      GO TO 90 
      ELSE IF( DMIN.LT.ZERO ) THEN 
!                                                                       
!        TAU too big. Select new TAU and try again.                     
!                                                                       
      NFAIL = NFAIL + 1 
      IF( TTYPE.LT.-22 ) THEN 
!                                                                       
!           Failed twice. Play it safe.                                 
!                                                                       
            TAU = ZERO 
      ELSE IF( DMIN1.GT.ZERO ) THEN 
!                                                                       
!           Late failure. Gives excellent shift.                        
!                                                                       
            TAU = ( TAU+DMIN )*( ONE-TWO*EPS ) 
            TTYPE = TTYPE - 11 
      ELSE 
!                                                                       
!           Early failure. Divide by 4.                                 
!                                                                       
            TAU = QURTR*TAU 
            TTYPE = TTYPE - 12 
      END IF 
      GO TO 70 
      ELSE IF( DISNAN( DMIN ) ) THEN 
!                                                                       
!        NaN.                                                           
!                                                                       
      IF( TAU.EQ.ZERO ) THEN 
            GO TO 80 
      ELSE 
            TAU = ZERO 
            GO TO 70 
      END IF 
      ELSE 
!                                                                       
!        Possible underflow. Play it safe.                              
!                                                                       
      GO TO 80 
      END IF 
!                                                                       
!     Risk of underflow.                                                
!                                                                       
80 CONTINUE 
      CALL DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DN1, DN2 ) 
      NDIV = NDIV + ( N0-I0+2 ) 
      ITER = ITER + 1 
      TAU = ZERO 
!                                                                       
90 CONTINUE 
      IF( TAU.LT.SIGMA ) THEN 
      DESIG = DESIG + TAU 
      T = SIGMA + DESIG 
      DESIG = DESIG - ( T-SIGMA ) 
      ELSE 
      T = SIGMA + TAU 
      DESIG = SIGMA - ( T-TAU ) + DESIG 
      END IF 
      SIGMA = T 
!                                                                       
      RETURN 
!                                                                       
!     End of DLASQ3                                                     
!                                                                       
      END                                           
!> \brief \b DLASQ4 computes an approximation to the smallest eigenvalue
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASQ4 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, 
!                          DN1, DN2, TAU, TTYPE, G )                    
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            I0, N0, N0IN, PP, TTYPE                      
!       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU     
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASQ4 computes an approximation TAU to the smallest eigenvalue      
!> using values of d from the previous transform.                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension ( 4*N0 )             
!>        Z holds the qd array.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0IN                                                      
!> \verbatim                                                            
!>          N0IN is INTEGER                                             
!>        The value of N0 at start of EIGTEST.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN                                                      
!> \verbatim                                                            
!>          DMIN is DOUBLE PRECISION                                    
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN1                                                     
!> \verbatim                                                            
!>          DMIN1 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DMIN2                                                     
!> \verbatim                                                            
!>          DMIN2 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN                                                        
!> \verbatim                                                            
!>          DN is DOUBLE PRECISION                                      
!>        d(N)                                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN1                                                       
!> \verbatim                                                            
!>          DN1 is DOUBLE PRECISION                                     
!>        d(N-1)                                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DN2                                                       
!> \verbatim                                                            
!>          DN2 is DOUBLE PRECISION                                     
!>        d(N-2)                                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION                                     
!>        This is the shift.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TTYPE                                                    
!> \verbatim                                                            
!>          TTYPE is INTEGER                                            
!>        Shift type.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] G                                                     
!> \verbatim                                                            
!>          G is DOUBLE PRECISION                                       
!>        G is passed as an argument in order to save its value between 
!>        calls to DLASQ4.                                              
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  CNST1 = 9/16                                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN,   &
&                   DN1, DN2, TAU, TTYPE, G )                      
!                                                                       
!  -- LAPACK computational routine (version 3.7.1) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, N0IN, PP, TTYPE 
      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   CNST1, CNST2, CNST3 
      PARAMETER          ( CNST1 = 0.5630D0, CNST2 = 1.010D0,           &
&                   CNST3 = 1.050D0 )                              
      DOUBLE PRECISION   QURTR, THIRD, HALF, ZERO, ONE, TWO, HUNDRD 
      PARAMETER          ( QURTR = 0.250D0, THIRD = 0.3330D0,           &
&                   HALF = 0.50D0, ZERO = 0.0D0, ONE = 1.0D0,      &
&                   TWO = 2.0D0, HUNDRD = 100.0D0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I4, NN, NP 
      DOUBLE PRECISION   A2, B1, B2, GAM, GAP1, GAP2, S 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     A negative DMIN forces the shift to take that absolute value      
!     TTYPE records the type of shift.                                  
!                                                                       
      IF( DMIN.LE.ZERO ) THEN 
      TAU = -DMIN 
      TTYPE = -1 
      RETURN 
      END IF 
!                                                                       
      NN = 4*N0 + PP 
      IF( N0IN.EQ.N0 ) THEN 
!                                                                       
!        No eigenvalues deflated.                                       
!                                                                       
      IF( DMIN.EQ.DN .OR. DMIN.EQ.DN1 ) THEN 
!                                                                       
            B1 = SQRT( Z( NN-3 ) )*SQRT( Z( NN-5 ) ) 
            B2 = SQRT( Z( NN-7 ) )*SQRT( Z( NN-9 ) ) 
            A2 = Z( NN-7 ) + Z( NN-5 ) 
!                                                                       
!           Cases 2 and 3.                                              
!                                                                       
            IF( DMIN.EQ.DN .AND. DMIN1.EQ.DN1 ) THEN 
            GAP2 = DMIN2 - A2 - DMIN2*QURTR 
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2 ) THEN 
                  GAP1 = A2 - DN - ( B2 / GAP2 )*B2 
            ELSE 
                  GAP1 = A2 - DN - ( B1+B2 ) 
            END IF 
            IF( GAP1.GT.ZERO .AND. GAP1.GT.B1 ) THEN 
                  S = MAX( DN-( B1 / GAP1 )*B1, HALF*DMIN ) 
                  TTYPE = -2 
            ELSE 
                  S = ZERO 
                  IF( DN.GT.B1 )                                        &
&               S = DN - B1                                        
                  IF( A2.GT.( B1+B2 ) )                                 &
&               S = MIN( S, A2-( B1+B2 ) )                         
                  S = MAX( S, THIRD*DMIN ) 
                  TTYPE = -3 
            END IF 
            ELSE 
!                                                                       
!              Case 4.                                                  
!                                                                       
            TTYPE = -4 
            S = QURTR*DMIN 
            IF( DMIN.EQ.DN ) THEN 
                  GAM = DN 
                  A2 = ZERO 
                  IF( Z( NN-5 ) .GT. Z( NN-7 ) )                        &
&               RETURN                                             
                  B2 = Z( NN-5 ) / Z( NN-7 ) 
                  NP = NN - 9 
            ELSE 
                  NP = NN - 2*PP 
                  GAM = DN1 
                  IF( Z( NP-4 ) .GT. Z( NP-2 ) )                        &
&               RETURN                                             
                  A2 = Z( NP-4 ) / Z( NP-2 ) 
                  IF( Z( NN-9 ) .GT. Z( NN-11 ) )                       &
&               RETURN                                             
                  B2 = Z( NN-9 ) / Z( NN-11 ) 
                  NP = NN - 13 
            END IF 
!                                                                       
!              Approximate contribution to norm squared from I < NN-1.  
!                                                                       
            A2 = A2 + B2 
            DO 10 I4 = NP, 4*I0 - 1 + PP, -4 
                  IF( B2.EQ.ZERO )                                      &
&               GO TO 20                                           
                  B1 = B2 
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                          &
&               RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) ) 
                  A2 = A2 + B2 
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )     &
&               GO TO 20                                           
10          CONTINUE 
20          CONTINUE 
            A2 = CNST3*A2 
!                                                                       
!              Rayleigh quotient residual bound.                        
!                                                                       
            IF( A2.LT.CNST1 )                                        &
&            S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )               
            END IF 
      ELSE IF( DMIN.EQ.DN2 ) THEN 
!                                                                       
!           Case 5.                                                     
!                                                                       
            TTYPE = -5 
            S = QURTR*DMIN 
!                                                                       
!           Compute contribution to norm squared from I > NN-2.         
!                                                                       
            NP = NN - 2*PP 
            B1 = Z( NP-2 ) 
            B2 = Z( NP-6 ) 
            GAM = DN2 
            IF( Z( NP-8 ).GT.B2 .OR. Z( NP-4 ).GT.B1 )                  &
&         RETURN                                                   
            A2 = ( Z( NP-8 ) / B2 )*( ONE+Z( NP-4 ) / B1 ) 
!                                                                       
!           Approximate contribution to norm squared from I < NN-2.     
!                                                                       
            IF( N0-I0.GT.2 ) THEN 
            B2 = Z( NN-13 ) / Z( NN-15 ) 
            A2 = A2 + B2 
            DO 30 I4 = NN - 17, 4*I0 - 1 + PP, -4 
                  IF( B2.EQ.ZERO )                                      &
&               GO TO 40                                           
                  B1 = B2 
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                          &
&               RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) ) 
                  A2 = A2 + B2 
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )     &
&               GO TO 40                                           
30          CONTINUE 
40          CONTINUE 
            A2 = CNST3*A2 
            END IF 
!                                                                       
            IF( A2.LT.CNST1 )                                           &
&         S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )                  
      ELSE 
!                                                                       
!           Case 6, no information to guide us.                         
!                                                                       
            IF( TTYPE.EQ.-6 ) THEN 
            G = G + THIRD*( ONE-G ) 
            ELSE IF( TTYPE.EQ.-18 ) THEN 
            G = QURTR*THIRD 
            ELSE 
            G = QURTR 
            END IF 
            S = G*DMIN 
            TTYPE = -6 
      END IF 
!                                                                       
      ELSE IF( N0IN.EQ.( N0+1 ) ) THEN 
!                                                                       
!        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.  
!                                                                       
      IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN 
!                                                                       
!           Cases 7 and 8.                                              
!                                                                       
            TTYPE = -7 
            S = THIRD*DMIN1 
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                &
&         RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 ) 
            B2 = B1 
            IF( B2.EQ.ZERO )                                            &
&         GO TO 60                                                 
            DO 50 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4 
            A2 = B1 
            IF( Z( I4 ).GT.Z( I4-2 ) )                               &
&            RETURN                                                
            B1 = B1*( Z( I4 ) / Z( I4-2 ) ) 
            B2 = B2 + B1 
            IF( HUNDRD*MAX( B1, A2 ).LT.B2 )                         &
&            GO TO 60                                              
50       CONTINUE 
60       CONTINUE 
            B2 = SQRT( CNST3*B2 ) 
            A2 = DMIN1 / ( ONE+B2**2 ) 
            GAP2 = HALF*DMIN2 - A2 
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN 
            S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) ) 
            ELSE 
            S = MAX( S, A2*( ONE-CNST2*B2 ) ) 
            TTYPE = -8 
            END IF 
      ELSE 
!                                                                       
!           Case 9.                                                     
!                                                                       
            S = QURTR*DMIN1 
            IF( DMIN1.EQ.DN1 )                                          &
&         S = HALF*DMIN1                                           
            TTYPE = -9 
      END IF 
!                                                                       
      ELSE IF( N0IN.EQ.( N0+2 ) ) THEN 
!                                                                       
!        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.      
!                                                                       
!        Cases 10 and 11.                                               
!                                                                       
      IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN 
            TTYPE = -10 
            S = THIRD*DMIN2 
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                &
&         RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 ) 
            B2 = B1 
            IF( B2.EQ.ZERO )                                            &
&         GO TO 80                                                 
            DO 70 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4 
            IF( Z( I4 ).GT.Z( I4-2 ) )                               &
&            RETURN                                                
            B1 = B1*( Z( I4 ) / Z( I4-2 ) ) 
            B2 = B2 + B1 
            IF( HUNDRD*B1.LT.B2 )                                    &
&            GO TO 80                                              
70       CONTINUE 
80       CONTINUE 
            B2 = SQRT( CNST3*B2 ) 
            A2 = DMIN2 / ( ONE+B2**2 ) 
            GAP2 = Z( NN-7 ) + Z( NN-9 ) -                              &
&             SQRT( Z( NN-11 ) )*SQRT( Z( NN-9 ) ) - A2            
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN 
            S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) ) 
            ELSE 
            S = MAX( S, A2*( ONE-CNST2*B2 ) ) 
            END IF 
      ELSE 
            S = QURTR*DMIN2 
            TTYPE = -11 
      END IF 
      ELSE IF( N0IN.GT.( N0+2 ) ) THEN 
!                                                                       
!        Case 12, more than two eigenvalues deflated. No information.   
!                                                                       
      S = ZERO 
      TTYPE = -12 
      END IF 
!                                                                       
      TAU = S 
      RETURN 
!                                                                       
!     End of DLASQ4                                                     
!                                                                       
      END                                           
!> \brief \b DLASQ5 computes one dqds transform in ping-pong form. Used 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASQ5 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2
!                          DNM1, DNM2, IEEE, EPS )                      
!                                                                       
!       .. Scalar Arguments ..                                          
!       LOGICAL            IEEE                                         
!       INTEGER            I0, N0, PP                                   
!       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU, SIGM
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASQ5 computes one dqds transform in ping-pong form, one            
!> version for IEEE machines another for non IEEE machines.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension ( 4*N )              
!>        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid      
!>        an extra argument.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION                                     
!>        This is the shift.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] SIGMA                                                     
!> \verbatim                                                            
!>          SIGMA is DOUBLE PRECISION                                   
!>        This is the accumulated shift up to this step.                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is DOUBLE PRECISION                                    
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN1                                                    
!> \verbatim                                                            
!>          DMIN1 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN2                                                    
!> \verbatim                                                            
!>          DMIN2 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DN                                                       
!> \verbatim                                                            
!>          DN is DOUBLE PRECISION                                      
!>        d(N0), the last value of d.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM1                                                     
!> \verbatim                                                            
!>          DNM1 is DOUBLE PRECISION                                    
!>        d(N0-1).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM2                                                     
!> \verbatim                                                            
!>          DNM2 is DOUBLE PRECISION                                    
!>        d(N0-2).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IEEE                                                      
!> \verbatim                                                            
!>          IEEE is LOGICAL                                             
!>        Flag for IEEE or non IEEE arithmetic.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] EPS                                                       
!> \verbatim                                                            
!>          EPS is DOUBLE PRECISION                                     
!>        This is the value of epsilon used.                            
!> \endverbatim                                                         
!>                                                                      
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, &
&                   DN, DNM1, DNM2, IEEE, EPS )                    
!                                                                       
!  -- LAPACK computational routine (version 3.7.1) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE 
      INTEGER            I0, N0, PP 
      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU,       &
&                   SIGMA, EPS                                     
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      DOUBLE PRECISION   ZERO, HALF 
      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2 
      DOUBLE PRECISION   D, EMIN, TEMP, DTHRESH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                            &
&   RETURN                                                         
!                                                                       
      DTHRESH = EPS*(SIGMA+TAU) 
      IF( TAU.LT.DTHRESH*HALF ) TAU = ZERO 
      IF( TAU.NE.ZERO ) THEN 
      J4 = 4*I0 + PP - 3 
      EMIN = Z( J4+4 ) 
      D = Z( J4 ) - TAU 
      DMIN = D 
      DMIN1 = -Z( J4 ) 
!                                                                       
      IF( IEEE ) THEN 
!                                                                       
!        Code for IEEE arithmetic.                                      
!                                                                       
      IF( PP.EQ.0 ) THEN 
            DO 10 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-2 ) = D + Z( J4-1 ) 
            TEMP = Z( J4+1 ) / Z( J4-2 ) 
            D = D*TEMP - TAU 
            DMIN = MIN( DMIN, D ) 
            Z( J4 ) = Z( J4-1 )*TEMP 
            EMIN = MIN( Z( J4 ), EMIN ) 
10       CONTINUE 
      ELSE 
            DO 20 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-3 ) = D + Z( J4 ) 
            TEMP = Z( J4+2 ) / Z( J4-3 ) 
            D = D*TEMP - TAU 
            DMIN = MIN( DMIN, D ) 
            Z( J4-1 ) = Z( J4 )*TEMP 
            EMIN = MIN( Z( J4-1 ), EMIN ) 
20       CONTINUE 
      END IF 
!                                                                       
!        Unroll last two steps.                                         
!                                                                       
      DNM2 = D 
      DMIN2 = DMIN 
      J4 = 4*( N0-2 ) - PP 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM2 + Z( J4P2 ) 
      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
      DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
      DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
      DMIN1 = DMIN 
      J4 = J4 + 4 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM1 + Z( J4P2 ) 
      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
      DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
      DMIN = MIN( DMIN, DN ) 
!                                                                       
      ELSE 
!                                                                       
!        Code for non IEEE arithmetic.                                  
!                                                                       
      IF( PP.EQ.0 ) THEN 
            DO 30 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-2 ) = D + Z( J4-1 ) 
            IF( D.LT.ZERO ) THEN 
                  RETURN 
            ELSE 
                  Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
                  D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4 ) ) 
30       CONTINUE 
      ELSE 
            DO 40 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-3 ) = D + Z( J4 ) 
            IF( D.LT.ZERO ) THEN 
                  RETURN 
            ELSE 
                  Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
                  D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4-1 ) ) 
40       CONTINUE 
      END IF 
!                                                                       
!        Unroll last two steps.                                         
!                                                                       
      DNM2 = D 
      DMIN2 = DMIN 
      J4 = 4*( N0-2 ) - PP 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM2 + Z( J4P2 ) 
      IF( DNM2.LT.ZERO ) THEN 
            RETURN 
      ELSE 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
      END IF 
      DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
      DMIN1 = DMIN 
      J4 = J4 + 4 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM1 + Z( J4P2 ) 
      IF( DNM1.LT.ZERO ) THEN 
            RETURN 
      ELSE 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
      END IF 
      DMIN = MIN( DMIN, DN ) 
!                                                                       
      END IF 
      ELSE 
!     This is the version that sets d's to zero if they are small enough
      J4 = 4*I0 + PP - 3 
      EMIN = Z( J4+4 ) 
      D = Z( J4 ) - TAU 
      DMIN = D 
      DMIN1 = -Z( J4 ) 
      IF( IEEE ) THEN 
!                                                                       
!     Code for IEEE arithmetic.                                         
!                                                                       
            IF( PP.EQ.0 ) THEN 
            DO 50 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  TEMP = Z( J4+1 ) / Z( J4-2 ) 
                  D = D*TEMP - TAU 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4 ) = Z( J4-1 )*TEMP 
                  EMIN = MIN( Z( J4 ), EMIN ) 
50          CONTINUE 
            ELSE 
            DO 60 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  TEMP = Z( J4+2 ) / Z( J4-3 ) 
                  D = D*TEMP - TAU 
                  IF( D.LT.DTHRESH ) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  Z( J4-1 ) = Z( J4 )*TEMP 
                  EMIN = MIN( Z( J4-1 ), EMIN ) 
60          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
      ELSE 
!                                                                       
!     Code for non IEEE arithmetic.                                     
!                                                                       
            IF( PP.EQ.0 ) THEN 
            DO 70 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-2 ) = D + Z( J4-1 ) 
                  IF( D.LT.ZERO ) THEN 
                  RETURN 
                  ELSE 
                  Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
                  D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU 
                  END IF 
                  IF( D.LT.DTHRESH) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4 ) ) 
70          CONTINUE 
            ELSE 
            DO 80 J4 = 4*I0, 4*( N0-3 ), 4 
                  Z( J4-3 ) = D + Z( J4 ) 
                  IF( D.LT.ZERO ) THEN 
                  RETURN 
                  ELSE 
                  Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
                  D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU 
                  END IF 
                  IF( D.LT.DTHRESH) D = ZERO 
                  DMIN = MIN( DMIN, D ) 
                  EMIN = MIN( EMIN, Z( J4-1 ) ) 
80          CONTINUE 
            END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
            DNM2 = D 
            DMIN2 = DMIN 
            J4 = 4*( N0-2 ) - PP 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM2 + Z( J4P2 ) 
            IF( DNM2.LT.ZERO ) THEN 
            RETURN 
            ELSE 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
            DMIN1 = DMIN 
            J4 = J4 + 4 
            J4P2 = J4 + 2*PP - 1 
            Z( J4-2 ) = DNM1 + Z( J4P2 ) 
            IF( DNM1.LT.ZERO ) THEN 
            RETURN 
            ELSE 
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU 
            END IF 
            DMIN = MIN( DMIN, DN ) 
!                                                                       
      END IF 
      END IF 
!                                                                       
      Z( J4+2 ) = DN 
      Z( 4*N0-PP ) = EMIN 
      RETURN 
!                                                                       
!     End of DLASQ5                                                     
!                                                                       
      END                                           
!> \brief \b DLASQ6 computes one dqd transform in ping-pong form. Used b
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASQ6 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,       
!                          DNM1, DNM2 )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            I0, N0, PP                                   
!       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2           
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   Z( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASQ6 computes one dqd (shift equal to zero) transform in           
!> ping-pong form, with protection against underflow and overflow.      
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] I0                                                        
!> \verbatim                                                            
!>          I0 is INTEGER                                               
!>        First index.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N0                                                        
!> \verbatim                                                            
!>          N0 is INTEGER                                               
!>        Last index.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Z                                                         
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension ( 4*N )              
!>        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid      
!>        an extra argument.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] PP                                                        
!> \verbatim                                                            
!>          PP is INTEGER                                               
!>        PP=0 for ping, PP=1 for pong.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN                                                     
!> \verbatim                                                            
!>          DMIN is DOUBLE PRECISION                                    
!>        Minimum value of d.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN1                                                    
!> \verbatim                                                            
!>          DMIN1 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ).                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DMIN2                                                    
!> \verbatim                                                            
!>          DMIN2 is DOUBLE PRECISION                                   
!>        Minimum value of d, excluding D( N0 ) and D( N0-1 ).          
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DN                                                       
!> \verbatim                                                            
!>          DN is DOUBLE PRECISION                                      
!>        d(N0), the last value of d.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM1                                                     
!> \verbatim                                                            
!>          DNM1 is DOUBLE PRECISION                                    
!>        d(N0-1).                                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] DNM2                                                     
!> \verbatim                                                            
!>          DNM2 is DOUBLE PRECISION                                    
!>        d(N0-2).                                                      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,         &
&                   DNM1, DNM2 )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, PP 
      DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   Z( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2 
      DOUBLE PRECISION   D, EMIN, SAFMIN, TEMP 
!     ..                                                                
!     .. External Function ..                                           
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           DLAMCH 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                            &
&   RETURN                                                         
!                                                                       
      SAFMIN = DLAMCH( 'Safe minimum' ) 
      J4 = 4*I0 + PP - 3 
      EMIN = Z( J4+4 ) 
      D = Z( J4 ) 
      DMIN = D 
!                                                                       
      IF( PP.EQ.0 ) THEN 
      DO 10 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-2 ) = D + Z( J4-1 ) 
            IF( Z( J4-2 ).EQ.ZERO ) THEN 
            Z( J4 ) = ZERO 
            D = Z( J4+1 ) 
            DMIN = D 
            EMIN = ZERO 
            ELSE IF( SAFMIN*Z( J4+1 ).LT.Z( J4-2 ) .AND.                &
&               SAFMIN*Z( J4-2 ).LT.Z( J4+1 ) ) THEN               
            TEMP = Z( J4+1 ) / Z( J4-2 ) 
            Z( J4 ) = Z( J4-1 )*TEMP 
            D = D*TEMP 
            ELSE 
            Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) ) 
            D = Z( J4+1 )*( D / Z( J4-2 ) ) 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4 ) ) 
10    CONTINUE 
      ELSE 
      DO 20 J4 = 4*I0, 4*( N0-3 ), 4 
            Z( J4-3 ) = D + Z( J4 ) 
            IF( Z( J4-3 ).EQ.ZERO ) THEN 
            Z( J4-1 ) = ZERO 
            D = Z( J4+2 ) 
            DMIN = D 
            EMIN = ZERO 
            ELSE IF( SAFMIN*Z( J4+2 ).LT.Z( J4-3 ) .AND.                &
&               SAFMIN*Z( J4-3 ).LT.Z( J4+2 ) ) THEN               
            TEMP = Z( J4+2 ) / Z( J4-3 ) 
            Z( J4-1 ) = Z( J4 )*TEMP 
            D = D*TEMP 
            ELSE 
            Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) ) 
            D = Z( J4+2 )*( D / Z( J4-3 ) ) 
            END IF 
            DMIN = MIN( DMIN, D ) 
            EMIN = MIN( EMIN, Z( J4-1 ) ) 
20    CONTINUE 
      END IF 
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
      DNM2 = D 
      DMIN2 = DMIN 
      J4 = 4*( N0-2 ) - PP 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM2 + Z( J4P2 ) 
      IF( Z( J4-2 ).EQ.ZERO ) THEN 
      Z( J4 ) = ZERO 
      DNM1 = Z( J4P2+2 ) 
      DMIN = DNM1 
      EMIN = ZERO 
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                    &
&         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
      TEMP = Z( J4P2+2 ) / Z( J4-2 ) 
      Z( J4 ) = Z( J4P2 )*TEMP 
      DNM1 = DNM2*TEMP 
      ELSE 
      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
      DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) 
      END IF 
      DMIN = MIN( DMIN, DNM1 ) 
!                                                                       
      DMIN1 = DMIN 
      J4 = J4 + 4 
      J4P2 = J4 + 2*PP - 1 
      Z( J4-2 ) = DNM1 + Z( J4P2 ) 
      IF( Z( J4-2 ).EQ.ZERO ) THEN 
      Z( J4 ) = ZERO 
      DN = Z( J4P2+2 ) 
      DMIN = DN 
      EMIN = ZERO 
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                    &
&         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
      TEMP = Z( J4P2+2 ) / Z( J4-2 ) 
      Z( J4 ) = Z( J4P2 )*TEMP 
      DN = DNM1*TEMP 
      ELSE 
      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) ) 
      DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) 
      END IF 
      DMIN = MIN( DMIN, DN ) 
!                                                                       
      Z( J4+2 ) = DN 
      Z( 4*N0-PP ) = EMIN 
      RETURN 
!                                                                       
!     End of DLASQ6                                                     
!                                                                       
      END                                           
!> \brief \b DLASRT sorts numbers in increasing or decreasing order.    
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASRT + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASRT( ID, N, D, INFO )                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ID                                           
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> Sort the numbers in D in increasing order (if ID = 'I') or           
!> in decreasing order (if ID = 'D' ).                                  
!>                                                                      
!> Use Quick Sort, reverting to Insertion sort on arrays of             
!> size <= 20. Dimension of STACK limits N to about 2**32.              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ID                                                        
!> \verbatim                                                            
!>          ID is CHARACTER*1                                           
!>          = 'I': sort D in increasing order;                          
!>          = 'D': sort D in decreasing order.                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The length of the array D.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the array to be sorted.                           
!>          On exit, D has been sorted into increasing order            
!>          (D(1) <= ... <= D(N) ) or into decreasing order             
!>          (D(1) >= ... >= D(N) ), depending on ID.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DLASRT( ID, N, D, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ID 
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            SELECT 
      PARAMETER          ( SELECT = 20 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            DIR, ENDD, I, J, START, STKPNT 
      DOUBLE PRECISION   D1, D2, D3, DMNMX, TMP 
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            STACK( 2, 32 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           XERBLA 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      DIR = -1 
      IF( LSAME( ID, 'D' ) ) THEN 
      DIR = 0 
      ELSE IF( LSAME( ID, 'I' ) ) THEN 
      DIR = 1 
      END IF 
      IF( DIR.EQ.-1 ) THEN 
      INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -2 
      END IF 
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DLASRT', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.1 )                                                      &
&   RETURN                                                         
!                                                                       
      STKPNT = 1 
      STACK( 1, 1 ) = 1 
      STACK( 2, 1 ) = N 
10 CONTINUE 
      START = STACK( 1, STKPNT ) 
      ENDD = STACK( 2, STKPNT ) 
      STKPNT = STKPNT - 1 
      IF( ENDD-START.LE.SELECT .AND. ENDD-START.GT.0 ) THEN 
!                                                                       
!        Do Insertion sort on D( START:ENDD )                           
!                                                                       
      IF( DIR.EQ.0 ) THEN 
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            DO 30 I = START + 1, ENDD 
            DO 20 J = I, START + 1, -1 
                  IF( D( J ).GT.D( J-1 ) ) THEN 
                  DMNMX = D( J ) 
                  D( J ) = D( J-1 ) 
                  D( J-1 ) = DMNMX 
                  ELSE 
                  GO TO 30 
                  END IF 
20          CONTINUE 
30       CONTINUE 
!                                                                       
      ELSE 
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            DO 50 I = START + 1, ENDD 
            DO 40 J = I, START + 1, -1 
                  IF( D( J ).LT.D( J-1 ) ) THEN 
                  DMNMX = D( J ) 
                  D( J ) = D( J-1 ) 
                  D( J-1 ) = DMNMX 
                  ELSE 
                  GO TO 50 
                  END IF 
40          CONTINUE 
50       CONTINUE 
!                                                                       
      END IF 
!                                                                       
      ELSE IF( ENDD-START.GT.SELECT ) THEN 
!                                                                       
!        Partition D( START:ENDD ) and stack parts, largest one first   
!                                                                       
!        Choose partition entry as median of 3                          
!                                                                       
      D1 = D( START ) 
      D2 = D( ENDD ) 
      I = ( START+ENDD ) / 2 
      D3 = D( I ) 
      IF( D1.LT.D2 ) THEN 
            IF( D3.LT.D1 ) THEN 
            DMNMX = D1 
            ELSE IF( D3.LT.D2 ) THEN 
            DMNMX = D3 
            ELSE 
            DMNMX = D2 
            END IF 
      ELSE 
            IF( D3.LT.D2 ) THEN 
            DMNMX = D2 
            ELSE IF( D3.LT.D1 ) THEN 
            DMNMX = D3 
            ELSE 
            DMNMX = D1 
            END IF 
      END IF 
!                                                                       
      IF( DIR.EQ.0 ) THEN 
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            I = START - 1 
            J = ENDD + 1 
60       CONTINUE 
70       CONTINUE 
            J = J - 1 
            IF( D( J ).LT.DMNMX )                                       &
&         GO TO 70                                                 
80       CONTINUE 
            I = I + 1 
            IF( D( I ).GT.DMNMX )                                       &
&         GO TO 80                                                 
            IF( I.LT.J ) THEN 
            TMP = D( I ) 
            D( I ) = D( J ) 
            D( J ) = TMP 
            GO TO 60 
            END IF 
            IF( J-START.GT.ENDD-J-1 ) THEN 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = START 
            STACK( 2, STKPNT ) = J 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = J + 1 
            STACK( 2, STKPNT ) = ENDD 
            ELSE 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = J + 1 
            STACK( 2, STKPNT ) = ENDD 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = START 
            STACK( 2, STKPNT ) = J 
            END IF 
      ELSE 
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            I = START - 1 
            J = ENDD + 1 
90       CONTINUE 
100       CONTINUE 
            J = J - 1 
            IF( D( J ).GT.DMNMX )                                       &
&         GO TO 100                                                
110       CONTINUE 
            I = I + 1 
            IF( D( I ).LT.DMNMX )                                       &
&         GO TO 110                                                
            IF( I.LT.J ) THEN 
            TMP = D( I ) 
            D( I ) = D( J ) 
            D( J ) = TMP 
            GO TO 90 
            END IF 
            IF( J-START.GT.ENDD-J-1 ) THEN 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = START 
            STACK( 2, STKPNT ) = J 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = J + 1 
            STACK( 2, STKPNT ) = ENDD 
            ELSE 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = J + 1 
            STACK( 2, STKPNT ) = ENDD 
            STKPNT = STKPNT + 1 
            STACK( 1, STKPNT ) = START 
            STACK( 2, STKPNT ) = J 
            END IF 
      END IF 
      END IF 
      IF( STKPNT.GT.0 )                                                 &
&   GO TO 10                                                       
      RETURN 
!                                                                       
!     End of DLASRT                                                     
!                                                                       
      END                                           
!> \brief \b DLASSQ updates a sum of squares represented in scaled form.
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLASSQ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLASSQ( N, X, INCX, SCALE, SUMSQ )                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INCX, N                                      
!       DOUBLE PRECISION   SCALE, SUMSQ                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   X( * )                                       
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLASSQ  returns the values  scl  and  smsq  such that                
!>                                                                      
!>    ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq, 
!>                                                                      
!> where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is     
!> assumed to be non-negative and  scl  returns the value               
!>                                                                      
!>    scl = max( scale, abs( x( i ) ) ).                                
!>                                                                      
!> scale and sumsq must be supplied in SCALE and SUMSQ and              
!> scl and smsq are overwritten on SCALE and SUMSQ respectively.        
!>                                                                      
!> The routine makes only one pass through the vector x.                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of elements to be used from the vector X.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension (1+(N-1)*INCX)       
!>          The vector for which a scaled sum of squares is computed.   
!>             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>          The increment between successive values of the vector X.    
!>          INCX > 0.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SCALE                                                 
!> \verbatim                                                            
!>          SCALE is DOUBLE PRECISION                                   
!>          On entry, the value  scale  in the equation above.          
!>          On exit, SCALE is overwritten with  scl , the scaling factor
!>          for the sum of squares.                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] SUMSQ                                                 
!> \verbatim                                                            
!>          SUMSQ is DOUBLE PRECISION                                   
!>          On entry, the value  sumsq  in the equation above.          
!>          On exit, SUMSQ is overwritten with  smsq , the basic sum of 
!>          squares from which  scl  has been factored out.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      SUBROUTINE DLASSQ( N, X, INCX, SCALE, SUMSQ ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N 
      DOUBLE PRECISION   SCALE, SUMSQ 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   X( * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO 
      PARAMETER          ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IX 
      DOUBLE PRECISION   ABSXI 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            DISNAN 
      EXTERNAL           DISNAN 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.GT.0 ) THEN 
      DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX 
            ABSXI = ABS( X( IX ) ) 
            IF( ABSXI.GT.ZERO.OR.DISNAN( ABSXI ) ) THEN 
            IF( SCALE.LT.ABSXI ) THEN 
                  SUMSQ = 1 + SUMSQ*( SCALE / ABSXI )**2 
                  SCALE = ABSXI 
            ELSE 
                  SUMSQ = SUMSQ + ( ABSXI / SCALE )**2 
            END IF 
            END IF 
10    CONTINUE 
      END IF 
      RETURN 
!                                                                       
!     End of DLASSQ                                                     
!                                                                       
      END                                           
!> \brief \b DLATRD reduces the first nb rows and columns of a symmetric
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DLATRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            LDA, LDW, N, NB                              
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), E( * ), TAU( * ), W( LDW, * )   
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLATRD reduces NB rows and columns of a real symmetric matrix A to   
!> symmetric tridiagonal form by an orthogonal similarity               
!> transformation Q**T * A * Q, and returns the matrices V and W which a
!> needed to apply the transformation to the unreduced part of A.       
!>                                                                      
!> If UPLO = 'U', DLATRD reduces the last NB rows and columns of a      
!> matrix, of which the upper triangle is supplied;                     
!> if UPLO = 'L', DLATRD reduces the first NB rows and columns of a     
!> matrix, of which the lower triangle is supplied.                     
!>                                                                      
!> This is an auxiliary routine called by DSYTRD.                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is stored:                               
!>          = 'U': Upper triangular                                     
!>          = 'L': Lower triangular                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NB                                                        
!> \verbatim                                                            
!>          NB is INTEGER                                               
!>          The number of rows and columns to be reduced.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          n-by-n upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading n-by-n lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit:                                                    
!>          if UPLO = 'U', the last NB columns have been reduced to     
!>            tridiagonal form, with the diagonal elements overwriting  
!>            the diagonal elements of A; the elements above the diagona
!>            with the array TAU, represent the orthogonal matrix Q as a
!>            product of elementary reflectors;                         
!>          if UPLO = 'L', the first NB columns have been reduced to    
!>            tridiagonal form, with the diagonal elements overwriting  
!>            the diagonal elements of A; the elements below the diagona
!>            with the array TAU, represent the  orthogonal matrix Q as 
!>            product of elementary reflectors.                         
!>          See Further Details.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= (1,N).        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal       
!>          elements of the last NB columns of the reduced matrix;      
!>          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of 
!>          the first NB columns of the reduced matrix.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (N-1)              
!>          The scalar factors of the elementary reflectors, stored in  
!>          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
!>          See Further Details.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (LDW,NB)             
!>          The n-by-nb matrix W required to update the unreduced part  
!>          of A.                                                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDW                                                       
!> \verbatim                                                            
!>          LDW is INTEGER                                              
!>          The leading dimension of the array W. LDW >= max(1,N).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERauxiliary                                        
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n) H(n-1) . . . H(n-nb+1).                                 
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
!>  and tau in TAU(i-1).                                                
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(nb).                                       
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The elements of the vectors v together form the n-by-nb matrix V    
!>  which is needed, with W, to apply the transformation to the unreduce
!>  part of the matrix, using a symmetric rank-2k update of the form:   
!>  A := A - V*W**T - W*V**T.                                           
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5 and nb = 2:                                              
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  a   a   a   v4  v5 )              (  d                  )      
!>    (      a   a   v4  v5 )              (  1   d              )      
!>    (          a   1   v5 )              (  v1  1   a          )      
!>    (              d   1  )              (  v1  v2  a   a      )      
!>    (                  d  )              (  v1  v2  a   a   a  )      
!>                                                                      
!>  where d denotes a diagonal element of the reduced matrix, a denotes 
!>  an element of the original matrix that is unchanged, and vi denotes 
!>  an element of the vector defining H(i).                             
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            LDA, LDW, N, NB 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), E( * ), TAU( * ), W( LDW, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, HALF 
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, HALF = 0.5D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, IW 
      DOUBLE PRECISION   ALPHA 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DAXPY, DGEMV, DLARFG, DSCAL, DSYMV 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      DOUBLE PRECISION   DDOT 
      EXTERNAL           LSAME, DDOT 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 )                                                      &
&   RETURN                                                         
!                                                                       
      IF( LSAME( UPLO, 'U' ) ) THEN 
!                                                                       
!        Reduce last NB columns of upper triangle                       
!                                                                       
      DO 10 I = N, N - NB + 1, -1 
            IW = I - N + NB 
            IF( I.LT.N ) THEN 
!                                                                       
!              Update A(1:i,i)                                          
!                                                                       
            CALL DGEMV( 'No transpose', I, N-I, -ONE, A( 1, I+1 ),   &
&                     LDA, W( I, IW+1 ), LDW, ONE, A( 1, I ), 1 )  
            CALL DGEMV( 'No transpose', I, N-I, -ONE, W( 1, IW+1 ),  &
&                     LDW, A( I, I+1 ), LDA, ONE, A( 1, I ), 1 )   
            END IF 
            IF( I.GT.1 ) THEN 
!                                                                       
!              Generate elementary reflector H(i) to annihilate         
!              A(1:i-2,i)                                               
!                                                                       
            CALL DLARFG( I-1, A( I-1, I ), A( 1, I ), 1, TAU( I-1 ) ) 
            E( I-1 ) = A( I-1, I ) 
            A( I-1, I ) = ONE 
!                                                                       
!              Compute W(1:i-1,i)                                       
!                                                                       
            CALL DSYMV( 'Upper', I-1, ONE, A, LDA, A( 1, I ), 1,     &
&                     ZERO, W( 1, IW ), 1 )                        
            IF( I.LT.N ) THEN 
                  CALL DGEMV( 'Transpose', I-1, N-I, ONE, W( 1, IW+1 ), &
&                        LDW, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
                  CALL DGEMV( 'No transpose', I-1, N-I, -ONE,           &
&                        A( 1, I+1 ), LDA, W( I+1, IW ), 1, ONE,   &
&                        W( 1, IW ), 1 )                           
                  CALL DGEMV( 'Transpose', I-1, N-I, ONE, A( 1, I+1 ),  &
&                        LDA, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
                  CALL DGEMV( 'No transpose', I-1, N-I, -ONE,           &
&                        W( 1, IW+1 ), LDW, W( I+1, IW ), 1, ONE,  &
&                        W( 1, IW ), 1 )                           
            END IF 
            CALL DSCAL( I-1, TAU( I-1 ), W( 1, IW ), 1 ) 
            ALPHA = -HALF*TAU( I-1 )*DDOT( I-1, W( 1, IW ), 1,       &
&                 A( 1, I ), 1 )                                   
            CALL DAXPY( I-1, ALPHA, A( 1, I ), 1, W( 1, IW ), 1 ) 
            END IF 
!                                                                       
10    CONTINUE 
      ELSE 
!                                                                       
!        Reduce first NB columns of lower triangle                      
!                                                                       
      DO 20 I = 1, NB 
!                                                                       
!           Update A(i:n,i)                                             
!                                                                       
            CALL DGEMV( 'No transpose', N-I+1, I-1, -ONE, A( I, 1 ),    &
&                  LDA, W( I, 1 ), LDW, ONE, A( I, I ), 1 )        
            CALL DGEMV( 'No transpose', N-I+1, I-1, -ONE, W( I, 1 ),    &
&                  LDW, A( I, 1 ), LDA, ONE, A( I, I ), 1 )        
            IF( I.LT.N ) THEN 
!                                                                       
!              Generate elementary reflector H(i) to annihilate         
!              A(i+2:n,i)                                               
!                                                                       
            CALL DLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1, &
&                      TAU( I ) )                                  
            E( I ) = A( I+1, I ) 
            A( I+1, I ) = ONE 
!                                                                       
!              Compute W(i+1:n,i)                                       
!                                                                       
            CALL DSYMV( 'Lower', N-I, ONE, A( I+1, I+1 ), LDA,       &
&                     A( I+1, I ), 1, ZERO, W( I+1, I ), 1 )       
            CALL DGEMV( 'Transpose', N-I, I-1, ONE, W( I+1, 1 ), LDW,&
&                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )         
            CALL DGEMV( 'No transpose', N-I, I-1, -ONE, A( I+1, 1 ), &
&                     LDA, W( 1, I ), 1, ONE, W( I+1, I ), 1 )     
            CALL DGEMV( 'Transpose', N-I, I-1, ONE, A( I+1, 1 ), LDA,&
&                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )         
            CALL DGEMV( 'No transpose', N-I, I-1, -ONE, W( I+1, 1 ), &
&                     LDW, W( 1, I ), 1, ONE, W( I+1, I ), 1 )     
            CALL DSCAL( N-I, TAU( I ), W( I+1, I ), 1 ) 
            ALPHA = -HALF*TAU( I )*DDOT( N-I, W( I+1, I ), 1,        &
&                 A( I+1, I ), 1 )                                 
            CALL DAXPY( N-I, ALPHA, A( I+1, I ), 1, W( I+1, I ), 1 ) 
            END IF 
!                                                                       
20    CONTINUE 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DLATRD                                                     
!                                                                       
      END                                           
!> \brief \b DNRM2                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX)                       
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION X(*)                                           
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DNRM2 returns the euclidean norm of a vector via the function        
!> name, so that                                                        
!>                                                                      
!>    DNRM2 := sqrt( x'*x )                                             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  -- This version written on 25-October-1982.                         
!>     Modified on 14-October-1993 to inline the call to DLASSQ.        
!>     Sven Hammarling, Nag Ltd.                                        
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION X(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION ABSXI,NORM,SCALE,SSQ 
      INTEGER IX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS,SQRT 
!     ..                                                                
      IF (N.LT.1 .OR. INCX.LT.1) THEN 
      NORM = ZERO 
      ELSE IF (N.EQ.1) THEN 
      NORM = ABS(X(1)) 
      ELSE 
      SCALE = ZERO 
      SSQ = ONE 
!        The following loop is equivalent to this call to the LAPACK    
!        auxiliary routine:                                             
!        CALL DLASSQ( N, X, INCX, SCALE, SSQ )                          
!                                                                       
      DO 10 IX = 1,1 + (N-1)*INCX,INCX 
            IF (X(IX).NE.ZERO) THEN 
                  ABSXI = ABS(X(IX)) 
                  IF (SCALE.LT.ABSXI) THEN 
                  SSQ = ONE + SSQ* (SCALE/ABSXI)**2 
                  SCALE = ABSXI 
                  ELSE 
                  SSQ = SSQ + (ABSXI/SCALE)**2 
                  END IF 
            END IF 
10     CONTINUE 
      NORM = SCALE*SQRT(SSQ) 
      END IF 
!                                                                       
      DNRM2 = NORM 
      RETURN 
!                                                                       
!     End of DNRM2.                                                     
!                                                                       
      END                                           
!> \brief \b DORM2L multiplies a general matrix by the orthogonal matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DORM2L + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, M, N                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DORM2L overwrites the general real m by n matrix C with              
!>                                                                      
!>       Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!>                                                                      
!>       Q**T * C  if SIDE = 'L' and TRANS = 'T', or                    
!>                                                                      
!>       C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!>                                                                      
!>       C * Q**T if SIDE = 'R' and TRANS = 'T',                        
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(k) . . . H(2) H(1)                                       
!>                                                                      
!> as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left                        
!>          = 'R': apply Q or Q**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply Q  (No transpose)                              
!>          = 'T': apply Q**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,K)              
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          DGEQLF in the last k columns of its array argument A.       
!>          A is modified by the routine but restored on exit.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (K)                
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by DGEQLF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension                   
!>                                   (N) if SIDE = 'L',                 
!>                                   (M) if SIDE = 'R'                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
&                   WORK, INFO )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN 
      INTEGER            I, I1, I2, I3, MI, NI, NQ 
      DOUBLE PRECISION   AII 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLARF, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN 
      NQ = M 
      ELSE 
      NQ = N 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
      INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
      INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
      INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
      INFO = -10 
      END IF 
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DORM2L', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                              &
&   RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. NOTRAN ) .OR. ( .NOT.LEFT .AND. .NOT.NOTRAN ) )  &
&     THEN                                                         
      I1 = 1 
      I2 = K 
      I3 = 1 
      ELSE 
      I1 = K 
      I2 = 1 
      I3 = -1 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
      NI = N 
      ELSE 
      MI = M 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
      IF( LEFT ) THEN 
!                                                                       
!           H(i) is applied to C(1:m-k+i,1:n)                           
!                                                                       
            MI = M - K + I 
      ELSE 
!                                                                       
!           H(i) is applied to C(1:m,1:n-k+i)                           
!                                                                       
            NI = N - K + I 
      END IF 
!                                                                       
!        Apply H(i)                                                     
!                                                                       
      AII = A( NQ-K+I, I ) 
      A( NQ-K+I, I ) = ONE 
      CALL DLARF( SIDE, MI, NI, A( 1, I ), 1, TAU( I ), C, LDC,      &
&               WORK )                                             
      A( NQ-K+I, I ) = AII 
10 END DO 
      RETURN 
!                                                                       
!     End of DORM2L                                                     
!                                                                       
      END                                           
!> \brief \b DORM2R multiplies a general matrix by the orthogonal matrix
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DORM2R + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, INFO )                                 
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, M, N                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DORM2R overwrites the general real m by n matrix C with              
!>                                                                      
!>       Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!>                                                                      
!>       Q**T* C  if SIDE = 'L' and TRANS = 'T', or                     
!>                                                                      
!>       C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!>                                                                      
!>       C * Q**T if SIDE = 'R' and TRANS = 'T',                        
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(1) H(2) . . . H(k)                                       
!>                                                                      
!> as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left                        
!>          = 'R': apply Q or Q**T from the Right                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N': apply Q  (No transpose)                              
!>          = 'T': apply Q**T (Transpose)                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,K)              
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          DGEQRF in the first k columns of its array argument A.      
!>          A is modified by the routine but restored on exit.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (K)                
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by DGEQRF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the m by n matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension                   
!>                                   (N) if SIDE = 'L',                 
!>                                   (M) if SIDE = 'R'                  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit                                        
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
&                   WORK, INFO )                                   
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN 
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ 
      DOUBLE PRECISION   AII 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLARF, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN 
      NQ = M 
      ELSE 
      NQ = N 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
      INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
      INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
      INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
      INFO = -10 
      END IF 
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DORM2R', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                              &
&   RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. .NOT.NOTRAN ) .OR. ( .NOT.LEFT .AND. NOTRAN ) )  &
&     THEN                                                         
      I1 = 1 
      I2 = K 
      I3 = 1 
      ELSE 
      I1 = K 
      I2 = 1 
      I3 = -1 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
      NI = N 
      JC = 1 
      ELSE 
      MI = M 
      IC = 1 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
      IF( LEFT ) THEN 
!                                                                       
!           H(i) is applied to C(i:m,1:n)                               
!                                                                       
            MI = M - I + 1 
            IC = I 
      ELSE 
!                                                                       
!           H(i) is applied to C(1:m,i:n)                               
!                                                                       
            NI = N - I + 1 
            JC = I 
      END IF 
!                                                                       
!        Apply H(i)                                                     
!                                                                       
      AII = A( I, I ) 
      A( I, I ) = ONE 
      CALL DLARF( SIDE, MI, NI, A( I, I ), 1, TAU( I ), C( IC, JC ), &
&               LDC, WORK )                                        
      A( I, I ) = AII 
10 END DO 
      RETURN 
!                                                                       
!     End of DORM2R                                                     
!                                                                       
      END                                           
!> \brief \b DORMQL                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DORMQL + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, LWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DORMQL overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(k) . . . H(2) H(1)                                       
!>                                                                      
!> as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,K)              
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          DGEQLF in the last k columns of its array argument A.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (K)                
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by DGEQLF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))    
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For good performance, LWORK should generally be larger.     
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
&                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT, TSIZE 
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,                   &
&                     TSIZE = LDT*NBMAX )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN 
      INTEGER            I, I1, I2, I3, IB, IINFO, IWT, LDWORK, LWKOPT, &
&                   MI, NB, NBMIN, NI, NQ, NW                      
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLARFB, DLARFT, DORM2L, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
      NQ = M 
      NW = MAX( 1, N ) 
      ELSE 
      NQ = N 
      NW = MAX( 1, M ) 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
      INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
      INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
      INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
      INFO = -10 
      ELSE IF( LWORK.LT.NW .AND. .NOT.LQUERY ) THEN 
      INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!        Compute the workspace requirements                             
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN 
            LWKOPT = 1 
      ELSE 
            NB = MIN( NBMAX, ILAENV( 1, 'DORMQL', SIDE // TRANS, M, N,  &
&                               K, -1 ) )                          
            LWKOPT = NW*NB + TSIZE 
      END IF 
      WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DORMQL', -INFO ) 
      RETURN 
      ELSE IF( LQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN 
      RETURN 
      END IF 
!                                                                       
      NBMIN = 2 
      LDWORK = NW 
      IF( NB.GT.1 .AND. NB.LT.K ) THEN 
      IF( LWORK.LT.NW*NB+TSIZE ) THEN 
            NB = (LWORK-TSIZE) / LDWORK 
            NBMIN = MAX( 2, ILAENV( 2, 'DORMQL', SIDE // TRANS, M, N, K,&
&              -1 ) )                                              
      END IF 
      END IF 
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN 
!                                                                       
!        Use unblocked code                                             
!                                                                       
      CALL DORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,  &
&                IINFO )                                           
      ELSE 
!                                                                       
!        Use blocked code                                               
!                                                                       
      IWT = 1 + NW*NB 
      IF( ( LEFT .AND. NOTRAN ) .OR.                                 &
&       ( .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN                     
            I1 = 1 
            I2 = K 
            I3 = NB 
      ELSE 
            I1 = ( ( K-1 ) / NB )*NB + 1 
            I2 = 1 
            I3 = -NB 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
            NI = N 
      ELSE 
            MI = M 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
            IB = MIN( NB, K-I+1 ) 
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i+ib-1) . . . H(i+1) H(i)                             
!                                                                       
            CALL DLARFT( 'Backward', 'Columnwise', NQ-K+I+IB-1, IB,     &
&                   A( 1, I ), LDA, TAU( I ), WORK( IWT ), LDT )   
            IF( LEFT ) THEN 
!                                                                       
!              H or H**T is applied to C(1:m-k+i+ib-1,1:n)              
!                                                                       
            MI = M - K + I + IB - 1 
            ELSE 
!                                                                       
!              H or H**T is applied to C(1:m,1:n-k+i+ib-1)              
!                                                                       
            NI = N - K + I + IB - 1 
            END IF 
!                                                                       
!           Apply H or H**T                                             
!                                                                       
            CALL DLARFB( SIDE, TRANS, 'Backward', 'Columnwise', MI, NI, &
&                   IB, A( 1, I ), LDA, WORK( IWT ), LDT, C, LDC,  &
&                   WORK, LDWORK )                                 
10    CONTINUE 
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of DORMQL                                                     
!                                                                       
      END                                           
!> \brief \b DORMQR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DORMQR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS                                  
!       INTEGER            INFO, K, LDA, LDC, LWORK, M, N               
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DORMQR overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix defined as the product of k      
!> elementary reflectors                                                
!>                                                                      
!>       Q = H(1) H(2) . . . H(k)                                       
!>                                                                      
!> as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N  
!> if SIDE = 'R'.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>          The number of elementary reflectors whose product defines   
!>          the matrix Q.                                               
!>          If SIDE = 'L', M >= K >= 0;                                 
!>          if SIDE = 'R', N >= K >= 0.                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,K)              
!>          The i-th column must contain the vector which defines the   
!>          elementary reflector H(i), for i = 1,2,...,k, as returned by
!>          DGEQRF in the first k columns of its array argument A.      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          If SIDE = 'L', LDA >= max(1,M);                             
!>          if SIDE = 'R', LDA >= max(1,N).                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (K)                
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by DGEQRF.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))    
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For good performance, LWORK should generally be larger.     
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,     &
&                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS 
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT, TSIZE 
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,                   &
&                     TSIZE = LDT*NBMAX )                          
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN 
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWT, JC, LDWORK, &
&                   LWKOPT, MI, NB, NBMIN, NI, NQ, NW              
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLARFB, DLARFT, DORM2R, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      NOTRAN = LSAME( TRANS, 'N' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
      NQ = M 
      NW = N 
      ELSE 
      NQ = N 
      NW = M 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN 
      INFO = -2 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN 
      INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
      INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
      INFO = -10 
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN 
      INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!        Compute the workspace requirements                             
!                                                                       
      NB = MIN( NBMAX, ILAENV( 1, 'DORMQR', SIDE // TRANS, M, N, K,  &
&        -1 ) )                                                    
      LWKOPT = MAX( 1, NW )*NB + TSIZE 
      WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DORMQR', -INFO ) 
      RETURN 
      ELSE IF( LQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN 
      WORK( 1 ) = 1 
      RETURN 
      END IF 
!                                                                       
      NBMIN = 2 
      LDWORK = NW 
      IF( NB.GT.1 .AND. NB.LT.K ) THEN 
      IF( LWORK.LT.NW*NB+TSIZE ) THEN 
            NB = (LWORK-TSIZE) / LDWORK 
            NBMIN = MAX( 2, ILAENV( 2, 'DORMQR', SIDE // TRANS, M, N, K,&
&              -1 ) )                                              
      END IF 
      END IF 
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN 
!                                                                       
!        Use unblocked code                                             
!                                                                       
      CALL DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,  &
&                IINFO )                                           
      ELSE 
!                                                                       
!        Use blocked code                                               
!                                                                       
      IWT = 1 + NW*NB 
      IF( ( LEFT .AND. .NOT.NOTRAN ) .OR.                            &
&       ( .NOT.LEFT .AND. NOTRAN ) ) THEN                          
            I1 = 1 
            I2 = K 
            I3 = NB 
      ELSE 
            I1 = ( ( K-1 ) / NB )*NB + 1 
            I2 = 1 
            I3 = -NB 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
            NI = N 
            JC = 1 
      ELSE 
            MI = M 
            IC = 1 
      END IF 
!                                                                       
      DO 10 I = I1, I2, I3 
            IB = MIN( NB, K-I+1 ) 
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i) H(i+1) . . . H(i+ib-1)                             
!                                                                       
            CALL DLARFT( 'Forward', 'Columnwise', NQ-I+1, IB, A( I, I ),&
&                   LDA, TAU( I ), WORK( IWT ), LDT )              
            IF( LEFT ) THEN 
!                                                                       
!              H or H**T is applied to C(i:m,1:n)                       
!                                                                       
            MI = M - I + 1 
            IC = I 
            ELSE 
!                                                                       
!              H or H**T is applied to C(1:m,i:n)                       
!                                                                       
            NI = N - I + 1 
            JC = I 
            END IF 
!                                                                       
!           Apply H or H**T                                             
!                                                                       
            CALL DLARFB( SIDE, TRANS, 'Forward', 'Columnwise', MI, NI,  &
&                   IB, A( I, I ), LDA, WORK( IWT ), LDT,          &
&                   C( IC, JC ), LDC, WORK, LDWORK )               
10    CONTINUE 
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of DORMQR                                                     
!                                                                       
      END                                           
!> \brief \b DORMTR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DORMTR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
!                          WORK, LWORK, INFO )                          
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          SIDE, TRANS, UPLO                            
!       INTEGER            INFO, LDA, LDC, LWORK, M, N                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DORMTR overwrites the general real M-by-N matrix C with              
!>                                                                      
!>                 SIDE = 'L'     SIDE = 'R'                            
!> TRANS = 'N':      Q * C          C * Q                               
!> TRANS = 'T':      Q**T * C       C * Q**T                            
!>                                                                      
!> where Q is a real orthogonal matrix of order nq, with nq = m if      
!> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of  
!> nq-1 elementary reflectors, as returned by DSYTRD:                   
!>                                                                      
!> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);                          
!>                                                                      
!> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).                          
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>          = 'L': apply Q or Q**T from the Left;                       
!>          = 'R': apply Q or Q**T from the Right.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U': Upper triangle of A contains elementary reflectors   
!>                 from DSYTRD;                                         
!>          = 'L': Lower triangle of A contains elementary reflectors   
!>                 from DSYTRD.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>          = 'N':  No transpose, apply Q;                              
!>          = 'T':  Transpose, apply Q**T.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix C. M >= 0.                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix C. N >= 0.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension                      
!>                               (LDA,M) if SIDE = 'L'                  
!>                               (LDA,N) if SIDE = 'R'                  
!>          The vectors which define the elementary reflectors, as      
!>          returned by DSYTRD.                                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.                       
!>          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TAU                                                       
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension                    
!>                               (M-1) if SIDE = 'L'                    
!>                               (N-1) if SIDE = 'R'                    
!>          TAU(i) must contain the scalar factor of the elementary     
!>          reflector H(i), as returned by DSYTRD.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension (LDC,N)              
!>          On entry, the M-by-N matrix C.                              
!>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>          The leading dimension of the array C. LDC >= max(1,M).      
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))    
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.                            
!>          If SIDE = 'L', LWORK >= max(1,N);                           
!>          if SIDE = 'R', LWORK >= max(1,M).                           
!>          For optimum performance LWORK >= N*NB if SIDE = 'L', and    
!>          LWORK >= M*NB if SIDE = 'R', where NB is the optimal        
!>          blocksize.                                                  
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,  &
&                   WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS, UPLO 
      INTEGER            INFO, LDA, LDC, LWORK, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, UPPER 
      INTEGER            I1, I2, IINFO, LWKOPT, MI, NB, NI, NQ, NW 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DORMQL, DORMQR, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0 
      LEFT = LSAME( SIDE, 'L' ) 
      UPPER = LSAME( UPLO, 'U' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN 
      NQ = M 
      NW = N 
      ELSE 
      NQ = N 
      NW = M 
      END IF 
      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
      INFO = -2 
      ELSE IF( .NOT.LSAME( TRANS, 'N' ) .AND. .NOT.LSAME( TRANS, 'T' ) )&
&          THEN                                                    
      INFO = -3 
      ELSE IF( M.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -5 
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN 
      INFO = -7 
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN 
      INFO = -10 
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN 
      INFO = -12 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
      IF( UPPER ) THEN 
            IF( LEFT ) THEN 
            NB = ILAENV( 1, 'DORMQL', SIDE // TRANS, M-1, N, M-1,    &
&              -1 )                                                
            ELSE 
            NB = ILAENV( 1, 'DORMQL', SIDE // TRANS, M, N-1, N-1,    &
&              -1 )                                                
            END IF 
      ELSE 
            IF( LEFT ) THEN 
            NB = ILAENV( 1, 'DORMQR', SIDE // TRANS, M-1, N, M-1,    &
&              -1 )                                                
            ELSE 
            NB = ILAENV( 1, 'DORMQR', SIDE // TRANS, M, N-1, N-1,    &
&              -1 )                                                
            END IF 
      END IF 
      LWKOPT = MAX( 1, NW )*NB 
      WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DORMTR', -INFO ) 
      RETURN 
      ELSE IF( LQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. NQ.EQ.1 ) THEN 
      WORK( 1 ) = 1 
      RETURN 
      END IF 
!                                                                       
      IF( LEFT ) THEN 
      MI = M - 1 
      NI = N 
      ELSE 
      MI = M 
      NI = N - 1 
      END IF 
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Q was determined by a call to DSYTRD with UPLO = 'U'           
!                                                                       
      CALL DORMQL( SIDE, TRANS, MI, NI, NQ-1, A( 1, 2 ), LDA, TAU, C,&
&                LDC, WORK, LWORK, IINFO )                         
      ELSE 
!                                                                       
!        Q was determined by a call to DSYTRD with UPLO = 'L'           
!                                                                       
      IF( LEFT ) THEN 
            I1 = 2 
            I2 = 1 
      ELSE 
            I1 = 1 
            I2 = 2 
      END IF 
      CALL DORMQR( SIDE, TRANS, MI, NI, NQ-1, A( 2, 1 ), LDA, TAU,   &
&                C( I1, I2 ), LDC, WORK, LWORK, IINFO )            
      END IF 
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of DORMTR                                                     
!                                                                       
      END                                           
!> \brief \b DSCAL                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSCAL(N,DA,DX,INCX)                                  
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION DA                                             
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*)                                          
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    DSCAL scales a vector by a constant.                              
!>    uses unrolled loops for increment equal to 1.                     
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DA                                                        
!> \verbatim                                                            
!>          DA is DOUBLE PRECISION                                      
!>           On entry, DA specifies the scalar alpha.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DX                                                    
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 3/93 to return if incx .le. 0.                          
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSCAL(N,DA,DX,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION DA 
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I,M,MP1,NINCX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0 .OR. INCX.LE.0) RETURN 
      IF (INCX.EQ.1) THEN 
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
      M = MOD(N,5) 
      IF (M.NE.0) THEN 
            DO I = 1,M 
            DX(I) = DA*DX(I) 
            END DO 
            IF (N.LT.5) RETURN 
      END IF 
      MP1 = M + 1 
      DO I = MP1,N,5 
            DX(I) = DA*DX(I) 
            DX(I+1) = DA*DX(I+1) 
            DX(I+2) = DA*DX(I+2) 
            DX(I+3) = DA*DX(I+3) 
            DX(I+4) = DA*DX(I+4) 
      END DO 
      ELSE 
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
      NINCX = N*INCX 
      DO I = 1,NINCX,INCX 
            DX(I) = DA*DX(I) 
      END DO 
      END IF 
      RETURN 
!> \brief \b DSTEBZ                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSTEBZ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E
!                          M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,   
!                          INFO )                                       
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          ORDER, RANGE                                 
!       INTEGER            IL, INFO, IU, M, N, NSPLIT                   
!       DOUBLE PRECISION   ABSTOL, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * )         
!       DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * )            
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSTEBZ computes the eigenvalues of a symmetric tridiagonal           
!> matrix T.  The user may ask for all eigenvalues, all eigenvalues     
!> in the half-open interval (VL, VU], or the IL-th through IU-th       
!> eigenvalues.                                                         
!>                                                                      
!> To avoid overflow, the matrix must be scaled so that its             
!> largest element is no greater than overflow**(1/2) * underflow**(1/4)
!> accuracy, it should not be much smaller than that.                   
!>                                                                      
!> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal        
!> Matrix", Report CS41, Computer Science Dept., Stanford               
!> University, July 21, 1966.                                           
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': ("All")   all eigenvalues will be found.             
!>          = 'V': ("Value") all eigenvalues in the half-open interval  
!>                           (VL, VU] will be found.                    
!>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
!>                           entire matrix) will be found.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ORDER                                                     
!> \verbatim                                                            
!>          ORDER is CHARACTER*1                                        
!>          = 'B': ("By Block") the eigenvalues will be grouped by      
!>                              split-off block (see IBLOCK, ISPLIT) and
!>                              ordered from smallest to largest within 
!>                              the block.                              
!>          = 'E': ("Entire matrix")                                    
!>                              the eigenvalues for the entire matrix   
!>                              will be ordered from smallest to        
!>                              largest.                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the tridiagonal matrix T.  N >= 0.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>                                                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>                                                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues.  Eigenvalues less than or equal
!>          to VL, or greater than VU, will not be returned.  VL < VU.  
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is DOUBLE PRECISION                                  
!>          The absolute tolerance for the eigenvalues.  An eigenvalue  
!>          (or cluster) is considered to be located if it has been     
!>          determined to lie in an interval whose width is ABSTOL or   
!>          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
!>          will be used, where |T| means the 1-norm of T.              
!>                                                                      
!>          Eigenvalues will be computed most accurately when ABSTOL is 
!>          set to twice the underflow threshold 2*DLAMCH('S'), not zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The (n-1) off-diagonal elements of the tridiagonal matrix T.
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The actual number of eigenvalues found. 0 <= M <= N.        
!>          (See also the description of INFO=2,3.)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] NSPLIT                                                   
!> \verbatim                                                            
!>          NSPLIT is INTEGER                                           
!>          The number of diagonal blocks in the matrix T.              
!>          1 <= NSPLIT <= N.                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          On exit, the first M elements of W will contain the         
!>          eigenvalues.  (DSTEBZ may use the remaining N-M elements as 
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IBLOCK                                                   
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          At each row/column j where E(j) is zero or small, the       
!>          matrix T is considered to split into a block diagonal       
!>          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which 
!>          block (from 1 to the number of blocks) the eigenvalue W(i)  
!>          belongs.  (DSTEBZ may use the remaining N-M elements as     
!>          workspace.)                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISPLIT                                                   
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to ISPLIT(1),
!>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),   
!>          etc., and the NSPLIT-th consists of rows/columns            
!>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.                
!>          (Only the first NSPLIT elements will actually be used, but  
!>          since the user cannot know a priori what value NSPLIT will  
!>          have, N words must be reserved for ISPLIT.)                 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (4*N)             
!> \endverbatim                                                         
      END                                           
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (3*N)                     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  some or all of the eigenvalues failed to converge or  
!>                were not computed:                                    
!>                =1 or 3: Bisection failed to converge for some        
!>                        eigenvalues; these eigenvalues are flagged by 
!>                        negative block number.  The effect is that the
!>                        eigenvalues may not be as accurate as the     
!>                        absolute and relative tolerances.  This is    
!>                        generally caused by unexpectedly inaccurate   
!>                        arithmetic.                                   
!>                =2 or 3: RANGE='I' only: Not all of the eigenvalues   
!>                        IL:IU were found.                             
!>                        Effect: M < IU+1-IL                           
!>                        Cause:  non-monotonic arithmetic, causing the 
!>                                Sturm sequence to be non-monotonic.   
!>                        Cure:   recalculate, using RANGE='A', and pick
!>                                out eigenvalues IL:IU.  In some cases,
!>                                increasing the PARAMETER "FUDGE" may  
!>                                make things work.                     
!>                = 4:    RANGE='I', and the Gershgorin interval        
!>                        initially used was too small.  No eigenvalues 
!>                        were computed.                                
!>                        Probable cause: your machine has sloppy       
!>                                        floating-point arithmetic.    
!>                        Cure: Increase the PARAMETER "FUDGE",         
!>                              recompile, and try again.               
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  RELFAC  DOUBLE PRECISION, default = 2.0e0                           
!>          The relative tolerance.  An interval (a,b] lies within      
!>          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),     
!>          where "ulp" is the machine precision (distance from 1 to    
!>          the next larger floating point number.)                     
!>                                                                      
!>  FUDGE   DOUBLE PRECISION, default = 2                               
!>          A "fudge factor" to widen the Gershgorin intervals.  Ideally
!>          a value of 1 should work, but on machines with sloppy       
!>          arithmetic, this needs to be larger.  The default for       
!>          publicly released versions should be large enough to handle 
!>          the worst machine around.  Note that this has no effect     
!>          on accuracy of the solution.                                
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E, &
&                   M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,     &
&                   INFO )                                         
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ORDER, RANGE 
      INTEGER            IL, INFO, IU, M, N, NSPLIT 
      DOUBLE PRECISION   ABSTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * ) 
      DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TWO, HALF 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0,      &
&                   HALF = 1.0D0 / TWO )                           
      DOUBLE PRECISION   FUDGE, RELFAC 
      PARAMETER          ( FUDGE = 2.1D0, RELFAC = 2.0D0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            NCNVRG, TOOFEW 
      INTEGER            IB, IBEGIN, IDISCL, IDISCU, IE, IEND, IINFO,   &
&                   IM, IN, IOFF, IORDER, IOUT, IRANGE, ITMAX,     &
&                   ITMP1, IW, IWOFF, J, JB, JDISC, JE, NB, NWL,   &
&                   NWU                                            
      DOUBLE PRECISION   ATOLI, BNORM, GL, GU, PIVMIN, RTOLI, SAFEMN,   &
&                   TMP1, TMP2, TNORM, ULP, WKILL, WL, WLU, WU, WUL
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            IDUMMA( 1 ) 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      DOUBLE PRECISION   DLAMCH 
      EXTERNAL           LSAME, ILAENV, DLAMCH 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLAEBZ, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0 
!                                                                       
!     Decode RANGE                                                      
!                                                                       
      IF( LSAME( RANGE, 'A' ) ) THEN 
      IRANGE = 1 
      ELSE IF( LSAME( RANGE, 'V' ) ) THEN 
      IRANGE = 2 
      ELSE IF( LSAME( RANGE, 'I' ) ) THEN 
      IRANGE = 3 
      ELSE 
      IRANGE = 0 
      END IF 
!                                                                       
!     Decode ORDER                                                      
!                                                                       
      IF( LSAME( ORDER, 'B' ) ) THEN 
      IORDER = 2 
      ELSE IF( LSAME( ORDER, 'E' ) ) THEN 
      IORDER = 1 
      ELSE 
      IORDER = 0 
      END IF 
!                                                                       
!     Check for Errors                                                  
!                                                                       
      IF( IRANGE.LE.0 ) THEN 
      INFO = -1 
      ELSE IF( IORDER.LE.0 ) THEN 
      INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( IRANGE.EQ.2 ) THEN 
      IF( VL.GE.VU )                                                 &
&      INFO = -5                                                   
      ELSE IF( IRANGE.EQ.3 .AND. ( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) )   &
&          THEN                                                    
      INFO = -6 
      ELSE IF( IRANGE.EQ.3 .AND. ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) )  &
&          THEN                                                    
      INFO = -7 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DSTEBZ', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Initialize error flags                                            
!                                                                       
      INFO = 0 
      NCNVRG = .FALSE. 
      TOOFEW = .FALSE. 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      M = 0 
      IF( N.EQ.0 )                                                      &
&   RETURN                                                         
!                                                                       
!     Simplifications:                                                  
!                                                                       
      IF( IRANGE.EQ.3 .AND. IL.EQ.1 .AND. IU.EQ.N )                     &
&   IRANGE = 1                                                     
!                                                                       
!     Get machine constants                                             
!     NB is the minimum vector length for vector bisection, or 0        
!     if only scalar is to be done.                                     
!                                                                       
      SAFEMN = DLAMCH( 'S' ) 
      ULP = DLAMCH( 'P' ) 
      RTOLI = ULP*RELFAC 
      NB = ILAENV( 1, 'DSTEBZ', ' ', N, -1, -1, -1 ) 
      IF( NB.LE.1 )                                                     &
&   NB = 0                                                         
!                                                                       
!     Special Case when N=1                                             
!                                                                       
      IF( N.EQ.1 ) THEN 
      NSPLIT = 1 
      ISPLIT( 1 ) = 1 
      IF( IRANGE.EQ.2 .AND. ( VL.GE.D( 1 ) .OR. VU.LT.D( 1 ) ) ) THEN 
            M = 0 
      ELSE 
            W( 1 ) = D( 1 ) 
            IBLOCK( 1 ) = 1 
            M = 1 
      END IF 
      RETURN 
      END IF 
!                                                                       
!     Compute Splitting Points                                          
!                                                                       
      NSPLIT = 1 
      WORK( N ) = ZERO 
      PIVMIN = ONE 
!                                                                       
      DO 10 J = 2, N 
      TMP1 = E( J-1 )**2 
      IF( ABS( D( J )*D( J-1 ) )*ULP**2+SAFEMN.GT.TMP1 ) THEN 
            ISPLIT( NSPLIT ) = J - 1 
            NSPLIT = NSPLIT + 1 
            WORK( J-1 ) = ZERO 
      ELSE 
            WORK( J-1 ) = TMP1 
            PIVMIN = MAX( PIVMIN, TMP1 ) 
      END IF 
10 END DO 
      ISPLIT( NSPLIT ) = N 
      PIVMIN = PIVMIN*SAFEMN 
!                                                                       
!     Compute Interval and ATOLI                                        
!                                                                       
      IF( IRANGE.EQ.3 ) THEN 
!                                                                       
!        RANGE='I': Compute the interval containing eigenvalues         
!                   IL through IU.                                      
!                                                                       
!        Compute Gershgorin interval for entire (split) matrix          
!        and use it as the initial interval                             
!                                                                       
      GU = D( 1 ) 
      GL = D( 1 ) 
      TMP1 = ZERO 
!                                                                       
      DO 20 J = 1, N - 1 
            TMP2 = SQRT( WORK( J ) ) 
            GU = MAX( GU, D( J )+TMP1+TMP2 ) 
            GL = MIN( GL, D( J )-TMP1-TMP2 ) 
            TMP1 = TMP2 
20    CONTINUE 
!                                                                       
      GU = MAX( GU, D( N )+TMP1 ) 
      GL = MIN( GL, D( N )-TMP1 ) 
      TNORM = MAX( ABS( GL ), ABS( GU ) ) 
      GL = GL - FUDGE*TNORM*ULP*N - FUDGE*TWO*PIVMIN 
      GU = GU + FUDGE*TNORM*ULP*N + FUDGE*PIVMIN 
!                                                                       
!        Compute Iteration parameters                                   
!                                                                       
      ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /           &
&           LOG( TWO ) ) + 2                                       
      IF( ABSTOL.LE.ZERO ) THEN 
            ATOLI = ULP*TNORM 
      ELSE 
            ATOLI = ABSTOL 
      END IF 
!                                                                       
      WORK( N+1 ) = GL 
      WORK( N+2 ) = GL 
      WORK( N+3 ) = GU 
      WORK( N+4 ) = GU 
      WORK( N+5 ) = GL 
      WORK( N+6 ) = GU 
      IWORK( 1 ) = -1 
      IWORK( 2 ) = -1 
      IWORK( 3 ) = N + 1 
      IWORK( 4 ) = N + 1 
      IWORK( 5 ) = IL - 1 
      IWORK( 6 ) = IU 
!                                                                       
      CALL DLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,&
&                WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT, &
&                IWORK, W, IBLOCK, IINFO )                         
!                                                                       
      IF( IWORK( 6 ).EQ.IU ) THEN 
            WL = WORK( N+1 ) 
            WLU = WORK( N+3 ) 
            NWL = IWORK( 1 ) 
            WU = WORK( N+4 ) 
            WUL = WORK( N+2 ) 
            NWU = IWORK( 4 ) 
      ELSE 
            WL = WORK( N+2 ) 
            WLU = WORK( N+4 ) 
            NWL = IWORK( 2 ) 
            WU = WORK( N+3 ) 
            WUL = WORK( N+1 ) 
            NWU = IWORK( 3 ) 
      END IF 
!                                                                       
      IF( NWL.LT.0 .OR. NWL.GE.N .OR. NWU.LT.1 .OR. NWU.GT.N ) THEN 
            INFO = 4 
            RETURN 
      END IF 
      ELSE 
!                                                                       
!        RANGE='A' or 'V' -- Set ATOLI                                  
!                                                                       
      TNORM = MAX( ABS( D( 1 ) )+ABS( E( 1 ) ),                      &
&           ABS( D( N ) )+ABS( E( N-1 ) ) )                        
!                                                                       
      DO 30 J = 2, N - 1 
            TNORM = MAX( TNORM, ABS( D( J ) )+ABS( E( J-1 ) )+          &
&              ABS( E( J ) ) )                                     
30    CONTINUE 
!                                                                       
      IF( ABSTOL.LE.ZERO ) THEN 
            ATOLI = ULP*TNORM 
      ELSE 
            ATOLI = ABSTOL 
      END IF 
!                                                                       
      IF( IRANGE.EQ.2 ) THEN 
            WL = VL 
            WU = VU 
      ELSE 
            WL = ZERO 
            WU = ZERO 
      END IF 
      END IF 
!                                                                       
!     Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.   
!     NWL accumulates the number of eigenvalues .le. WL,                
!     NWU accumulates the number of eigenvalues .le. WU                 
!                                                                       
      M = 0 
      IEND = 0 
      INFO = 0 
      NWL = 0 
      NWU = 0 
!                                                                       
      DO 70 JB = 1, NSPLIT 
      IOFF = IEND 
      IBEGIN = IOFF + 1 
      IEND = ISPLIT( JB ) 
      IN = IEND - IOFF 
!                                                                       
      IF( IN.EQ.1 ) THEN 
!                                                                       
!           Special Case -- IN=1                                        
!                                                                       
            IF( IRANGE.EQ.1 .OR. WL.GE.D( IBEGIN )-PIVMIN )             &
&         NWL = NWL + 1                                            
            IF( IRANGE.EQ.1 .OR. WU.GE.D( IBEGIN )-PIVMIN )             &
&         NWU = NWU + 1                                            
            IF( IRANGE.EQ.1 .OR. ( WL.LT.D( IBEGIN )-PIVMIN .AND. WU.GE.&
&          D( IBEGIN )-PIVMIN ) ) THEN                             
            M = M + 1 
            W( M ) = D( IBEGIN ) 
            IBLOCK( M ) = JB 
            END IF 
      ELSE 
!                                                                       
!           General Case -- IN > 1                                      
!                                                                       
!           Compute Gershgorin Interval                                 
!           and use it as the initial interval                          
!                                                                       
            GU = D( IBEGIN ) 
            GL = D( IBEGIN ) 
            TMP1 = ZERO 
!                                                                       
            DO 40 J = IBEGIN, IEND - 1 
            TMP2 = ABS( E( J ) ) 
            GU = MAX( GU, D( J )+TMP1+TMP2 ) 
            GL = MIN( GL, D( J )-TMP1-TMP2 ) 
            TMP1 = TMP2 
40       CONTINUE 
!                                                                       
            GU = MAX( GU, D( IEND )+TMP1 ) 
            GL = MIN( GL, D( IEND )-TMP1 ) 
            BNORM = MAX( ABS( GL ), ABS( GU ) ) 
            GL = GL - FUDGE*BNORM*ULP*IN - FUDGE*PIVMIN 
            GU = GU + FUDGE*BNORM*ULP*IN + FUDGE*PIVMIN 
!                                                                       
!           Compute ATOLI for the current submatrix                     
!                                                                       
            IF( ABSTOL.LE.ZERO ) THEN 
            ATOLI = ULP*MAX( ABS( GL ), ABS( GU ) ) 
            ELSE 
            ATOLI = ABSTOL 
            END IF 
!                                                                       
            IF( IRANGE.GT.1 ) THEN 
            IF( GU.LT.WL ) THEN 
                  NWL = NWL + IN 
                  NWU = NWU + IN 
                  GO TO 70 
            END IF 
            GL = MAX( GL, WL ) 
            GU = MIN( GU, WU ) 
            IF( GL.GE.GU )                                           &
&            GO TO 70                                              
            END IF 
!                                                                       
!           Set Up Initial Interval                                     
!                                                                       
            WORK( N+1 ) = GL 
            WORK( N+IN+1 ) = GU 
            CALL DLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,     &
&                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),      &
&                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,     &
&                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
!                                                                       
            NWL = NWL + IWORK( 1 ) 
            NWU = NWU + IWORK( IN+1 ) 
            IWOFF = M - IWORK( 1 ) 
!                                                                       
!           Compute Eigenvalues                                         
!                                                                       
            ITMAX = INT( ( LOG( GU-GL+PIVMIN )-LOG( PIVMIN ) ) /        &
&              LOG( TWO ) ) + 2                                    
            CALL DLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN, &
&                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),      &
&                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,   &
&                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )        
!                                                                       
!           Copy Eigenvalues Into W and IBLOCK                          
!           Use -JB for block number for unconverged eigenvalues.       
!                                                                       
            DO 60 J = 1, IOUT 
            TMP1 = HALF*( WORK( J+N )+WORK( J+IN+N ) ) 
!                                                                       
!              Flag non-convergence.                                    
!                                                                       
            IF( J.GT.IOUT-IINFO ) THEN 
                  NCNVRG = .TRUE. 
                  IB = -JB 
            ELSE 
                  IB = JB 
            END IF 
            DO 50 JE = IWORK( J ) + 1 + IWOFF,                       &
&                 IWORK( J+IN ) + IWOFF                            
                  W( JE ) = TMP1 
                  IBLOCK( JE ) = IB 
50          CONTINUE 
60       CONTINUE 
!                                                                       
            M = M + IM 
      END IF 
70 END DO 
!                                                                       
!     If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU     
!     If NWL+1 < IL or NWU > IU, discard extra eigenvalues.             
!                                                                       
      IF( IRANGE.EQ.3 ) THEN 
      IM = 0 
      IDISCL = IL - 1 - NWL 
      IDISCU = NWU - IU 
!                                                                       
      IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
            DO 80 JE = 1, M 
            IF( W( JE ).LE.WLU .AND. IDISCL.GT.0 ) THEN 
                  IDISCL = IDISCL - 1 
            ELSE IF( W( JE ).GE.WUL .AND. IDISCU.GT.0 ) THEN 
                  IDISCU = IDISCU - 1 
            ELSE 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
            END IF 
80       CONTINUE 
            M = IM 
      END IF 
      IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN 
!                                                                       
!           Code to deal with effects of bad arithmetic:                
!           Some low eigenvalues to be discarded are not in (WL,WLU],   
!           or high eigenvalues to be discarded are not in (WUL,WU]     
!           so just kill off the smallest IDISCL/largest IDISCU         
!           eigenvalues, by simply finding the smallest/largest         
!           eigenvalue(s).                                              
!                                                                       
!           (If N(w) is monotone non-decreasing, this should never      
!               happen.)                                                
!                                                                       
            IF( IDISCL.GT.0 ) THEN 
            WKILL = WU 
            DO 100 JDISC = 1, IDISCL 
                  IW = 0 
                  DO 90 JE = 1, M 
                  IF( IBLOCK( JE ).NE.0 .AND.                        &
&                   ( W( JE ).LT.WKILL .OR. IW.EQ.0 ) ) THEN       
                        IW = JE 
                        WKILL = W( JE ) 
                  END IF 
90             CONTINUE 
                  IBLOCK( IW ) = 0 
100          CONTINUE 
            END IF 
            IF( IDISCU.GT.0 ) THEN 
!                                                                       
            WKILL = WL 
            DO 120 JDISC = 1, IDISCU 
                  IW = 0 
                  DO 110 JE = 1, M 
                  IF( IBLOCK( JE ).NE.0 .AND.                        &
&                   ( W( JE ).GT.WKILL .OR. IW.EQ.0 ) ) THEN       
                        IW = JE 
                        WKILL = W( JE ) 
                  END IF 
110             CONTINUE 
                  IBLOCK( IW ) = 0 
120          CONTINUE 
            END IF 
            IM = 0 
            DO 130 JE = 1, M 
            IF( IBLOCK( JE ).NE.0 ) THEN 
                  IM = IM + 1 
                  W( IM ) = W( JE ) 
                  IBLOCK( IM ) = IBLOCK( JE ) 
            END IF 
130       CONTINUE 
            M = IM 
      END IF 
      IF( IDISCL.LT.0 .OR. IDISCU.LT.0 ) THEN 
            TOOFEW = .TRUE. 
      END IF 
      END IF 
!                                                                       
!     If ORDER='B', do nothing -- the eigenvalues are already sorted    
!        by block.                                                      
!     If ORDER='E', sort the eigenvalues from smallest to largest       
!                                                                       
      IF( IORDER.EQ.1 .AND. NSPLIT.GT.1 ) THEN 
      DO 150 JE = 1, M - 1 
            IE = 0 
            TMP1 = W( JE ) 
            DO 140 J = JE + 1, M 
            IF( W( J ).LT.TMP1 ) THEN 
                  IE = J 
                  TMP1 = W( J ) 
            END IF 
140       CONTINUE 
!                                                                       
            IF( IE.NE.0 ) THEN 
            ITMP1 = IBLOCK( IE ) 
            W( IE ) = W( JE ) 
            IBLOCK( IE ) = IBLOCK( JE ) 
            W( JE ) = TMP1 
            IBLOCK( JE ) = ITMP1 
            END IF 
150    CONTINUE 
      END IF 
!                                                                       
      INFO = 0 
      IF( NCNVRG )                                                      &
&   INFO = INFO + 1                                                
      IF( TOOFEW )                                                      &
&   INFO = INFO + 2                                                
      RETURN 
!                                                                       
!     End of DSTEBZ                                                     
!                                                                       
      END                                           
!> \brief \b DSTEIN                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSTEIN + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK, 
!                          IWORK, IFAIL, INFO )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, LDZ, M, N                              
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),        
!      $                   IWORK( * )                                   
!       DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSTEIN computes the eigenvectors of a real symmetric tridiagonal     
!> matrix T corresponding to specified eigenvalues, using inverse       
!> iteration.                                                           
!>                                                                      
!> The maximum number of iterations allowed for each eigenvector is     
!> specified by an internal parameter MAXITS (currently set to 5).      
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] D                                                         
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The n diagonal elements of the tridiagonal matrix T.        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] E                                                         
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The (n-1) subdiagonal elements of the tridiagonal matrix    
!>          T, in elements 1 to N-1.                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of eigenvectors to be found.  0 <= M <= N.       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] W                                                         
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          The first M elements of W contain the eigenvalues for       
!>          which eigenvectors are to be computed.  The eigenvalues     
!>          should be grouped by split-off block and ordered from       
!>          smallest to largest within the block.  ( The output array   
!>          W from DSTEBZ with ORDER = 'B' is expected here. )          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IBLOCK                                                    
!> \verbatim                                                            
!>          IBLOCK is INTEGER array, dimension (N)                      
!>          The submatrix indices associated with the corresponding     
!>          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to 
!>          the first submatrix from the top, =2 if W(i) belongs to     
!>          the second submatrix, etc.  ( The output array IBLOCK       
!>          from DSTEBZ is expected here. )                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ISPLIT                                                    
!> \verbatim                                                            
!>          ISPLIT is INTEGER array, dimension (N)                      
!>          The splitting points, at which T breaks up into submatrices.
!>          The first submatrix consists of rows/columns 1 to           
!>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1       
!>          through ISPLIT( 2 ), etc.                                   
!>          ( The output array ISPLIT from DSTEBZ is expected here. )   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension (LDZ, M)             
!>          The computed eigenvectors.  The eigenvector associated      
!>          with the eigenvalue W(i) is stored in the i-th column of    
!>          Z.  Any vector which fails to converge is set to its current
!>          iterate after MAXITS iterations.                            
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (5*N)             
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (N)                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IFAIL                                                    
!> \verbatim                                                            
!>          IFAIL is INTEGER array, dimension (M)                       
!>          On normal exit, all elements of IFAIL are zero.             
!>          If one or more eigenvectors fail to converge after          
!>          MAXITS iterations, then their indices are stored in         
!>          array IFAIL.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0: successful exit.                                       
!>          < 0: if INFO = -i, the i-th argument had an illegal value   
!>          > 0: if INFO = i, then i eigenvectors failed to converge    
!>               in MAXITS iterations.  Their indices are stored in     
!>               array IFAIL.                                           
!> \endverbatim                                                         
!                                                                       
!> \par Internal Parameters:                                            
!  =========================                                            
!>                                                                      
!> \verbatim                                                            
!>  MAXITS  INTEGER, default = 5                                        
!>          The maximum number of iterations performed.                 
!>                                                                      
!>  EXTRA   INTEGER, default = 2                                        
!>          The number of iterations performed after norm growth        
!>          criterion is satisfied, should be at least 1.               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!  =====================================================================
      SUBROUTINE DSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK,   &
&                   IWORK, IFAIL, INFO )                           
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDZ, M, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),          &
&                   IWORK( * )                                     
      DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TEN, ODM3, ODM1 
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TEN = 1.0D+1,   &
&                   ODM3 = 1.0D-3, ODM1 = 1.0D-1 )                 
      INTEGER            MAXITS, EXTRA 
      PARAMETER          ( MAXITS = 5, EXTRA = 2 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            B1, BLKSIZ, BN, GPIND, I, IINFO, INDRV1,       &
&                   INDRV2, INDRV3, INDRV4, INDRV5, ITS, J, J1,    &
&                   JBLK, JMAX, NBLK, NRMCHK                       
      DOUBLE PRECISION   DTPCRT, EPS, EPS1, NRM, ONENRM, ORTOL, PERTOL, &
&                   SCL, SEP, TOL, XJ, XJM, ZTR                    
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            ISEED( 4 ) 
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            IDAMAX 
      DOUBLE PRECISION   DDOT, DLAMCH, DNRM2 
      EXTERNAL           IDAMAX, DDOT, DLAMCH, DNRM2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DAXPY, DCOPY, DLAGTF, DLAGTS, DLARNV, DSCAL,   &
&                   XERBLA                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      DO 10 I = 1, M 
      IFAIL( I ) = 0 
10 END DO 
!                                                                       
      IF( N.LT.0 ) THEN 
      INFO = -1 
      ELSE IF( M.LT.0 .OR. M.GT.N ) THEN 
      INFO = -4 
      ELSE IF( LDZ.LT.MAX( 1, N ) ) THEN 
      INFO = -9 
      ELSE 
      DO 20 J = 2, M 
            IF( IBLOCK( J ).LT.IBLOCK( J-1 ) ) THEN 
            INFO = -6 
            GO TO 30 
            END IF 
            IF( IBLOCK( J ).EQ.IBLOCK( J-1 ) .AND. W( J ).LT.W( J-1 ) ) &
&           THEN                                                   
            INFO = -5 
            GO TO 30 
            END IF 
20    CONTINUE 
30    CONTINUE 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DSTEIN', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 ) THEN 
      RETURN 
      ELSE IF( N.EQ.1 ) THEN 
      Z( 1, 1 ) = ONE 
      RETURN 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      EPS = DLAMCH( 'Precision' ) 
!                                                                       
!     Initialize seed for random number generator DLARNV.               
!                                                                       
      DO 40 I = 1, 4 
      ISEED( I ) = 1 
40 END DO 
!                                                                       
!     Initialize pointers.                                              
!                                                                       
      INDRV1 = 0 
      INDRV2 = INDRV1 + N 
      INDRV3 = INDRV2 + N 
      INDRV4 = INDRV3 + N 
      INDRV5 = INDRV4 + N 
!                                                                       
!     Compute eigenvectors of matrix blocks.                            
!                                                                       
      J1 = 1 
      DO 160 NBLK = 1, IBLOCK( M ) 
!                                                                       
!        Find starting and ending indices of block nblk.                
!                                                                       
      IF( NBLK.EQ.1 ) THEN 
            B1 = 1 
      ELSE 
            B1 = ISPLIT( NBLK-1 ) + 1 
      END IF 
      BN = ISPLIT( NBLK ) 
      BLKSIZ = BN - B1 + 1 
      IF( BLKSIZ.EQ.1 )                                              &
&      GO TO 60                                                    
      GPIND = J1 
!                                                                       
!        Compute reorthogonalization criterion and stopping criterion.  
!                                                                       
      ONENRM = ABS( D( B1 ) ) + ABS( E( B1 ) ) 
      ONENRM = MAX( ONENRM, ABS( D( BN ) )+ABS( E( BN-1 ) ) ) 
      DO 50 I = B1 + 1, BN - 1 
            ONENRM = MAX( ONENRM, ABS( D( I ) )+ABS( E( I-1 ) )+        &
&               ABS( E( I ) ) )                                    
50    CONTINUE 
      ORTOL = ODM3*ONENRM 
!                                                                       
      DTPCRT = SQRT( ODM1 / BLKSIZ ) 
!                                                                       
!        Loop through eigenvalues of block nblk.                        
!                                                                       
60    CONTINUE 
      JBLK = 0 
      DO 150 J = J1, M 
            IF( IBLOCK( J ).NE.NBLK ) THEN 
            J1 = J 
            GO TO 160 
            END IF 
            JBLK = JBLK + 1 
            XJ = W( J ) 
!                                                                       
!           Skip all the work if the block size is one.                 
!                                                                       
            IF( BLKSIZ.EQ.1 ) THEN 
            WORK( INDRV1+1 ) = ONE 
            GO TO 120 
            END IF 
!                                                                       
!           If eigenvalues j and j-1 are too close, add a relatively    
!           small perturbation.                                         
!                                                                       
            IF( JBLK.GT.1 ) THEN 
            EPS1 = ABS( EPS*XJ ) 
            PERTOL = TEN*EPS1 
            SEP = XJ - XJM 
            IF( SEP.LT.PERTOL )                                      &
&            XJ = XJM + PERTOL                                     
            END IF 
!                                                                       
            ITS = 0 
            NRMCHK = 0 
!                                                                       
!           Get random starting vector.                                 
!                                                                       
            CALL DLARNV( 2, ISEED, BLKSIZ, WORK( INDRV1+1 ) ) 
!                                                                       
!           Copy the matrix T so it won't be destroyed in factorization.
!                                                                       
            CALL DCOPY( BLKSIZ, D( B1 ), 1, WORK( INDRV4+1 ), 1 ) 
            CALL DCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV2+2 ), 1 ) 
            CALL DCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV3+1 ), 1 ) 
!                                                                       
!           Compute LU factors with partial pivoting  ( PT = LU )       
!                                                                       
            TOL = ZERO 
            CALL DLAGTF( BLKSIZ, WORK( INDRV4+1 ), XJ, WORK( INDRV2+2 ),&
&                   WORK( INDRV3+1 ), TOL, WORK( INDRV5+1 ), IWORK,&
&                   IINFO )                                        
!                                                                       
!           Update iteration count.                                     
!                                                                       
70       CONTINUE 
            ITS = ITS + 1 
            IF( ITS.GT.MAXITS )                                         &
&         GO TO 100                                                
!                                                                       
!           Normalize and scale the righthand side vector Pb.           
!                                                                       
            JMAX = IDAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            SCL = BLKSIZ*ONENRM*MAX( EPS,                               &
&            ABS( WORK( INDRV4+BLKSIZ ) ) ) /                      &
&            ABS( WORK( INDRV1+JMAX ) )                            
            CALL DSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 ) 
!                                                                       
!           Solve the system LU = Pb.                                   
!                                                                       
            CALL DLAGTS( -1, BLKSIZ, WORK( INDRV4+1 ), WORK( INDRV2+2 ),&
&                   WORK( INDRV3+1 ), WORK( INDRV5+1 ), IWORK,     &
&                   WORK( INDRV1+1 ), TOL, IINFO )                 
!                                                                       
!           Reorthogonalize by modified Gram-Schmidt if eigenvalues are 
!           close enough.                                               
!                                                                       
            IF( JBLK.EQ.1 )                                             &
&         GO TO 90                                                 
            IF( ABS( XJ-XJM ).GT.ORTOL )                                &
&         GPIND = J                                                
            IF( GPIND.NE.J ) THEN 
            DO 80 I = GPIND, J - 1 
                  ZTR = -DDOT( BLKSIZ, WORK( INDRV1+1 ), 1, Z( B1, I ), &
&                  1 )                                             
                  CALL DAXPY( BLKSIZ, ZTR, Z( B1, I ), 1,               &
&                        WORK( INDRV1+1 ), 1 )                     
80          CONTINUE 
            END IF 
!                                                                       
!           Check the infinity norm of the iterate.                     
!                                                                       
90       CONTINUE 
            JMAX = IDAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            NRM = ABS( WORK( INDRV1+JMAX ) ) 
!                                                                       
!           Continue for additional iterations after norm reaches       
!           stopping criterion.                                         
!                                                                       
            IF( NRM.LT.DTPCRT )                                         &
&         GO TO 70                                                 
            NRMCHK = NRMCHK + 1 
            IF( NRMCHK.LT.EXTRA+1 )                                     &
&         GO TO 70                                                 
!                                                                       
            GO TO 110 
!                                                                       
!           If stopping criterion was not satisfied, update info and    
!           store eigenvector number in array ifail.                    
!                                                                       
100       CONTINUE 
            INFO = INFO + 1 
            IFAIL( INFO ) = J 
!                                                                       
!           Accept iterate as jth eigenvector.                          
!                                                                       
110       CONTINUE 
            SCL = ONE / DNRM2( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            JMAX = IDAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 ) 
            IF( WORK( INDRV1+JMAX ).LT.ZERO )                           &
&         SCL = -SCL                                               
            CALL DSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 ) 
120       CONTINUE 
            DO 130 I = 1, N 
            Z( I, J ) = ZERO 
130       CONTINUE 
            DO 140 I = 1, BLKSIZ 
            Z( B1+I-1, J ) = WORK( INDRV1+I ) 
140       CONTINUE 
!                                                                       
!           Save the shift to check eigenvalue spacing at next          
!           iteration.                                                  
!                                                                       
            XJM = XJ 
!                                                                       
150    CONTINUE 
160 END DO 
!                                                                       
      RETURN 
!                                                                       
!     End of DSTEIN                                                     
!                                                                       
!> \brief \b DSTEMR                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSTEMR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSTEMR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU,        
!                          M, W, Z, LDZ, NZC, ISUPPZ, TRYRAC, WORK, LWOR
!                          IWORK, LIWORK, INFO )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBZ, RANGE                                  
!       LOGICAL            TRYRAC                                       
!       INTEGER            IL, INFO, IU, LDZ, NZC, LIWORK, LWORK, M, N  
!       DOUBLE PRECISION VL, VU                                         
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * ), IWORK( * )                      
!       DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * )            
!       DOUBLE PRECISION   Z( LDZ, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSTEMR computes selected eigenvalues and, optionally, eigenvectors   
!> of a real symmetric tridiagonal matrix T. Any such unreduced matrix h
!> a well defined set of pairwise different real eigenvalues, the corres
!> real eigenvectors are pairwise orthogonal.                           
!>                                                                      
!> The spectrum may be computed either completely or partially by specif
!> either an interval (VL,VU] or a range of indices IL:IU for the desire
!> eigenvalues.                                                         
!>                                                                      
!> Depending on the number of desired eigenvalues, these are computed ei
!> by bisection or the dqds algorithm. Numerically orthogonal eigenvecto
!> computed by the use of various suitable L D L^T factorizations near c
!> of close eigenvalues (referred to as RRRs, Relatively Robust         
!> Representations). An informal sketch of the algorithm follows.       
!>                                                                      
!> For each unreduced block (submatrix) of T,                           
!>    (a) Compute T - sigma I  = L D L^T, so that L and D               
!>        define all the wanted eigenvalues to high relative accuracy.  
!>        This means that small relative changes in the entries of D and
!>        cause only small relative changes in the eigenvalues and      
!>        eigenvectors. The standard (unfactored) representation of the 
!>        tridiagonal matrix T does not have this property in general.  
!>    (b) Compute the eigenvalues to suitable accuracy.                 
!>        If the eigenvectors are desired, the algorithm attains full   
!>        accuracy of the computed eigenvalues only right before        
!>        the corresponding vectors have to be computed, see steps c) an
!>    (c) For each cluster of close eigenvalues, select a new           
!>        shift close to the cluster, find a new factorization, and refi
!>        the shifted eigenvalues to suitable accuracy.                 
!>    (d) For each eigenvalue with a large enough relative separation co
!>        the corresponding eigenvector by forming a rank revealing twis
!>        factorization. Go back to (c) for any clusters that remain.   
!>                                                                      
!> For more details, see:                                               
!> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representat
!>   to compute orthogonal eigenvectors of symmetric tridiagonal matrice
!>   Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
!> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors an
!>   Relative Gaps," SIAM Journal on Matrix Analysis and Applications, V
!>   2004.  Also LAPACK Working Note 154.                               
!> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric        
!>   tridiagonal eigenvalue/eigenvector problem",                       
!>   Computer Science Division Technical Report No. UCB/CSD-97-971,     
!>   UC Berkeley, May 1997.                                             
!>                                                                      
!> Further Details                                                      
!> 1.DSTEMR works only on machines which follow IEEE-754                
!> floating-point standard in their handling of infinities and NaNs.    
!> This permits the use of efficient inner loops avoiding a check for   
!> zero divisors.                                                       
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBZ                                                      
!> \verbatim                                                            
!>          JOBZ is CHARACTER*1                                         
!>          = 'N':  Compute eigenvalues only;                           
!>          = 'V':  Compute eigenvalues and eigenvectors.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': all eigenvalues will be found.                       
!>          = 'V': all eigenvalues in the half-open interval (VL,VU]    
!>                 will be found.                                       
!>          = 'I': the IL-th through IU-th eigenvalues will be found.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the N diagonal elements of the tridiagonal matrix 
!>          T. On exit, D is overwritten.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the (N-1) subdiagonal elements of the tridiagonal 
!>          matrix T in elements 1 to N-1 of E. E(N) need not be set on 
!>          input, but is used internally as workspace.                 
!>          On exit, E is overwritten.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>                                                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>                                                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0.                               
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>                                                                      
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0.                               
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues found.  0 <= M <= N.        
!>          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          The first M elements contain the selected eigenvalues in    
!>          ascending order.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M) )     
!>          If JOBZ = 'V', and if INFO = 0, then the first M columns of 
!>          contain the orthonormal eigenvectors of the matrix T        
!>          corresponding to the selected eigenvalues, with the i-th    
!>          column of Z holding the eigenvector associated with W(i).   
!>          If JOBZ = 'N', then Z is not referenced.                    
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z; if RANGE = 'V', the exact value of 
!>          is not known in advance and can be computed with a workspace
!>          query by setting NZC = -1, see below.                       
!> \endverbatim                                                         
!>                                                                      
      END                                           
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', then LDZ >= max(1,N).                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NZC                                                       
!> \verbatim                                                            
!>          NZC is INTEGER                                              
!>          The number of eigenvectors to be held in the array Z.       
!>          If RANGE = 'A', then NZC >= max(1,N).                       
!>          If RANGE = 'V', then NZC >= the number of eigenvalues in (VL
!>          If RANGE = 'I', then NZC >= IU-IL+1.                        
!>          If NZC = -1, then a workspace query is assumed; the         
!>          routine calculates the number of columns of the array Z that
!>          are needed to hold the eigenvectors.                        
!>          This value is returned as the first entry of the Z array, an
!>          no error message related to NZC is issued by XERBLA.        
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The i-th computed eige
!>          is nonzero only in elements ISUPPZ( 2*i-1 ) through         
!>          ISUPPZ( 2*i ). This is relevant in the case when the matrix 
!>          is split. ISUPPZ is only accessed when JOBZ is 'V' and N > 0
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] TRYRAC                                                
!> \verbatim                                                            
!>          TRYRAC is LOGICAL                                           
!>          If TRYRAC = .TRUE., indicates that the code should check whe
!>          the tridiagonal matrix defines its eigenvalues to high relat
!>          accuracy.  If so, the code uses relative-accuracy preserving
!>          algorithms that might be (a bit) slower depending on the mat
!>          If the matrix does not define its eigenvalues to high relati
!>          accuracy, the code can uses possibly faster algorithms.     
!>          If TRYRAC = .FALSE., the code is not required to guarantee  
!>          relatively accurate eigenvalues and can use the fastest poss
!>          techniques.                                                 
!>          On exit, a .TRUE. TRYRAC will be set to .FALSE. if the matri
!>          does not define its eigenvalues to high relative accuracy.  
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (LWORK)           
!>          On exit, if INFO = 0, WORK(1) returns the optimal           
!>          (and minimal) LWORK.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK. LWORK >= max(1,18*N)       
!>          if JOBZ = 'V', and LWORK >= max(1,12*N) if JOBZ = 'N'.      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (LIWORK)                  
!>          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LIWORK                                                    
!> \verbatim                                                            
!>          LIWORK is INTEGER                                           
!>          The dimension of the array IWORK.  LIWORK >= max(1,10*N)    
!>          if the eigenvectors are desired, and LIWORK >= max(1,8*N)   
!>          if only the eigenvalues are to be computed.                 
!>          If LIWORK = -1, then a workspace query is assumed; the      
!>          routine only calculates the optimal size of the IWORK array,
!>          returns this value as the first entry of the IWORK array, an
!>          no error message related to LIWORK is issued by XERBLA.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          On exit, INFO                                               
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  if INFO = 1X, internal error in DLARRE,               
!>                if INFO = 2X, internal error in DLARRV.               
!>                Here, the digit X = ABS( IINFO ) < 10, where IINFO is 
!>                the nonzero error code returned by DLARRE or          
!>                DLARRV, respectively.                                 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup doubleOTHERcomputational                                    
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!> Beresford Parlett, University of California, Berkeley, USA \n        
!> Jim Demmel, University of California, Berkeley, USA \n               
!> Inderjit Dhillon, University of Texas, Austin, USA \n                
!> Osni Marques, LBNL/NERSC, USA \n                                     
!> Christof Voemel, University of California, Berkeley, USA             
!                                                                       
!  =====================================================================
      SUBROUTINE DSTEMR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU,          &
&                   M, W, Z, LDZ, NZC, ISUPPZ, TRYRAC, WORK, LWORK,&
&                   IWORK, LIWORK, INFO )                          
!                                                                       
!  -- LAPACK computational routine (version 3.7.1) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBZ, RANGE 
      LOGICAL            TRYRAC 
      INTEGER            IL, INFO, IU, LDZ, NZC, LIWORK, LWORK, M, N 
      DOUBLE PRECISION VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ), IWORK( * ) 
      DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ) 
      DOUBLE PRECISION   Z( LDZ, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, FOUR, MINRGP 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0,                   &
&                     FOUR = 4.0D0,                                &
&                     MINRGP = 1.0D-3 )                            
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ALLEIG, INDEIG, LQUERY, VALEIG, WANTZ, ZQUERY 
      INTEGER            I, IBEGIN, IEND, IFIRST, IIL, IINDBL, IINDW,   &
&                   IINDWK, IINFO, IINSPL, IIU, ILAST, IN, INDD,   &
&                   INDE2, INDERR, INDGP, INDGRS, INDWRK, ITMP,    &
&                   ITMP2, J, JBLK, JJ, LIWMIN, LWMIN, NSPLIT,     &
&                   NZCMIN, OFFSET, WBEGIN, WEND                   
      DOUBLE PRECISION   BIGNUM, CS, EPS, PIVMIN, R1, R2, RMAX, RMIN,   &
&                   RTOL1, RTOL2, SAFMIN, SCALE, SMLNUM, SN,       &
&                   THRESH, TMP, TNRM, WL, WU                      
!     ..                                                                
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      DOUBLE PRECISION   DLAMCH, DLANST 
      EXTERNAL           LSAME, DLAMCH, DLANST 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY, DLAE2, DLAEV2, DLARRC, DLARRE, DLARRJ,  &
&                   DLARRR, DLARRV, DLASRT, DSCAL, DSWAP, XERBLA   
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
                                                                        
                                                                        
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      WANTZ = LSAME( JOBZ, 'V' ) 
      ALLEIG = LSAME( RANGE, 'A' ) 
      VALEIG = LSAME( RANGE, 'V' ) 
      INDEIG = LSAME( RANGE, 'I' ) 
!                                                                       
      LQUERY = ( ( LWORK.EQ.-1 ).OR.( LIWORK.EQ.-1 ) ) 
      ZQUERY = ( NZC.EQ.-1 ) 
                                                                        
!     DSTEMR needs WORK of size 6*N, IWORK of size 3*N.                 
!     In addition, DLARRE needs WORK of size 6*N, IWORK of size 5*N.    
!     Furthermore, DLARRV needs WORK of size 12*N, IWORK of size 7*N.   
      IF( WANTZ ) THEN 
      LWMIN = 18*N 
      LIWMIN = 10*N 
      ELSE 
!        need less workspace if only the eigenvalues are wanted         
      LWMIN = 12*N 
      LIWMIN = 8*N 
      ENDIF 
                                                                        
      WL = ZERO 
      WU = ZERO 
      IIL = 0 
      IIU = 0 
      NSPLIT = 0 
                                                                        
      IF( VALEIG ) THEN 
!        We do not reference VL, VU in the cases RANGE = 'I','A'        
!        The interval (WL, WU] contains all the wanted eigenvalues.     
!        It is either given by the user or computed in DLARRE.          
      WL = VL 
      WU = VU 
      ELSEIF( INDEIG ) THEN 
!        We do not reference IL, IU in the cases RANGE = 'V','A'        
      IIL = IL 
      IIU = IU 
      ENDIF 
!                                                                       
      INFO = 0 
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN 
      INFO = -2 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -3 
      ELSE IF( VALEIG .AND. N.GT.0 .AND. WU.LE.WL ) THEN 
      INFO = -7 
      ELSE IF( INDEIG .AND. ( IIL.LT.1 .OR. IIL.GT.N ) ) THEN 
      INFO = -8 
      ELSE IF( INDEIG .AND. ( IIU.LT.IIL .OR. IIU.GT.N ) ) THEN 
      INFO = -9 
      ELSE IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN 
      INFO = -13 
      ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN 
      INFO = -17 
      ELSE IF( LIWORK.LT.LIWMIN .AND. .NOT.LQUERY ) THEN 
      INFO = -19 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      SAFMIN = DLAMCH( 'Safe minimum' ) 
      EPS = DLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      BIGNUM = ONE / SMLNUM 
      RMIN = SQRT( SMLNUM ) 
      RMAX = MIN( SQRT( BIGNUM ), ONE / SQRT( SQRT( SAFMIN ) ) ) 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
      WORK( 1 ) = LWMIN 
      IWORK( 1 ) = LIWMIN 
!                                                                       
      IF( WANTZ .AND. ALLEIG ) THEN 
            NZCMIN = N 
      ELSE IF( WANTZ .AND. VALEIG ) THEN 
            CALL DLARRC( 'T', N, VL, VU, D, E, SAFMIN,                  &
&                            NZCMIN, ITMP, ITMP2, INFO )           
      ELSE IF( WANTZ .AND. INDEIG ) THEN 
            NZCMIN = IIU-IIL+1 
      ELSE 
!           WANTZ .EQ. FALSE.                                           
            NZCMIN = 0 
      ENDIF 
      IF( ZQUERY .AND. INFO.EQ.0 ) THEN 
            Z( 1,1 ) = NZCMIN 
      ELSE IF( NZC.LT.NZCMIN .AND. .NOT.ZQUERY ) THEN 
            INFO = -14 
      END IF 
      END IF 
                                                                        
      IF( INFO.NE.0 ) THEN 
!                                                                       
      CALL XERBLA( 'DSTEMR', -INFO ) 
!                                                                       
      RETURN 
      ELSE IF( LQUERY .OR. ZQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Handle N = 0, 1, and 2 cases immediately                          
!                                                                       
      M = 0 
      IF( N.EQ.0 )                                                      &
&   RETURN                                                         
!                                                                       
      IF( N.EQ.1 ) THEN 
      IF( ALLEIG .OR. INDEIG ) THEN 
            M = 1 
            W( 1 ) = D( 1 ) 
      ELSE 
            IF( WL.LT.D( 1 ) .AND. WU.GE.D( 1 ) ) THEN 
            M = 1 
            W( 1 ) = D( 1 ) 
            END IF 
      END IF 
      IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            Z( 1, 1 ) = ONE 
            ISUPPZ(1) = 1 
            ISUPPZ(2) = 1 
      END IF 
      RETURN 
      END IF 
!                                                                       
      IF( N.EQ.2 ) THEN 
      IF( .NOT.WANTZ ) THEN 
            CALL DLAE2( D(1), E(1), D(2), R1, R2 ) 
      ELSE IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            CALL DLAEV2( D(1), E(1), D(2), R1, R2, CS, SN ) 
      END IF 
      IF( ALLEIG.OR.                                                 &
&      (VALEIG.AND.(R2.GT.WL).AND.                                 &
&                  (R2.LE.WU)).OR.                                 &
&      (INDEIG.AND.(IIL.EQ.1)) ) THEN                              
            M = M+1 
            W( M ) = R2 
            IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            Z( 1, M ) = -SN 
            Z( 2, M ) = CS 
!              Note: At most one of SN and CS can be zero.              
            IF (SN.NE.ZERO) THEN 
                  IF (CS.NE.ZERO) THEN 
                  ISUPPZ(2*M-1) = 1 
                  ISUPPZ(2*M) = 2 
                  ELSE 
                  ISUPPZ(2*M-1) = 1 
                  ISUPPZ(2*M) = 1 
                  END IF 
            ELSE 
                  ISUPPZ(2*M-1) = 2 
                  ISUPPZ(2*M) = 2 
            END IF 
            ENDIF 
      ENDIF 
      IF( ALLEIG.OR.                                                 &
&      (VALEIG.AND.(R1.GT.WL).AND.                                 &
&                  (R1.LE.WU)).OR.                                 &
&      (INDEIG.AND.(IIU.EQ.2)) ) THEN                              
            M = M+1 
            W( M ) = R1 
            IF( WANTZ.AND.(.NOT.ZQUERY) ) THEN 
            Z( 1, M ) = CS 
            Z( 2, M ) = SN 
!              Note: At most one of SN and CS can be zero.              
            IF (SN.NE.ZERO) THEN 
                  IF (CS.NE.ZERO) THEN 
                  ISUPPZ(2*M-1) = 1 
                  ISUPPZ(2*M) = 2 
                  ELSE 
                  ISUPPZ(2*M-1) = 1 
                  ISUPPZ(2*M) = 1 
                  END IF 
            ELSE 
                  ISUPPZ(2*M-1) = 2 
                  ISUPPZ(2*M) = 2 
            END IF 
            ENDIF 
      ENDIF 
                                                                        
      ELSE 
                                                                        
!     Continue with general N                                           
                                                                        
      INDGRS = 1 
      INDERR = 2*N + 1 
      INDGP = 3*N + 1 
      INDD = 4*N + 1 
      INDE2 = 5*N + 1 
      INDWRK = 6*N + 1 
!                                                                       
      IINSPL = 1 
      IINDBL = N + 1 
      IINDW = 2*N + 1 
      IINDWK = 3*N + 1 
!                                                                       
!        Scale matrix to allowable range, if necessary.                 
!        The allowable range is related to the PIVMIN parameter; see the
!        comments in DLARRD.  The preference for scaling small values   
!        up is heuristic; we expect users' matrices not to be close to t
!        RMAX threshold.                                                
!                                                                       
      SCALE = ONE 
      TNRM = DLANST( 'M', N, D, E ) 
      IF( TNRM.GT.ZERO .AND. TNRM.LT.RMIN ) THEN 
            SCALE = RMIN / TNRM 
      ELSE IF( TNRM.GT.RMAX ) THEN 
            SCALE = RMAX / TNRM 
      END IF 
      IF( SCALE.NE.ONE ) THEN 
            CALL DSCAL( N, SCALE, D, 1 ) 
            CALL DSCAL( N-1, SCALE, E, 1 ) 
            TNRM = TNRM*SCALE 
            IF( VALEIG ) THEN 
!              If eigenvalues in interval have to be found,             
!              scale (WL, WU] accordingly                               
            WL = WL*SCALE 
            WU = WU*SCALE 
            ENDIF 
      END IF 
!                                                                       
!        Compute the desired eigenvalues of the tridiagonal after splitt
!        into smaller subblocks if the corresponding off-diagonal elemen
!        are small                                                      
!        THRESH is the splitting parameter for DLARRE                   
!        A negative THRESH forces the old splitting criterion based on t
!        size of the off-diagonal. A positive THRESH switches to splitti
!        which preserves relative accuracy.                             
!                                                                       
      IF( TRYRAC ) THEN 
!           Test whether the matrix warrants the more expensive relative
            CALL DLARRR( N, D, E, IINFO ) 
      ELSE 
!           The user does not care about relative accurately eigenvalues
            IINFO = -1 
      ENDIF 
!        Set the splitting criterion                                    
      IF (IINFO.EQ.0) THEN 
            THRESH = EPS 
      ELSE 
            THRESH = -EPS 
!           relative accuracy is desired but T does not guarantee it    
            TRYRAC = .FALSE. 
      ENDIF 
!                                                                       
      IF( TRYRAC ) THEN 
!           Copy original diagonal, needed to guarantee relative accurac
            CALL DCOPY(N,D,1,WORK(INDD),1) 
      ENDIF 
!        Store the squares of the offdiagonal values of T               
      DO 5 J = 1, N-1 
            WORK( INDE2+J-1 ) = E(J)**2 
5    CONTINUE 
                                                                        
!        Set the tolerance parameters for bisection                     
      IF( .NOT.WANTZ ) THEN 
!           DLARRE computes the eigenvalues to full precision.          
            RTOL1 = FOUR * EPS 
            RTOL2 = FOUR * EPS 
      ELSE 
!           DLARRE computes the eigenvalues to less than full precision.
!           DLARRV will refine the eigenvalue approximations, and we can
!           need less accurate initial bisection in DLARRE.             
!           Note: these settings do only affect the subset case and DLAR
            RTOL1 = SQRT(EPS) 
            RTOL2 = MAX( SQRT(EPS)*5.0D-3, FOUR * EPS ) 
      ENDIF 
      CALL DLARRE( RANGE, N, WL, WU, IIL, IIU, D, E,                 &
&             WORK(INDE2), RTOL1, RTOL2, THRESH, NSPLIT,           &
&             IWORK( IINSPL ), M, W, WORK( INDERR ),               &
&             WORK( INDGP ), IWORK( IINDBL ),                      &
&             IWORK( IINDW ), WORK( INDGRS ), PIVMIN,              &
&             WORK( INDWRK ), IWORK( IINDWK ), IINFO )             
      IF( IINFO.NE.0 ) THEN 
            INFO = 10 + ABS( IINFO ) 
            RETURN 
      END IF 
!        Note that if RANGE .NE. 'V', DLARRE computes bounds on the desi
!        part of the spectrum. All desired eigenvalues are contained in 
!        (WL,WU]                                                        
                                                                        
                                                                        
      IF( WANTZ ) THEN 
!                                                                       
!           Compute the desired eigenvectors corresponding to the comput
!           eigenvalues                                                 
!                                                                       
            CALL DLARRV( N, WL, WU, D, E,                               &
&                PIVMIN, IWORK( IINSPL ), M,                       &
&                1, M, MINRGP, RTOL1, RTOL2,                       &
&                W, WORK( INDERR ), WORK( INDGP ), IWORK( IINDBL ),&
&                IWORK( IINDW ), WORK( INDGRS ), Z, LDZ,           &
&                ISUPPZ, WORK( INDWRK ), IWORK( IINDWK ), IINFO )  
            IF( IINFO.NE.0 ) THEN 
            INFO = 20 + ABS( IINFO ) 
            RETURN 
            END IF 
      ELSE 
!           DLARRE computes eigenvalues of the (shifted) root representa
!           DLARRV returns the eigenvalues of the unshifted matrix.     
!           However, if the eigenvectors are not desired by the user, we
!           to apply the corresponding shifts from DLARRE to obtain the 
!           eigenvalues of the original matrix.                         
            DO 20 J = 1, M 
            ITMP = IWORK( IINDBL+J-1 ) 
            W( J ) = W( J ) + E( IWORK( IINSPL+ITMP-1 ) ) 
20       CONTINUE 
      END IF 
!                                                                       
                                                                        
      IF ( TRYRAC ) THEN 
!           Refine computed eigenvalues so that they are relatively accu
!           with respect to the original matrix T.                      
            IBEGIN = 1 
            WBEGIN = 1 
            DO 39  JBLK = 1, IWORK( IINDBL+M-1 ) 
            IEND = IWORK( IINSPL+JBLK-1 ) 
            IN = IEND - IBEGIN + 1 
            WEND = WBEGIN - 1 
!              check if any eigenvalues have to be refined in this block
36          CONTINUE 
            IF( WEND.LT.M ) THEN 
                  IF( IWORK( IINDBL+WEND ).EQ.JBLK ) THEN 
                  WEND = WEND + 1 
                  GO TO 36 
                  END IF 
            END IF 
            IF( WEND.LT.WBEGIN ) THEN 
                  IBEGIN = IEND + 1 
                  GO TO 39 
            END IF 
                                                                        
            OFFSET = IWORK(IINDW+WBEGIN-1)-1 
            IFIRST = IWORK(IINDW+WBEGIN-1) 
            ILAST = IWORK(IINDW+WEND-1) 
            RTOL2 = FOUR * EPS 
            CALL DLARRJ( IN,                                         &
&                   WORK(INDD+IBEGIN-1), WORK(INDE2+IBEGIN-1),     &
&                   IFIRST, ILAST, RTOL2, OFFSET, W(WBEGIN),       &
&                   WORK( INDERR+WBEGIN-1 ),                       &
&                   WORK( INDWRK ), IWORK( IINDWK ), PIVMIN,       &
&                   TNRM, IINFO )                                  
            IBEGIN = IEND + 1 
            WBEGIN = WEND + 1 
39       CONTINUE 
      ENDIF 
!                                                                       
!        If matrix was scaled, then rescale eigenvalues appropriately.  
!                                                                       
      IF( SCALE.NE.ONE ) THEN 
            CALL DSCAL( M, ONE / SCALE, W, 1 ) 
      END IF 
                                                                        
      END IF 
                                                                        
!                                                                       
!     If eigenvalues are not in increasing order, then sort them,       
!     possibly along with eigenvectors.                                 
!                                                                       
      IF( NSPLIT.GT.1 .OR. N.EQ.2 ) THEN 
      IF( .NOT. WANTZ ) THEN 
            CALL DLASRT( 'I', M, W, IINFO ) 
            IF( IINFO.NE.0 ) THEN 
            INFO = 3 
            RETURN 
            END IF 
      ELSE 
            DO 60 J = 1, M - 1 
            I = 0 
            TMP = W( J ) 
            DO 50 JJ = J + 1, M 
                  IF( W( JJ ).LT.TMP ) THEN 
                  I = JJ 
                  TMP = W( JJ ) 
                  END IF 
50          CONTINUE 
            IF( I.NE.0 ) THEN 
                  W( I ) = W( J ) 
                  W( J ) = TMP 
                  IF( WANTZ ) THEN 
                  CALL DSWAP( N, Z( 1, I ), 1, Z( 1, J ), 1 ) 
                  ITMP = ISUPPZ( 2*I-1 ) 
                  ISUPPZ( 2*I-1 ) = ISUPPZ( 2*J-1 ) 
                  ISUPPZ( 2*J-1 ) = ITMP 
                  ITMP = ISUPPZ( 2*I ) 
                  ISUPPZ( 2*I ) = ISUPPZ( 2*J ) 
                  ISUPPZ( 2*J ) = ITMP 
                  END IF 
            END IF 
60       CONTINUE 
      END IF 
      ENDIF 
!                                                                       
!                                                                       
      WORK( 1 ) = LWMIN 
      IWORK( 1 ) = LIWMIN 
      RETURN 
!                                                                       
!     End of DSTEMR                                                     
!                                                                       
      END                                           
!> \brief \b DSTERF                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSTERF + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSTERF( N, D, E, INFO )                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            INFO, N                                      
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   D( * ), E( * )                               
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSTERF computes all eigenvalues of a symmetric tridiagonal matrix    
!> using the Pal-Walker-Kahan variant of the QL or QR algorithm.        
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix.  N >= 0.                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] D                                                     
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          On entry, the n diagonal elements of the tridiagonal matrix.
!>          On exit, if INFO = 0, the eigenvalues in ascending order.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] E                                                     
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          On entry, the (n-1) subdiagonal elements of the tridiagonal 
!>          matrix.                                                     
!>          On exit, E has been destroyed.                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  the algorithm failed to find all of the eigenvalues in
!>                a total of 30*N iterations; if INFO = i, then i       
!>                elements of E have not converged to zero.             
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERcomputational                                       
!                                                                       
!  =====================================================================
      SUBROUTINE DSTERF( N, D, E, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   D( * ), E( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TWO, THREE 
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0,      &
&                   THREE = 3.0D0 )                                
      INTEGER            MAXIT 
      PARAMETER          ( MAXIT = 30 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, ISCALE, JTOT, L, L1, LEND, LENDSV, LSV, M,  &
&                   NMAXIT                                         
      DOUBLE PRECISION   ALPHA, ANORM, BB, C, EPS, EPS2, GAMMA, OLDC,   &
&                   OLDGAM, P, R, RT1, RT2, RTE, S, SAFMAX, SAFMIN,&
&                   SIGMA, SSFMAX, SSFMIN, RMAX                    
!     ..                                                                
!     .. External Functions ..                                          
      DOUBLE PRECISION   DLAMCH, DLANST, DLAPY2 
      EXTERNAL           DLAMCH, DLANST, DLAPY2 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLAE2, DLASCL, DLASRT, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SIGN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LT.0 ) THEN 
      INFO = -1 
      CALL XERBLA( 'DSTERF', -INFO ) 
      RETURN 
      END IF 
      IF( N.LE.1 )                                                      &
&   RETURN                                                         
!                                                                       
!     Determine the unit roundoff for this environment.                 
!                                                                       
      EPS = DLAMCH( 'E' ) 
      EPS2 = EPS**2 
      SAFMIN = DLAMCH( 'S' ) 
      SAFMAX = ONE / SAFMIN 
      SSFMAX = SQRT( SAFMAX ) / THREE 
      SSFMIN = SQRT( SAFMIN ) / EPS2 
      RMAX = DLAMCH( 'O' ) 
!                                                                       
!     Compute the eigenvalues of the tridiagonal matrix.                
!                                                                       
      NMAXIT = N*MAXIT 
      SIGMA = ZERO 
      JTOT = 0 
!                                                                       
!     Determine where the matrix splits and choose QL or QR iteration   
!     for each block, according to whether top or bottom diagonal       
!     element is smaller.                                               
!                                                                       
      L1 = 1 
!                                                                       
10 CONTINUE 
      IF( L1.GT.N )                                                     &
&   GO TO 170                                                      
      IF( L1.GT.1 )                                                     &
&   E( L1-1 ) = ZERO                                               
      DO 20 M = L1, N - 1 
      IF( ABS( E( M ) ).LE.( SQRT( ABS( D( M ) ) )*SQRT( ABS( D( M+  &
&       1 ) ) ) )*EPS ) THEN                                       
            E( M ) = ZERO 
            GO TO 30 
      END IF 
20 END DO 
      M = N 
!                                                                       
30 CONTINUE 
      L = L1 
      LSV = L 
      LEND = M 
      LENDSV = LEND 
      L1 = M + 1 
      IF( LEND.EQ.L )                                                   &
&   GO TO 10                                                       
!                                                                       
!     Scale submatrix in rows and columns L to LEND                     
!                                                                       
      ANORM = DLANST( 'M', LEND-L+1, D( L ), E( L ) ) 
      ISCALE = 0 
      IF( ANORM.EQ.ZERO )                                               &
&   GO TO 10                                                       
      IF( (ANORM.GT.SSFMAX) ) THEN 
      ISCALE = 1 
      CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N, &
&                INFO )                                            
      CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N,   &
&                INFO )                                            
      ELSE IF( ANORM.LT.SSFMIN ) THEN 
      ISCALE = 2 
      CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N, &
&                INFO )                                            
      CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N,   &
&                INFO )                                            
      END IF 
!                                                                       
      DO 40 I = L, LEND - 1 
      E( I ) = E( I )**2 
40 END DO 
!                                                                       
!     Choose between QL and QR iteration                                
!                                                                       
      IF( ABS( D( LEND ) ).LT.ABS( D( L ) ) ) THEN 
      LEND = LSV 
      L = LENDSV 
      END IF 
!                                                                       
      IF( LEND.GE.L ) THEN 
!                                                                       
!        QL Iteration                                                   
!                                                                       
!        Look for small subdiagonal element.                            
!                                                                       
50    CONTINUE 
      IF( L.NE.LEND ) THEN 
            DO 60 M = L, LEND - 1 
            IF( ABS( E( M ) ).LE.EPS2*ABS( D( M )*D( M+1 ) ) )       &
&            GO TO 70                                              
60       CONTINUE 
      END IF 
      M = LEND 
!                                                                       
70    CONTINUE 
      IF( M.LT.LEND )                                                &
&      E( M ) = ZERO                                               
      P = D( L ) 
      IF( M.EQ.L )                                                   &
&      GO TO 90                                                    
!                                                                       
!        If remaining matrix is 2 by 2, use DLAE2 to compute its        
!        eigenvalues.                                                   
!                                                                       
      IF( M.EQ.L+1 ) THEN 
            RTE = SQRT( E( L ) ) 
            CALL DLAE2( D( L ), RTE, D( L+1 ), RT1, RT2 ) 
            D( L ) = RT1 
            D( L+1 ) = RT2 
            E( L ) = ZERO 
            L = L + 2 
            IF( L.LE.LEND )                                             &
&         GO TO 50                                                 
            GO TO 150 
      END IF 
!                                                                       
      IF( JTOT.EQ.NMAXIT )                                           &
&      GO TO 150                                                   
      JTOT = JTOT + 1 
!                                                                       
!        Form shift.                                                    
!                                                                       
      RTE = SQRT( E( L ) ) 
      SIGMA = ( D( L+1 )-P ) / ( TWO*RTE ) 
      R = DLAPY2( SIGMA, ONE ) 
      SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) ) 
!                                                                       
      C = ONE 
      S = ZERO 
      GAMMA = D( M ) - SIGMA 
      P = GAMMA*GAMMA 
!                                                                       
!        Inner loop                                                     
!                                                                       
      DO 80 I = M - 1, L, -1 
            BB = E( I ) 
            R = P + BB 
            IF( I.NE.M-1 )                                              &
&         E( I+1 ) = S*R                                           
            OLDC = C 
            C = P / R 
            S = BB / R 
            OLDGAM = GAMMA 
            ALPHA = D( I ) 
            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM 
            D( I+1 ) = OLDGAM + ( ALPHA-GAMMA ) 
            IF( C.NE.ZERO ) THEN 
            P = ( GAMMA*GAMMA ) / C 
            ELSE 
            P = OLDC*BB 
            END IF 
80    CONTINUE 
!                                                                       
      E( L ) = S*P 
      D( L ) = SIGMA + GAMMA 
      GO TO 50 
!                                                                       
!        Eigenvalue found.                                              
!                                                                       
90    CONTINUE 
      D( L ) = P 
!                                                                       
      L = L + 1 
      IF( L.LE.LEND )                                                &
&      GO TO 50                                                    
      GO TO 150 
!                                                                       
      ELSE 
!                                                                       
!        QR Iteration                                                   
!                                                                       
!        Look for small superdiagonal element.                          
!                                                                       
100    CONTINUE 
      DO 110 M = L, LEND + 1, -1 
            IF( ABS( E( M-1 ) ).LE.EPS2*ABS( D( M )*D( M-1 ) ) )        &
&         GO TO 120                                                
110    CONTINUE 
      M = LEND 
!                                                                       
120    CONTINUE 
      IF( M.GT.LEND )                                                &
&      E( M-1 ) = ZERO                                             
      P = D( L ) 
      IF( M.EQ.L )                                                   &
&      GO TO 140                                                   
!                                                                       
!        If remaining matrix is 2 by 2, use DLAE2 to compute its        
!        eigenvalues.                                                   
!                                                                       
      IF( M.EQ.L-1 ) THEN 
            RTE = SQRT( E( L-1 ) ) 
            CALL DLAE2( D( L ), RTE, D( L-1 ), RT1, RT2 ) 
            D( L ) = RT1 
            D( L-1 ) = RT2 
            E( L-1 ) = ZERO 
            L = L - 2 
            IF( L.GE.LEND )                                             &
&         GO TO 100                                                
            GO TO 150 
      END IF 
!                                                                       
      IF( JTOT.EQ.NMAXIT )                                           &
&      GO TO 150                                                   
      JTOT = JTOT + 1 
!                                                                       
!        Form shift.                                                    
!                                                                       
      RTE = SQRT( E( L-1 ) ) 
      SIGMA = ( D( L-1 )-P ) / ( TWO*RTE ) 
      R = DLAPY2( SIGMA, ONE ) 
      SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) ) 
!                                                                       
      C = ONE 
      S = ZERO 
      GAMMA = D( M ) - SIGMA 
      P = GAMMA*GAMMA 
!                                                                       
!        Inner loop                                                     
!                                                                       
      DO 130 I = M, L - 1 
            BB = E( I ) 
            R = P + BB 
            IF( I.NE.M )                                                &
&         E( I-1 ) = S*R                                           
            OLDC = C 
            C = P / R 
            S = BB / R 
            OLDGAM = GAMMA 
            ALPHA = D( I+1 ) 
            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM 
            D( I ) = OLDGAM + ( ALPHA-GAMMA ) 
            IF( C.NE.ZERO ) THEN 
            P = ( GAMMA*GAMMA ) / C 
            ELSE 
            P = OLDC*BB 
            END IF 
130    CONTINUE 
!                                                                       
      E( L-1 ) = S*P 
      D( L ) = SIGMA + GAMMA 
      GO TO 100 
!                                                                       
!        Eigenvalue found.                                              
!                                                                       
140    CONTINUE 
      D( L ) = P 
!                                                                       
      L = L - 1 
      IF( L.GE.LEND )                                                &
&      GO TO 100                                                   
      GO TO 150 
!                                                                       
      END IF 
!                                                                       
!     Undo scaling if necessary                                         
!                                                                       
150 CONTINUE 
      IF( ISCALE.EQ.1 )                                                 &
&   CALL DLASCL( 'G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1,        &
&                D( LSV ), N, INFO )                               
      IF( ISCALE.EQ.2 )                                                 &
&   CALL DLASCL( 'G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1,        &
&                D( LSV ), N, INFO )                               
!                                                                       
!     Check for no convergence to an eigenvalue after a total           
!     of N*MAXIT iterations.                                            
!                                                                       
      IF( JTOT.LT.NMAXIT )                                              &
&   GO TO 10                                                       
      DO 160 I = 1, N - 1 
      IF( E( I ).NE.ZERO )                                           &
&      INFO = INFO + 1                                             
160 END DO 
      GO TO 180 
!                                                                       
!     Sort eigenvalues in increasing order.                             
!                                                                       
170 CONTINUE 
      CALL DLASRT( 'I', N, D, INFO ) 
!                                                                       
180 CONTINUE 
      RETURN 
!                                                                       
!     End of DSTERF                                                     
!                                                                       
      END                                           
!> \brief \b DSWAP                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSWAP(N,DX,INCX,DY,INCY)                             
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,INCY,N                                             
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*),DY(*)                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    DSWAP interchanges two vectors.                                   
!>    uses unrolled loops for increments equal to 1.                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DX                                                    
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] DY                                                    
!> \verbatim                                                            
!>          DY is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>         storage spacing between elements of DY                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup double_blas_level1                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSWAP(N,DX,INCX,DY,INCY) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,INCY,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*),DY(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLE PRECISION DTEMP 
      INTEGER I,IX,IY,M,MP1 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     ..                                                                
      IF (N.LE.0) RETURN 
      IF (INCX.EQ.1 .AND. INCY.EQ.1) THEN 
!                                                                       
!       code for both increments equal to 1                             
!                                                                       
!                                                                       
!       clean-up loop                                                   
!                                                                       
      M = MOD(N,3) 
      IF (M.NE.0) THEN 
            DO I = 1,M 
            DTEMP = DX(I) 
            DX(I) = DY(I) 
            DY(I) = DTEMP 
            END DO 
            IF (N.LT.3) RETURN 
      END IF 
      MP1 = M + 1 
      DO I = MP1,N,3 
            DTEMP = DX(I) 
            DX(I) = DY(I) 
            DY(I) = DTEMP 
            DTEMP = DX(I+1) 
            DX(I+1) = DY(I+1) 
            DY(I+1) = DTEMP 
            DTEMP = DX(I+2) 
            DX(I+2) = DY(I+2) 
            DY(I+2) = DTEMP 
      END DO 
      ELSE 
!                                                                       
!       code for unequal increments or equal increments not equal       
!         to 1                                                          
!                                                                       
      IX = 1 
      IY = 1 
      IF (INCX.LT.0) IX = (-N+1)*INCX + 1 
      IF (INCY.LT.0) IY = (-N+1)*INCY + 1 
      DO I = 1,N 
            DTEMP = DX(IX) 
            DX(IX) = DY(IY) 
            DY(IY) = DTEMP 
            IX = IX + INCX 
            IY = IY + INCY 
      END DO 
      END IF 
      RETURN 
!> \brief <b> DSYEVR computes the eigenvalues and, optionally, the left 
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSYEVR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,
!                          ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,   
!                          IWORK, LIWORK, INFO )                        
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          JOBZ, RANGE, UPLO                            
!       INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N  
!       DOUBLE PRECISION   ABSTOL, VL, VU                               
!       ..                                                              
!       .. Array Arguments ..                                           
!       INTEGER            ISUPPZ( * ), IWORK( * )                      
!       DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYEVR computes selected eigenvalues and, optionally, eigenvectors   
!> of a real symmetric matrix A.  Eigenvalues and eigenvectors can be   
!> selected by specifying either a range of values or a range of        
!> indices for the desired eigenvalues.                                 
!>                                                                      
!> DSYEVR first reduces the matrix A to tridiagonal form T with a call  
!> to DSYTRD.  Then, whenever possible, DSYEVR calls DSTEMR to compute  
!> the eigenspectrum using Relatively Robust Representations.  DSTEMR   
!> computes eigenvalues by the dqds algorithm, while orthogonal         
!> eigenvectors are computed from various "good" L D L^T representations
!> (also known as Relatively Robust Representations). Gram-Schmidt      
!> orthogonalization is avoided as far as possible. More specifically,  
!> the various steps of the algorithm are as follows.                   
!>                                                                      
!> For each unreduced block (submatrix) of T,                           
!>    (a) Compute T - sigma I  = L D L^T, so that L and D               
!>        define all the wanted eigenvalues to high relative accuracy.  
!>        This means that small relative changes in the entries of D and
!>        cause only small relative changes in the eigenvalues and      
!>        eigenvectors. The standard (unfactored) representation of the 
!>        tridiagonal matrix T does not have this property in general.  
!>    (b) Compute the eigenvalues to suitable accuracy.                 
!>        If the eigenvectors are desired, the algorithm attains full   
!>        accuracy of the computed eigenvalues only right before        
!>        the corresponding vectors have to be computed, see steps c) an
!>    (c) For each cluster of close eigenvalues, select a new           
!>        shift close to the cluster, find a new factorization, and refi
!>        the shifted eigenvalues to suitable accuracy.                 
!>    (d) For each eigenvalue with a large enough relative separation co
!>        the corresponding eigenvector by forming a rank revealing twis
!>        factorization. Go back to (c) for any clusters that remain.   
!>                                                                      
!> The desired accuracy of the output can be specified by the input     
!> parameter ABSTOL.                                                    
!>                                                                      
!> For more details, see DSTEMR's documentation and:                    
!> - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representat
!>   to compute orthogonal eigenvectors of symmetric tridiagonal matrice
!>   Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
!> - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors an
!>   Relative Gaps," SIAM Journal on Matrix Analysis and Applications, V
!>   2004.  Also LAPACK Working Note 154.                               
!> - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric        
!>   tridiagonal eigenvalue/eigenvector problem",                       
!>   Computer Science Division Technical Report No. UCB/CSD-97-971,     
!>   UC Berkeley, May 1997.                                             
!>                                                                      
!>                                                                      
!> Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested     
!> on machines which conform to the ieee-754 floating point standard.   
!> DSYEVR calls DSTEBZ and DSTEIN on non-ieee machines and              
!> when partial spectrum requests are made.                             
!>                                                                      
!> Normal execution of DSTEMR may create NaNs and infinities and        
!> hence may abort due to a floating point exception in environments    
!> which do not handle NaNs and infinities in the ieee standard default 
!> manner.                                                              
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] JOBZ                                                      
!> \verbatim                                                            
!>          JOBZ is CHARACTER*1                                         
!>          = 'N':  Compute eigenvalues only;                           
!>          = 'V':  Compute eigenvalues and eigenvectors.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] RANGE                                                     
!> \verbatim                                                            
!>          RANGE is CHARACTER*1                                        
!>          = 'A': all eigenvalues will be found.                       
!>          = 'V': all eigenvalues in the half-open interval (VL,VU]    
!>                 will be found.                                       
!>          = 'I': the IL-th through IU-th eigenvalues will be found.   
!>          For RANGE = 'V' or 'I' and IU - IL < N - 1, DSTEBZ and      
!>          DSTEIN are called                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U':  Upper triangle of A is stored;                      
!>          = 'L':  Lower triangle of A is stored.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA, N)             
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the       
!>          leading N-by-N upper triangular part of A contains the      
!>          upper triangular part of the matrix A.  If UPLO = 'L',      
!>          the leading N-by-N lower triangular part of A contains      
!>          the lower triangular part of the matrix A.                  
!>          On exit, the lower triangle (if UPLO='L') or the upper      
!>          triangle (if UPLO='U') of A, including the diagonal, is     
!>          destroyed.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VL                                                        
!> \verbatim                                                            
!>          VL is DOUBLE PRECISION                                      
!>          If RANGE='V', the lower bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] VU                                                        
!> \verbatim                                                            
!>          VU is DOUBLE PRECISION                                      
!>          If RANGE='V', the upper bound of the interval to            
!>          be searched for eigenvalues. VL < VU.                       
!>          Not referenced if RANGE = 'A' or 'I'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IL                                                        
!> \verbatim                                                            
!>          IL is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          smallest eigenvalue to be returned.                         
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IU                                                        
!> \verbatim                                                            
!>          IU is INTEGER                                               
!>          If RANGE='I', the index of the                              
!>          largest eigenvalue to be returned.                          
!>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.   
!>          Not referenced if RANGE = 'A' or 'V'.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ABSTOL                                                    
!> \verbatim                                                            
!>          ABSTOL is DOUBLE PRECISION                                  
!>          The absolute error tolerance for the eigenvalues.           
!>          An approximate eigenvalue is accepted as converged          
!>          when it is determined to lie in an interval [a,b]           
!>          of width less than or equal to                              
!>                                                                      
!>                  ABSTOL + EPS *   max( |a|,|b| ) ,                   
!>                                                                      
!>          where EPS is the machine precision.  If ABSTOL is less than 
!>          or equal to zero, then  EPS*|T|  will be used in its place, 
!>          where |T| is the 1-norm of the tridiagonal matrix obtained  
!>          by reducing A to tridiagonal form.                          
!>                                                                      
      END                                           
!>          See "Computing Small Singular Values of Bidiagonal Matrices 
!>          with Guaranteed High Relative Accuracy," by Demmel and      
!>          Kahan, LAPACK Working Note #3.                              
!>                                                                      
!>          If high relative accuracy is important, set ABSTOL to       
!>          DLAMCH( 'Safe minimum' ).  Doing so will guarantee that     
!>          eigenvalues are computed to high relative accuracy when     
!>          possible in future releases.  The current code does not     
!>          make any guarantees about high relative accuracy, but       
!>          future releases will. See J. Barlow and J. Demmel,          
!>          "Computing Accurate Eigensystems of Scaled Diagonally       
!>          Dominant Matrices", LAPACK Working Note #7, for a discussion
!>          of which matrices define their eigenvalues to high relative 
!>          accuracy.                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] M                                                        
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The total number of eigenvalues found.  0 <= M <= N.        
!>          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] W                                                        
!> \verbatim                                                            
!>          W is DOUBLE PRECISION array, dimension (N)                  
!>          The first M elements contain the selected eigenvalues in    
!>          ascending order.                                            
!> \endverbatim                                                         
!>                                                                      
!> \param[out] Z                                                        
!> \verbatim                                                            
!>          Z is DOUBLE PRECISION array, dimension (LDZ, max(1,M))      
!>          If JOBZ = 'V', then if INFO = 0, the first M columns of Z   
!>          contain the orthonormal eigenvectors of the matrix A        
!>          corresponding to the selected eigenvalues, with the i-th    
!>          column of Z holding the eigenvector associated with W(i).   
!>          If JOBZ = 'N', then Z is not referenced.                    
!>          Note: the user must ensure that at least max(1,M) columns ar
!>          supplied in the array Z; if RANGE = 'V', the exact value of 
!>          is not known in advance and an upper bound must be used.    
!>          Supplying N columns is always safe.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDZ                                                       
!> \verbatim                                                            
!>          LDZ is INTEGER                                              
!>          The leading dimension of the array Z.  LDZ >= 1, and if     
!>          JOBZ = 'V', LDZ >= max(1,N).                                
!> \endverbatim                                                         
!>                                                                      
!> \param[out] ISUPPZ                                                   
!> \verbatim                                                            
!>          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )           
!>          The support of the eigenvectors in Z, i.e., the indices     
!>          indicating the nonzero elements in Z. The i-th eigenvector  
!>          is nonzero only in elements ISUPPZ( 2*i-1 ) through         
!>          ISUPPZ( 2*i ). This is an output of DSTEMR (tridiagonal     
!>          matrix). The support of the eigenvectors of A is typically  
!>          1:N because of the orthogonal transformations applied by DOR
!>          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1 
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))    
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.  LWORK >= max(1,26*N).     
!>          For optimal efficiency, LWORK >= (NB+6)*N,                  
!>          where NB is the max of the blocksize for DSYTRD and DORMTR  
!>          returned by ILAENV.                                         
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] IWORK                                                    
!> \verbatim                                                            
!>          IWORK is INTEGER array, dimension (MAX(1,LIWORK))           
!>          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LIWORK                                                    
!> \verbatim                                                            
!>          LIWORK is INTEGER                                           
!>          The dimension of the array IWORK.  LIWORK >= max(1,10*N).   
!>                                                                      
!>          If LIWORK = -1, then a workspace query is assumed; the      
!>          routine only calculates the optimal size of the IWORK array,
!>          returns this value as the first entry of the IWORK array, an
!>          no error message related to LIWORK is issued by XERBLA.     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!>          > 0:  Internal error                                        
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2016                                                      
!                                                                       
!> \ingroup doubleSYeigen                                               
!                                                                       
!> \par Contributors:                                                   
!  ==================                                                   
!>                                                                      
!>     Inderjit Dhillon, IBM Almaden, USA \n                            
!>     Osni Marques, LBNL/NERSC, USA \n                                 
!>     Ken Stanley, Computer Science Division, University of            
!>       California at Berkeley, USA \n                                 
!>     Jason Riedy, Computer Science Division, University of            
!>       California at Berkeley, USA \n                                 
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,  &
&                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,     &
&                   IWORK, LIWORK, INFO )                          
!                                                                       
!  -- LAPACK driver routine (version 3.7.1) --                          
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2016                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBZ, RANGE, UPLO 
      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N 
      DOUBLE PRECISION   ABSTOL, VL, VU 
!     ..                                                                
!     .. Array Arguments ..                                             
      INTEGER            ISUPPZ( * ), IWORK( * ) 
      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * ) 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ZERO, ONE, TWO 
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            ALLEIG, INDEIG, LOWER, LQUERY, VALEIG, WANTZ,  &
&                   TRYRAC                                         
      CHARACTER          ORDER 
      INTEGER            I, IEEEOK, IINFO, IMAX, INDD, INDDD, INDE,     &
&                   INDEE, INDIBL, INDIFL, INDISP, INDIWO, INDTAU, &
&                   INDWK, INDWKN, ISCALE, J, JJ, LIWMIN,          &
&                   LLWORK, LLWRKN, LWKOPT, LWMIN, NB, NSPLIT      
      DOUBLE PRECISION   ABSTLL, ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN, &
&                   SIGMA, SMLNUM, TMP1, VLL, VUU                  
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      DOUBLE PRECISION   DLAMCH, DLANSY 
      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANSY 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DCOPY, DORMTR, DSCAL, DSTEBZ, DSTEMR, DSTEIN,  &
&                   DSTERF, DSWAP, DSYTRD, XERBLA                  
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      IEEEOK = ILAENV( 10, 'DSYEVR', 'N', 1, 2, 3, 4 ) 
!                                                                       
      LOWER = LSAME( UPLO, 'L' ) 
      WANTZ = LSAME( JOBZ, 'V' ) 
      ALLEIG = LSAME( RANGE, 'A' ) 
      VALEIG = LSAME( RANGE, 'V' ) 
      INDEIG = LSAME( RANGE, 'I' ) 
!                                                                       
      LQUERY = ( ( LWORK.EQ.-1 ) .OR. ( LIWORK.EQ.-1 ) ) 
!                                                                       
      LWMIN = MAX( 1, 26*N ) 
      LIWMIN = MAX( 1, 10*N ) 
!                                                                       
      INFO = 0 
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN 
      INFO = -1 
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN 
      INFO = -2 
      ELSE IF( .NOT.( LOWER .OR. LSAME( UPLO, 'U' ) ) ) THEN 
      INFO = -3 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -4 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
      INFO = -6 
      ELSE 
      IF( VALEIG ) THEN 
            IF( N.GT.0 .AND. VU.LE.VL )                                 &
&         INFO = -8                                                
      ELSE IF( INDEIG ) THEN 
            IF( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) THEN 
            INFO = -9 
            ELSE IF( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) THEN 
            INFO = -10 
            END IF 
      END IF 
      END IF 
      IF( INFO.EQ.0 ) THEN 
      IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN 
            INFO = -15 
      ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN 
            INFO = -18 
      ELSE IF( LIWORK.LT.LIWMIN .AND. .NOT.LQUERY ) THEN 
            INFO = -20 
      END IF 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
      NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 ) 
      NB = MAX( NB, ILAENV( 1, 'DORMTR', UPLO, N, -1, -1, -1 ) ) 
      LWKOPT = MAX( ( NB+1 )*N, LWMIN ) 
      WORK( 1 ) = LWKOPT 
      IWORK( 1 ) = LIWMIN 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DSYEVR', -INFO ) 
      RETURN 
      ELSE IF( LQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      M = 0 
      IF( N.EQ.0 ) THEN 
      WORK( 1 ) = 1 
      RETURN 
      END IF 
!                                                                       
      IF( N.EQ.1 ) THEN 
      WORK( 1 ) = 7 
      IF( ALLEIG .OR. INDEIG ) THEN 
            M = 1 
            W( 1 ) = A( 1, 1 ) 
      ELSE 
            IF( VL.LT.A( 1, 1 ) .AND. VU.GE.A( 1, 1 ) ) THEN 
            M = 1 
            W( 1 ) = A( 1, 1 ) 
            END IF 
      END IF 
      IF( WANTZ ) THEN 
            Z( 1, 1 ) = ONE 
            ISUPPZ( 1 ) = 1 
            ISUPPZ( 2 ) = 1 
      END IF 
      RETURN 
      END IF 
!                                                                       
!     Get machine constants.                                            
!                                                                       
      SAFMIN = DLAMCH( 'Safe minimum' ) 
      EPS = DLAMCH( 'Precision' ) 
      SMLNUM = SAFMIN / EPS 
      BIGNUM = ONE / SMLNUM 
      RMIN = SQRT( SMLNUM ) 
      RMAX = MIN( SQRT( BIGNUM ), ONE / SQRT( SQRT( SAFMIN ) ) ) 
!                                                                       
!     Scale matrix to allowable range, if necessary.                    
!                                                                       
      ISCALE = 0 
      ABSTLL = ABSTOL 
      IF (VALEIG) THEN 
      VLL = VL 
      VUU = VU 
      END IF 
      ANRM = DLANSY( 'M', UPLO, N, A, LDA, WORK ) 
      IF( ANRM.GT.ZERO .AND. ANRM.LT.RMIN ) THEN 
      ISCALE = 1 
      SIGMA = RMIN / ANRM 
      ELSE IF( ANRM.GT.RMAX ) THEN 
      ISCALE = 1 
      SIGMA = RMAX / ANRM 
      END IF 
      IF( ISCALE.EQ.1 ) THEN 
      IF( LOWER ) THEN 
            DO 10 J = 1, N 
            CALL DSCAL( N-J+1, SIGMA, A( J, J ), 1 ) 
10       CONTINUE 
      ELSE 
            DO 20 J = 1, N 
            CALL DSCAL( J, SIGMA, A( 1, J ), 1 ) 
20       CONTINUE 
      END IF 
      IF( ABSTOL.GT.0 )                                              &
&      ABSTLL = ABSTOL*SIGMA                                       
      IF( VALEIG ) THEN 
            VLL = VL*SIGMA 
            VUU = VU*SIGMA 
      END IF 
      END IF 
                                                                        
!     Initialize indices into workspaces.  Note: The IWORK indices are  
!     used only if DSTERF or DSTEMR fail.                               
                                                                        
!     WORK(INDTAU:INDTAU+N-1) stores the scalar factors of the          
!     elementary reflectors used in DSYTRD.                             
      INDTAU = 1 
!     WORK(INDD:INDD+N-1) stores the tridiagonal's diagonal entries.    
      INDD = INDTAU + N 
!     WORK(INDE:INDE+N-1) stores the off-diagonal entries of the        
!     tridiagonal matrix from DSYTRD.                                   
      INDE = INDD + N 
!     WORK(INDDD:INDDD+N-1) is a copy of the diagonal entries over      
!     -written by DSTEMR (the DSTERF path copies the diagonal to W).    
      INDDD = INDE + N 
!     WORK(INDEE:INDEE+N-1) is a copy of the off-diagonal entries over  
!     -written while computing the eigenvalues in DSTERF and DSTEMR.    
      INDEE = INDDD + N 
!     INDWK is the starting offset of the left-over workspace, and      
!     LLWORK is the remaining workspace size.                           
      INDWK = INDEE + N 
      LLWORK = LWORK - INDWK + 1 
                                                                        
!     IWORK(INDIBL:INDIBL+M-1) corresponds to IBLOCK in DSTEBZ and      
!     stores the block indices of each of the M<=N eigenvalues.         
      INDIBL = 1 
!     IWORK(INDISP:INDISP+NSPLIT-1) corresponds to ISPLIT in DSTEBZ and 
!     stores the starting and finishing indices of each block.          
      INDISP = INDIBL + N 
!     IWORK(INDIFL:INDIFL+N-1) stores the indices of eigenvectors       
!     that corresponding to eigenvectors that fail to converge in       
!     DSTEIN.  This information is discarded; if any fail, the driver   
!     returns INFO > 0.                                                 
      INDIFL = INDISP + N 
!     INDIWO is the offset of the remaining integer workspace.          
      INDIWO = INDIFL + N 
                                                                        
!                                                                       
!     Call DSYTRD to reduce symmetric matrix to tridiagonal form.       
!                                                                       
      CALL DSYTRD( UPLO, N, A, LDA, WORK( INDD ), WORK( INDE ),         &
&             WORK( INDTAU ), WORK( INDWK ), LLWORK, IINFO )       
!                                                                       
!     If all eigenvalues are desired                                    
!     then call DSTERF or DSTEMR and DORMTR.                            
!                                                                       
      IF( ( ALLEIG .OR. ( INDEIG .AND. IL.EQ.1 .AND. IU.EQ.N ) ) .AND.  &
&    IEEEOK.EQ.1 ) THEN                                            
      IF( .NOT.WANTZ ) THEN 
            CALL DCOPY( N, WORK( INDD ), 1, W, 1 ) 
            CALL DCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 ) 
            CALL DSTERF( N, W, WORK( INDEE ), INFO ) 
      ELSE 
            CALL DCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 ) 
            CALL DCOPY( N, WORK( INDD ), 1, WORK( INDDD ), 1 ) 
!                                                                       
            IF (ABSTOL .LE. TWO*N*EPS) THEN 
            TRYRAC = .TRUE. 
            ELSE 
            TRYRAC = .FALSE. 
            END IF 
            CALL DSTEMR( JOBZ, 'A', N, WORK( INDDD ), WORK( INDEE ),    &
&                   VL, VU, IL, IU, M, W, Z, LDZ, N, ISUPPZ,       &
&                   TRYRAC, WORK( INDWK ), LWORK, IWORK, LIWORK,   &
&                   INFO )                                         
!                                                                       
!                                                                       
!                                                                       
!        Apply orthogonal matrix used in reduction to tridiagonal       
!        form to eigenvectors returned by DSTEMR.                       
!                                                                       
            IF( WANTZ .AND. INFO.EQ.0 ) THEN 
            INDWKN = INDE 
            LLWRKN = LWORK - INDWKN + 1 
            CALL DORMTR( 'L', UPLO, 'N', N, M, A, LDA,               &
&                      WORK( INDTAU ), Z, LDZ, WORK( INDWKN ),     &
&                      LLWRKN, IINFO )                             
            END IF 
      END IF 
!                                                                       
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!           Everything worked.  Skip DSTEBZ/DSTEIN.  IWORK(:) are       
!           undefined.                                                  
            M = N 
            GO TO 30 
      END IF 
      INFO = 0 
      END IF 
!                                                                       
!     Otherwise, call DSTEBZ and, if eigenvectors are desired, DSTEIN.  
!     Also call DSTEBZ and DSTEIN if DSTEMR fails.                      
!                                                                       
      IF( WANTZ ) THEN 
      ORDER = 'B' 
      ELSE 
      ORDER = 'E' 
      END IF 
                                                                        
      CALL DSTEBZ( RANGE, ORDER, N, VLL, VUU, IL, IU, ABSTLL,           &
&             WORK( INDD ), WORK( INDE ), M, NSPLIT, W,            &
&             IWORK( INDIBL ), IWORK( INDISP ), WORK( INDWK ),     &
&             IWORK( INDIWO ), INFO )                              
!                                                                       
      IF( WANTZ ) THEN 
      CALL DSTEIN( N, WORK( INDD ), WORK( INDE ), M, W,              &
&                IWORK( INDIBL ), IWORK( INDISP ), Z, LDZ,         &
&                WORK( INDWK ), IWORK( INDIWO ), IWORK( INDIFL ),  &
&                INFO )                                            
!                                                                       
!        Apply orthogonal matrix used in reduction to tridiagonal       
!        form to eigenvectors returned by DSTEIN.                       
!                                                                       
      INDWKN = INDE 
      LLWRKN = LWORK - INDWKN + 1 
      CALL DORMTR( 'L', UPLO, 'N', N, M, A, LDA, WORK( INDTAU ), Z,  &
&                LDZ, WORK( INDWKN ), LLWRKN, IINFO )              
      END IF 
!                                                                       
!     If matrix was scaled, then rescale eigenvalues appropriately.     
!                                                                       
!  Jump here if DSTEMR/DSTEIN succeeded.                                
30 CONTINUE 
      IF( ISCALE.EQ.1 ) THEN 
      IF( INFO.EQ.0 ) THEN 
            IMAX = M 
      ELSE 
            IMAX = INFO - 1 
      END IF 
      CALL DSCAL( IMAX, ONE / SIGMA, W, 1 ) 
      END IF 
!                                                                       
!     If eigenvalues are not in order, then sort them, along with       
!     eigenvectors.  Note: We do not sort the IFAIL portion of IWORK.   
!     It may not be initialized (if DSTEMR/DSTEIN succeeded), and we do 
!     not return this detailed information to the user.                 
!                                                                       
      IF( WANTZ ) THEN 
      DO 50 J = 1, M - 1 
            I = 0 
            TMP1 = W( J ) 
            DO 40 JJ = J + 1, M 
            IF( W( JJ ).LT.TMP1 ) THEN 
                  I = JJ 
                  TMP1 = W( JJ ) 
            END IF 
40       CONTINUE 
!                                                                       
            IF( I.NE.0 ) THEN 
            W( I ) = W( J ) 
            W( J ) = TMP1 
            CALL DSWAP( N, Z( 1, I ), 1, Z( 1, J ), 1 ) 
            END IF 
50    CONTINUE 
      END IF 
!                                                                       
!     Set WORK(1) to optimal workspace size.                            
!                                                                       
      WORK( 1 ) = LWKOPT 
      IWORK( 1 ) = LIWMIN 
!                                                                       
      RETURN 
!                                                                       
!     End of DSYEVR                                                     
!                                                                       
      END                                           
!> \brief \b DSYMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)         
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA,BETA                                     
!       INTEGER INCX,INCY,LDA,N                                         
!       CHARACTER UPLO                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),X(*),Y(*)                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYMV  performs the matrix-vector  operation                         
!>                                                                      
!>    y := alpha*A*x + beta*y,                                          
!>                                                                      
!> where alpha and beta are scalars, x and y are n element vectors and  
!> A is an n by n symmetric matrix.                                     
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the upper or lower        
!>           triangular part of the array A is to be referenced as      
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the upper triangular part of A 
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the lower triangular part of A 
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, N )           
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular part of the symmetric matrix and the strictly   
!>           lower triangular part of A is not referenced.              
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular part of the symmetric matrix and the strictly   
!>           upper triangular part of A is not referenced.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is DOUBLE PRECISION.                                   
!>           On entry, BETA specifies the scalar beta. When BETA is     
!>           supplied as zero then Y need not be set on input.          
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] Y                                                     
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y. On exit, Y is overwritten by the updated 
!>           vector y.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA,BETA 
      INTEGER INCX,INCY,LDA,N 
      CHARACTER UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP1,TEMP2 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
      INFO = 1 
      ELSE IF (N.LT.0) THEN 
      INFO = 2 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
      INFO = 5 
      ELSE IF (INCX.EQ.0) THEN 
      INFO = 7 
      ELSE IF (INCY.EQ.0) THEN 
      INFO = 10 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DSYMV ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN 
!                                                                       
!     Set up the start points in  X  and  Y.                            
!                                                                       
      IF (INCX.GT.0) THEN 
      KX = 1 
      ELSE 
      KX = 1 - (N-1)*INCX 
      END IF 
      IF (INCY.GT.0) THEN 
      KY = 1 
      ELSE 
      KY = 1 - (N-1)*INCY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through the triangular part   
!     of A.                                                             
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF (BETA.NE.ONE) THEN 
      IF (INCY.EQ.1) THEN 
            IF (BETA.EQ.ZERO) THEN 
                  DO 10 I = 1,N 
                  Y(I) = ZERO 
10             CONTINUE 
            ELSE 
                  DO 20 I = 1,N 
                  Y(I) = BETA*Y(I) 
20             CONTINUE 
            END IF 
      ELSE 
            IY = KY 
            IF (BETA.EQ.ZERO) THEN 
                  DO 30 I = 1,N 
                  Y(IY) = ZERO 
                  IY = IY + INCY 
30             CONTINUE 
            ELSE 
                  DO 40 I = 1,N 
                  Y(IY) = BETA*Y(IY) 
                  IY = IY + INCY 
40             CONTINUE 
            END IF 
      END IF 
      END IF 
      IF (ALPHA.EQ.ZERO) RETURN 
      IF (LSAME(UPLO,'U')) THEN 
!                                                                       
!        Form  y  when A is stored in upper triangle.                   
!                                                                       
      IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
            DO 60 J = 1,N 
                  TEMP1 = ALPHA*X(J) 
                  TEMP2 = ZERO 
                  DO 50 I = 1,J - 1 
                  Y(I) = Y(I) + TEMP1*A(I,J) 
                  TEMP2 = TEMP2 + A(I,J)*X(I) 
50             CONTINUE 
                  Y(J) = Y(J) + TEMP1*A(J,J) + ALPHA*TEMP2 
60         CONTINUE 
      ELSE 
            JX = KX 
            JY = KY 
            DO 80 J = 1,N 
                  TEMP1 = ALPHA*X(JX) 
                  TEMP2 = ZERO 
                  IX = KX 
                  IY = KY 
                  DO 70 I = 1,J - 1 
                  Y(IY) = Y(IY) + TEMP1*A(I,J) 
                  TEMP2 = TEMP2 + A(I,J)*X(IX) 
                  IX = IX + INCX 
                  IY = IY + INCY 
70             CONTINUE 
                  Y(JY) = Y(JY) + TEMP1*A(J,J) + ALPHA*TEMP2 
                  JX = JX + INCX 
                  JY = JY + INCY 
80         CONTINUE 
      END IF 
      ELSE 
!                                                                       
!        Form  y  when A is stored in lower triangle.                   
!                                                                       
      IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
            DO 100 J = 1,N 
                  TEMP1 = ALPHA*X(J) 
                  TEMP2 = ZERO 
                  Y(J) = Y(J) + TEMP1*A(J,J) 
                  DO 90 I = J + 1,N 
                  Y(I) = Y(I) + TEMP1*A(I,J) 
                  TEMP2 = TEMP2 + A(I,J)*X(I) 
90             CONTINUE 
                  Y(J) = Y(J) + ALPHA*TEMP2 
100         CONTINUE 
      ELSE 
            JX = KX 
            JY = KY 
            DO 120 J = 1,N 
                  TEMP1 = ALPHA*X(JX) 
                  TEMP2 = ZERO 
                  Y(JY) = Y(JY) + TEMP1*A(J,J) 
                  IX = JX 
                  IY = JY 
                  DO 110 I = J + 1,N 
                  IX = IX + INCX 
                  IY = IY + INCY 
                  Y(IY) = Y(IY) + TEMP1*A(I,J) 
                  TEMP2 = TEMP2 + A(I,J)*X(IX) 
110             CONTINUE 
                  Y(JY) = Y(JY) + ALPHA*TEMP2 
                  JX = JX + INCX 
                  JY = JY + INCY 
120         CONTINUE 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DSYMV .                                                    
!                                                                       
      END                                           
!> \brief \b DSYR2                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA)              
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA                                          
!       INTEGER INCX,INCY,LDA,N                                         
!       CHARACTER UPLO                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),X(*),Y(*)                             
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYR2  performs the symmetric rank 2 operation                       
!>                                                                      
!>    A := alpha*x*y**T + alpha*y*x**T + A,                             
!>                                                                      
!> where alpha is a scalar, x and y are n element vectors and A is an n 
!> by n symmetric matrix.                                               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the upper or lower        
!>           triangular part of the array A is to be referenced as      
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the upper triangular part of A 
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the lower triangular part of A 
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] X                                                         
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] Y                                                         
!> \verbatim                                                            
!>          Y is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCY ) ).                             
!>           Before entry, the incremented array Y must contain the n   
!>           element vector y.                                          
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCY                                                      
!> \verbatim                                                            
!>          INCY is INTEGER                                             
!>           On entry, INCY specifies the increment for the elements of 
!>           Y. INCY must not be zero.                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, N )           
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular part of the symmetric matrix and the strictly   
!>           lower triangular part of A is not referenced. On exit, the 
!>           upper triangular part of the array A is overwritten by the 
!>           upper triangular part of the updated matrix.               
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular part of the symmetric matrix and the strictly   
!>           upper triangular part of A is not referenced. On exit, the 
!>           lower triangular part of the array A is overwritten by the 
!>           lower triangular part of the updated matrix.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA 
      INTEGER INCX,INCY,LDA,N 
      CHARACTER UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),X(*),Y(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ZERO 
      PARAMETER (ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP1,TEMP2 
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
      INFO = 1 
      ELSE IF (N.LT.0) THEN 
      INFO = 2 
      ELSE IF (INCX.EQ.0) THEN 
      INFO = 5 
      ELSE IF (INCY.EQ.0) THEN 
      INFO = 7 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
      INFO = 9 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DSYR2 ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. (ALPHA.EQ.ZERO)) RETURN 
!                                                                       
!     Set up the start points in X and Y if the increments are not both 
!     unity.                                                            
!                                                                       
      IF ((INCX.NE.1) .OR. (INCY.NE.1)) THEN 
      IF (INCX.GT.0) THEN 
            KX = 1 
      ELSE 
            KX = 1 - (N-1)*INCX 
      END IF 
      IF (INCY.GT.0) THEN 
            KY = 1 
      ELSE 
            KY = 1 - (N-1)*INCY 
      END IF 
      JX = KX 
      JY = KY 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through the triangular part   
!     of A.                                                             
!                                                                       
      IF (LSAME(UPLO,'U')) THEN 
!                                                                       
!        Form  A  when A is stored in the upper triangle.               
!                                                                       
      IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
            DO 20 J = 1,N 
                  IF ((X(J).NE.ZERO) .OR. (Y(J).NE.ZERO)) THEN 
                  TEMP1 = ALPHA*Y(J) 
                  TEMP2 = ALPHA*X(J) 
                  DO 10 I = 1,J 
                        A(I,J) = A(I,J) + X(I)*TEMP1 + Y(I)*TEMP2 
10                 CONTINUE 
                  END IF 
20         CONTINUE 
      ELSE 
            DO 40 J = 1,N 
                  IF ((X(JX).NE.ZERO) .OR. (Y(JY).NE.ZERO)) THEN 
                  TEMP1 = ALPHA*Y(JY) 
                  TEMP2 = ALPHA*X(JX) 
                  IX = KX 
                  IY = KY 
                  DO 30 I = 1,J 
                        A(I,J) = A(I,J) + X(IX)*TEMP1 + Y(IY)*TEMP2 
                        IX = IX + INCX 
                        IY = IY + INCY 
30                 CONTINUE 
                  END IF 
                  JX = JX + INCX 
                  JY = JY + INCY 
40         CONTINUE 
      END IF 
      ELSE 
!                                                                       
!        Form  A  when A is stored in the lower triangle.               
!                                                                       
      IF ((INCX.EQ.1) .AND. (INCY.EQ.1)) THEN 
            DO 60 J = 1,N 
                  IF ((X(J).NE.ZERO) .OR. (Y(J).NE.ZERO)) THEN 
                  TEMP1 = ALPHA*Y(J) 
                  TEMP2 = ALPHA*X(J) 
                  DO 50 I = J,N 
                        A(I,J) = A(I,J) + X(I)*TEMP1 + Y(I)*TEMP2 
50                 CONTINUE 
                  END IF 
60         CONTINUE 
      ELSE 
            DO 80 J = 1,N 
                  IF ((X(JX).NE.ZERO) .OR. (Y(JY).NE.ZERO)) THEN 
                  TEMP1 = ALPHA*Y(JY) 
                  TEMP2 = ALPHA*X(JX) 
                  IX = JX 
                  IY = JY 
                  DO 70 I = J,N 
                        A(I,J) = A(I,J) + X(IX)*TEMP1 + Y(IY)*TEMP2 
                        IX = IX + INCX 
                        IY = IY + INCY 
70                 CONTINUE 
                  END IF 
                  JX = JX + INCX 
                  JY = JY + INCY 
80         CONTINUE 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DSYR2 .                                                    
!                                                                       
      END                                           
!> \brief \b DSYR2K                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)  
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA,BETA                                     
!       INTEGER K,LDA,LDB,LDC,N                                         
!       CHARACTER TRANS,UPLO                                            
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)                     
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYR2K  performs one of the symmetric rank 2k operations             
!>                                                                      
!>    C := alpha*A*B**T + alpha*B*A**T + beta*C,                        
!>                                                                      
!> or                                                                   
!>                                                                      
!>    C := alpha*A**T*B + alpha*B**T*A + beta*C,                        
!>                                                                      
!> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
!> and  A and B  are  n by k  matrices  in the  first  case  and  k by n
!> matrices in the second case.                                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On  entry,   UPLO  specifies  whether  the  upper  or  lowe
!>           triangular  part  of the  array  C  is to be  referenced  a
!>           follows:                                                   
!>                                                                      
!>              UPLO = 'U' or 'u'   Only the  upper triangular part of  
!>                                  is to be referenced.                
!>                                                                      
!>              UPLO = 'L' or 'l'   Only the  lower triangular part of  
!>                                  is to be referenced.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry,  TRANS  specifies the operation to be performed a
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T + 
!>                                        beta*C.                       
!>                                                                      
!>              TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A + 
!>                                        beta*C.                       
!>                                                                      
!>              TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A + 
!>                                        beta*C.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry,  N specifies the order of the matrix C.  N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] K                                                         
!> \verbatim                                                            
!>          K is INTEGER                                                
!>           On entry with  TRANS = 'N' or 'n',  K  specifies  the numbe
!>           of  columns  of the  matrices  A and B,  and on  entry  wit
!>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  numbe
!>           of rows of the matrices  A and B.  K must be at least  zero
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry, ALPHA specifies the scalar alpha.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka
!>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.        
!>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by 
!>           part of the array  A  must contain the matrix  A,  otherwis
!>           the leading  k by n  part of the array  A  must contain  th
!>           matrix A.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n
!>           then  LDA must be at least  max( 1, n ), otherwise  LDA mus
!>           be at least  max( 1, k ).                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb
!>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.        
!>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by 
!>           part of the array  B  must contain the matrix  B,  otherwis
!>           the leading  k by n  part of the array  B  must contain  th
!>           matrix B.                                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n
!>           then  LDB must be at least  max( 1, n ), otherwise  LDB mus
!>           be at least  max( 1, k ).                                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] BETA                                                      
!> \verbatim                                                            
!>          BETA is DOUBLE PRECISION.                                   
!>           On entry, BETA specifies the scalar beta.                  
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] C                                                     
!> \verbatim                                                            
!>          C is DOUBLE PRECISION array, dimension ( LDC, N )           
!>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
!>           upper triangular part of the array C must contain the upper
!>           triangular part  of the  symmetric matrix  and the strictly
!>           lower triangular part of C is not referenced.  On exit, the
!>           upper triangular part of the array  C is overwritten by the
!>           upper triangular part of the updated matrix.               
!>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
!>           lower triangular part of the array C must contain the lower
!>           triangular part  of the  symmetric matrix  and the strictly
!>           upper triangular part of C is not referenced.  On exit, the
!>           lower triangular part of the array  C is overwritten by the
!>           lower triangular part of the updated matrix.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDC                                                       
!> \verbatim                                                            
!>          LDC is INTEGER                                              
!>           On entry, LDC specifies the first dimension of C as declare
!>           in  the  calling  (sub)  program.   LDC  must  be  at  leas
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA,BETA 
      INTEGER K,LDA,LDB,LDC,N 
      CHARACTER TRANS,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP1,TEMP2 
      INTEGER I,INFO,J,L,NROWA 
      LOGICAL UPPER 
!     ..                                                                
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
      NROWA = N 
      ELSE 
      NROWA = K 
      END IF 
      UPPER = LSAME(UPLO,'U') 
!                                                                       
      INFO = 0 
      IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN 
      INFO = 1 
      ELSE IF ((.NOT.LSAME(TRANS,'N')) .AND.                            &
&         (.NOT.LSAME(TRANS,'T')) .AND.                            &
&         (.NOT.LSAME(TRANS,'C'))) THEN                            
      INFO = 2 
      ELSE IF (N.LT.0) THEN 
      INFO = 3 
      ELSE IF (K.LT.0) THEN 
      INFO = 4 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
      INFO = 7 
      ELSE IF (LDB.LT.MAX(1,NROWA)) THEN 
      INFO = 9 
      ELSE IF (LDC.LT.MAX(1,N)) THEN 
      INFO = 12 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DSYR2K',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ((N.EQ.0) .OR. (((ALPHA.EQ.ZERO).OR.                           &
&    (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN                         
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
      IF (UPPER) THEN 
            IF (BETA.EQ.ZERO) THEN 
                  DO 20 J = 1,N 
                  DO 10 I = 1,J 
                        C(I,J) = ZERO 
10                 CONTINUE 
20             CONTINUE 
            ELSE 
                  DO 40 J = 1,N 
                  DO 30 I = 1,J 
                        C(I,J) = BETA*C(I,J) 
30                 CONTINUE 
40             CONTINUE 
            END IF 
      ELSE 
            IF (BETA.EQ.ZERO) THEN 
                  DO 60 J = 1,N 
                  DO 50 I = J,N 
                        C(I,J) = ZERO 
50                 CONTINUE 
60             CONTINUE 
            ELSE 
                  DO 80 J = 1,N 
                  DO 70 I = J,N 
                        C(I,J) = BETA*C(I,J) 
70                 CONTINUE 
80             CONTINUE 
            END IF 
      END IF 
      RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  C := alpha*A*B**T + alpha*B*A**T + C.                    
!                                                                       
      IF (UPPER) THEN 
            DO 130 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                  DO 90 I = 1,J 
                        C(I,J) = ZERO 
90                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                  DO 100 I = 1,J 
                        C(I,J) = BETA*C(I,J) 
100                 CONTINUE 
                  END IF 
                  DO 120 L = 1,K 
                  IF ((A(J,L).NE.ZERO) .OR. (B(J,L).NE.ZERO)) THEN 
                        TEMP1 = ALPHA*B(J,L) 
                        TEMP2 = ALPHA*A(J,L) 
                        DO 110 I = 1,J 
                              C(I,J) = C(I,J) + A(I,L)*TEMP1 +          &
&                                 B(I,L)*TEMP2                     
110                     CONTINUE 
                  END IF 
120             CONTINUE 
130         CONTINUE 
      ELSE 
            DO 180 J = 1,N 
                  IF (BETA.EQ.ZERO) THEN 
                  DO 140 I = J,N 
                        C(I,J) = ZERO 
140                 CONTINUE 
                  ELSE IF (BETA.NE.ONE) THEN 
                  DO 150 I = J,N 
                        C(I,J) = BETA*C(I,J) 
150                 CONTINUE 
                  END IF 
                  DO 170 L = 1,K 
                  IF ((A(J,L).NE.ZERO) .OR. (B(J,L).NE.ZERO)) THEN 
                        TEMP1 = ALPHA*B(J,L) 
                        TEMP2 = ALPHA*A(J,L) 
                        DO 160 I = J,N 
                              C(I,J) = C(I,J) + A(I,L)*TEMP1 +          &
&                                 B(I,L)*TEMP2                     
160                     CONTINUE 
                  END IF 
170             CONTINUE 
180         CONTINUE 
      END IF 
      ELSE 
!                                                                       
!        Form  C := alpha*A**T*B + alpha*B**T*A + C.                    
!                                                                       
      IF (UPPER) THEN 
            DO 210 J = 1,N 
                  DO 200 I = 1,J 
                  TEMP1 = ZERO 
                  TEMP2 = ZERO 
                  DO 190 L = 1,K 
                        TEMP1 = TEMP1 + A(L,I)*B(L,J) 
                        TEMP2 = TEMP2 + B(L,I)*A(L,J) 
190                 CONTINUE 
                  IF (BETA.EQ.ZERO) THEN 
                        C(I,J) = ALPHA*TEMP1 + ALPHA*TEMP2 
                  ELSE 
                        C(I,J) = BETA*C(I,J) + ALPHA*TEMP1 +          &
&                             ALPHA*TEMP2                          
                  END IF 
200             CONTINUE 
210         CONTINUE 
      ELSE 
            DO 240 J = 1,N 
                  DO 230 I = J,N 
                  TEMP1 = ZERO 
                  TEMP2 = ZERO 
                  DO 220 L = 1,K 
                        TEMP1 = TEMP1 + A(L,I)*B(L,J) 
                        TEMP2 = TEMP2 + B(L,I)*A(L,J) 
220                 CONTINUE 
                  IF (BETA.EQ.ZERO) THEN 
                        C(I,J) = ALPHA*TEMP1 + ALPHA*TEMP2 
                  ELSE 
                        C(I,J) = BETA*C(I,J) + ALPHA*TEMP1 +          &
&                             ALPHA*TEMP2                          
                  END IF 
230             CONTINUE 
240         CONTINUE 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DSYR2K.                                                    
!                                                                       
      END                                           
!> \brief \b DSYTD2 reduces a symmetric matrix to real symmetric tridiag
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSYTD2 + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )           
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            INFO, LDA, N                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * )        
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal    
!> form T by an orthogonal similarity transformation: Q**T * A * Q = T. 
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          Specifies whether the upper or lower triangular part of the 
!>          symmetric matrix A is stored:                               
!>          = 'U':  Upper triangular                                    
!>          = 'L':  Lower triangular                                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          n-by-n upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading n-by-n lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
!>          of A are overwritten by the corresponding elements of the   
!>          tridiagonal matrix T, and the elements above the first      
!>          superdiagonal, with the array TAU, represent the orthogonal 
!>          matrix Q as a product of elementary reflectors; if UPLO     
!>          = 'L', the diagonal and first subdiagonal of A are over-    
!>          written by the corresponding elements of the tridiagonal    
!>          matrix T, and the elements below the first subdiagonal, with
!>          the array TAU, represent the orthogonal matrix Q as a produc
!>          of elementary reflectors. See Further Details.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The diagonal elements of the tridiagonal matrix T:          
!>          D(i) = A(i,i).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The off-diagonal elements of the tridiagonal matrix T:      
!>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (N-1)              
!>          The scalar factors of the elementary reflectors (see Further
!>          Details).                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value. 
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleSYcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n-1) . . . H(2) H(1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in            
!>  A(1:i-1,i+1), and tau in TAU(i).                                    
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(n-1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5:                                                         
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  d   e   v2  v3  v4 )              (  d                  )      
!>    (      d   e   v3  v4 )              (  e   d              )      
!>    (          d   e   v4 )              (  v1  e   d          )      
!>    (              d   e  )              (  v1  v2  e   d      )      
!>    (                  d  )              (  v1  v2  v3  e   d  )      
!>                                                                      
!>  where d and e denote diagonal and off-diagonal elements of T, and vi
!>  denotes an element of the vector defining H(i).                     
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            INFO, LDA, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO, HALF 
      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0,                   &
&                   HALF = 1.0D0 / 2.0D0 )                         
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            UPPER 
      INTEGER            I 
      DOUBLE PRECISION   ALPHA, TAUI 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DAXPY, DLARFG, DSYMV, DSYR2, XERBLA 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      DOUBLE PRECISION   DDOT 
      EXTERNAL           LSAME, DDOT 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      INFO = 0 
      UPPER = LSAME( UPLO, 'U' ) 
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
      INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -2 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
      INFO = -4 
      END IF 
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DSYTD2', -INFO ) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 )                                                      &
&   RETURN                                                         
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Reduce the upper triangle of A                                 
!                                                                       
      DO 10 I = N - 1, 1, -1 
!                                                                       
!           Generate elementary reflector H(i) = I - tau * v * v**T     
!           to annihilate A(1:i-1,i+1)                                  
!                                                                       
            CALL DLARFG( I, A( I, I+1 ), A( 1, I+1 ), 1, TAUI ) 
            E( I ) = A( I, I+1 ) 
!                                                                       
            IF( TAUI.NE.ZERO ) THEN 
!                                                                       
!              Apply H(i) from both sides to A(1:i,1:i)                 
!                                                                       
            A( I, I+1 ) = ONE 
!                                                                       
!              Compute  x := tau * A * v  storing x in TAU(1:i)         
!                                                                       
            CALL DSYMV( UPLO, I, TAUI, A, LDA, A( 1, I+1 ), 1, ZERO, &
&                     TAU, 1 )                                     
!                                                                       
!              Compute  w := x - 1/2 * tau * (x**T * v) * v             
!                                                                       
            ALPHA = -HALF*TAUI*DDOT( I, TAU, 1, A( 1, I+1 ), 1 ) 
            CALL DAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 ) 
!                                                                       
!              Apply the transformation as a rank-2 update:             
!                 A := A - v * w**T - w * v**T                          
!                                                                       
            CALL DSYR2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A,    &
&                     LDA )                                        
!                                                                       
            A( I, I+1 ) = E( I ) 
            END IF 
            D( I+1 ) = A( I+1, I+1 ) 
            TAU( I ) = TAUI 
10    CONTINUE 
      D( 1 ) = A( 1, 1 ) 
      ELSE 
!                                                                       
!        Reduce the lower triangle of A                                 
!                                                                       
      DO 20 I = 1, N - 1 
!                                                                       
!           Generate elementary reflector H(i) = I - tau * v * v**T     
!           to annihilate A(i+2:n,i)                                    
!                                                                       
            CALL DLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1,    &
&                   TAUI )                                         
            E( I ) = A( I+1, I ) 
!                                                                       
            IF( TAUI.NE.ZERO ) THEN 
!                                                                       
!              Apply H(i) from both sides to A(i+1:n,i+1:n)             
!                                                                       
            A( I+1, I ) = ONE 
!                                                                       
!              Compute  x := tau * A * v  storing y in TAU(i:n-1)       
!                                                                       
            CALL DSYMV( UPLO, N-I, TAUI, A( I+1, I+1 ), LDA,         &
&                     A( I+1, I ), 1, ZERO, TAU( I ), 1 )          
!                                                                       
!              Compute  w := x - 1/2 * tau * (x**T * v) * v             
!                                                                       
            ALPHA = -HALF*TAUI*DDOT( N-I, TAU( I ), 1, A( I+1, I ),  &
&                 1 )                                              
            CALL DAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 ) 
!                                                                       
!              Apply the transformation as a rank-2 update:             
!                 A := A - v * w**T - w * v**T                          
!                                                                       
            CALL DSYR2( UPLO, N-I, -ONE, A( I+1, I ), 1, TAU( I ), 1,&
&                     A( I+1, I+1 ), LDA )                         
!                                                                       
            A( I+1, I ) = E( I ) 
            END IF 
            D( I ) = A( I, I ) 
            TAU( I ) = TAUI 
20    CONTINUE 
      D( N ) = A( N, N ) 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DSYTD2                                                     
!                                                                       
      END                                           
!> \brief \b DSYTRD                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download DSYTRD + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER          UPLO                                         
!       INTEGER            INFO, LDA, LWORK, N                          
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * ),       
!      $                   WORK( * )                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DSYTRD reduces a real symmetric matrix A to real symmetric           
!> tridiagonal form T by an orthogonal similarity transformation:       
!> Q**T * A * Q = T.                                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>          = 'U':  Upper triangle of A is stored;                      
!>          = 'L':  Lower triangle of A is stored.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The order of the matrix A.  N >= 0.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] A                                                     
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          On entry, the symmetric matrix A.  If UPLO = 'U', the leadin
!>          N-by-N upper triangular part of A contains the upper        
!>          triangular part of the matrix A, and the strictly lower     
!>          triangular part of A is not referenced.  If UPLO = 'L', the 
!>          leading N-by-N lower triangular part of A contains the lower
!>          triangular part of the matrix A, and the strictly upper     
!>          triangular part of A is not referenced.                     
!>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
!>          of A are overwritten by the corresponding elements of the   
!>          tridiagonal matrix T, and the elements above the first      
!>          superdiagonal, with the array TAU, represent the orthogonal 
!>          matrix Q as a product of elementary reflectors; if UPLO     
!>          = 'L', the diagonal and first subdiagonal of A are over-    
!>          written by the corresponding elements of the tridiagonal    
!>          matrix T, and the elements below the first subdiagonal, with
!>          the array TAU, represent the orthogonal matrix Q as a produc
!>          of elementary reflectors. See Further Details.              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A.  LDA >= max(1,N).     
!> \endverbatim                                                         
!>                                                                      
!> \param[out] D                                                        
!> \verbatim                                                            
!>          D is DOUBLE PRECISION array, dimension (N)                  
!>          The diagonal elements of the tridiagonal matrix T:          
!>          D(i) = A(i,i).                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[out] E                                                        
!> \verbatim                                                            
!>          E is DOUBLE PRECISION array, dimension (N-1)                
!>          The off-diagonal elements of the tridiagonal matrix T:      
!>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'
!> \endverbatim                                                         
!>                                                                      
!> \param[out] TAU                                                      
!> \verbatim                                                            
!>          TAU is DOUBLE PRECISION array, dimension (N-1)              
!>          The scalar factors of the elementary reflectors (see Further
!>          Details).                                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[out] WORK                                                     
!> \verbatim                                                            
!>          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))    
!>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>          The dimension of the array WORK.  LWORK >= 1.               
!>          For optimum performance LWORK >= N*NB, where NB is the      
!>          optimal blocksize.                                          
!>                                                                      
!>          If LWORK = -1, then a workspace query is assumed; the routin
!>          only calculates the optimal size of the WORK array, returns 
!>          this value as the first entry of the WORK array, and no erro
!>          message related to LWORK is issued by XERBLA.               
!> \endverbatim                                                         
!>                                                                      
!> \param[out] INFO                                                     
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          = 0:  successful exit                                       
!>          < 0:  if INFO = -i, the i-th argument had an illegal value  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup doubleSYcomputational                                       
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  If UPLO = 'U', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(n-1) . . . H(2) H(1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in            
!>  A(1:i-1,i+1), and tau in TAU(i).                                    
!>                                                                      
!>  If UPLO = 'L', the matrix Q is represented as a product of elementar
!>  reflectors                                                          
!>                                                                      
!>     Q = H(1) H(2) . . . H(n-1).                                      
!>                                                                      
!>  Each H(i) has the form                                              
!>                                                                      
!>     H(i) = I - tau * v * v**T                                        
!>                                                                      
!>  where tau is a real scalar, and v is a real vector with             
!>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!>  and tau in TAU(i).                                                  
!>                                                                      
!>  The contents of A on exit are illustrated by the following examples 
!>  with n = 5:                                                         
!>                                                                      
!>  if UPLO = 'U':                       if UPLO = 'L':                 
!>                                                                      
!>    (  d   e   v2  v3  v4 )              (  d                  )      
!>    (      d   e   v3  v4 )              (  e   d              )      
!>    (          d   e   v4 )              (  v1  e   d          )      
!>    (              d   e  )              (  v1  v2  e   d      )      
!>    (                  d  )              (  v1  v2  v3  e   d  )      
!>                                                                      
!>  where d and e denote diagonal and off-diagonal elements of T, and vi
!>  denotes an element of the vector defining H(i).                     
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO ) 
!                                                                       
!  -- LAPACK computational routine (version 3.7.0) --                   
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO 
      INTEGER            INFO, LDA, LWORK, N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * ),         &
&                   WORK( * )                                      
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE 
      PARAMETER          ( ONE = 1.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY, UPPER 
      INTEGER            I, IINFO, IWS, J, KK, LDWORK, LWKOPT, NB,      &
&                   NBMIN, NX                                      
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL           DLATRD, DSYR2K, DSYTD2, XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      INTEGER            ILAENV 
      EXTERNAL           LSAME, ILAENV 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      INFO = 0 
      UPPER = LSAME( UPLO, 'U' ) 
      LQUERY = ( LWORK.EQ.-1 ) 
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN 
      INFO = -1 
      ELSE IF( N.LT.0 ) THEN 
      INFO = -2 
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN 
      INFO = -4 
      ELSE IF( LWORK.LT.1 .AND. .NOT.LQUERY ) THEN 
      INFO = -9 
      END IF 
!                                                                       
      IF( INFO.EQ.0 ) THEN 
!                                                                       
!        Determine the block size.                                      
!                                                                       
      NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 ) 
      LWKOPT = N*NB 
      WORK( 1 ) = LWKOPT 
      END IF 
!                                                                       
      IF( INFO.NE.0 ) THEN 
      CALL XERBLA( 'DSYTRD', -INFO ) 
      RETURN 
      ELSE IF( LQUERY ) THEN 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 ) THEN 
      WORK( 1 ) = 1 
      RETURN 
      END IF 
!                                                                       
      NX = N 
      IWS = 1 
      IF( NB.GT.1 .AND. NB.LT.N ) THEN 
!                                                                       
!        Determine when to cross over from blocked to unblocked code    
!        (last block is always handled by unblocked code).              
!                                                                       
      NX = MAX( NB, ILAENV( 3, 'DSYTRD', UPLO, N, -1, -1, -1 ) ) 
      IF( NX.LT.N ) THEN 
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = N 
            IWS = LDWORK*NB 
            IF( LWORK.LT.IWS ) THEN 
!                                                                       
!              Not enough workspace to use optimal NB:  determine the   
!              minimum value of NB, and reduce NB or force use of       
!              unblocked code by setting NX = N.                        
!                                                                       
            NB = MAX( LWORK / LDWORK, 1 ) 
            NBMIN = ILAENV( 2, 'DSYTRD', UPLO, N, -1, -1, -1 ) 
            IF( NB.LT.NBMIN )                                        &
&            NX = N                                                
            END IF 
      ELSE 
            NX = N 
      END IF 
      ELSE 
      NB = 1 
      END IF 
!                                                                       
      IF( UPPER ) THEN 
!                                                                       
!        Reduce the upper triangle of A.                                
!        Columns 1:kk are handled by the unblocked method.              
!                                                                       
      KK = N - ( ( N-NX+NB-1 ) / NB )*NB 
      DO 20 I = N - NB + 1, KK + 1, -NB 
!                                                                       
!           Reduce columns i:i+nb-1 to tridiagonal form and form the    
!           matrix W which is needed to update the unreduced part of    
!           the matrix                                                  
!                                                                       
            CALL DLATRD( UPLO, I+NB-1, NB, A, LDA, E, TAU, WORK,        &
&                   LDWORK )                                       
!                                                                       
!           Update the unreduced submatrix A(1:i-1,1:i-1), using an     
!           update of the form:  A := A - V*W**T - W*V**T               
!                                                                       
            CALL DSYR2K( UPLO, 'No transpose', I-1, NB, -ONE, A( 1, I ),&
&                   LDA, WORK, LDWORK, ONE, A, LDA )               
!                                                                       
!           Copy superdiagonal elements back into A, and diagonal       
!           elements into D                                             
!                                                                       
            DO 10 J = I, I + NB - 1 
            A( J-1, J ) = E( J-1 ) 
            D( J ) = A( J, J ) 
10       CONTINUE 
20    CONTINUE 
!                                                                       
!        Use unblocked code to reduce the last or only block            
!                                                                       
      CALL DSYTD2( UPLO, KK, A, LDA, D, E, TAU, IINFO ) 
      ELSE 
!                                                                       
!        Reduce the lower triangle of A                                 
!                                                                       
      DO 40 I = 1, N - NX, NB 
!                                                                       
!           Reduce columns i:i+nb-1 to tridiagonal form and form the    
!           matrix W which is needed to update the unreduced part of    
!           the matrix                                                  
!                                                                       
            CALL DLATRD( UPLO, N-I+1, NB, A( I, I ), LDA, E( I ),       &
&                   TAU( I ), WORK, LDWORK )                       
!                                                                       
!           Update the unreduced submatrix A(i+ib:n,i+ib:n), using      
!           an update of the form:  A := A - V*W**T - W*V**T            
!                                                                       
            CALL DSYR2K( UPLO, 'No transpose', N-I-NB+1, NB, -ONE,      &
&                   A( I+NB, I ), LDA, WORK( NB+1 ), LDWORK, ONE,  &
&                   A( I+NB, I+NB ), LDA )                         
!                                                                       
!           Copy subdiagonal elements back into A, and diagonal         
!           elements into D                                             
!                                                                       
            DO 30 J = I, I + NB - 1 
            A( J+1, J ) = E( J ) 
            D( J ) = A( J, J ) 
30       CONTINUE 
40    CONTINUE 
!                                                                       
!        Use unblocked code to reduce the last or only block            
!                                                                       
      CALL DSYTD2( UPLO, N-I+1, A( I, I ), LDA, D( I ), E( I ),      &
&                TAU( I ), IINFO )                                 
      END IF 
!                                                                       
      WORK( 1 ) = LWKOPT 
      RETURN 
!                                                                       
!     End of DSYTRD                                                     
!                                                                       
      END                                           
!> \brief \b DTRMM                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)   
!                                                                       
!       .. Scalar Arguments ..                                          
!       DOUBLE PRECISION ALPHA                                          
!       INTEGER LDA,LDB,M,N                                             
!       CHARACTER DIAG,SIDE,TRANSA,UPLO                                 
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),B(LDB,*)                              
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DTRMM  performs one of the matrix-matrix operations                  
!>                                                                      
!>    B := alpha*op( A )*B,   or   B := alpha*B*op( A ),                
!>                                                                      
!> where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
!> non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
!>                                                                      
!>    op( A ) = A   or   op( A ) = A**T.                                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SIDE                                                      
!> \verbatim                                                            
!>          SIDE is CHARACTER*1                                         
!>           On entry,  SIDE specifies whether  op( A ) multiplies B fro
!>           the left or right as follows:                              
!>                                                                      
!>              SIDE = 'L' or 'l'   B := alpha*op( A )*B.               
!>                                                                      
!>              SIDE = 'R' or 'r'   B := alpha*B*op( A ).               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the matrix A is an upper o
!>           lower triangular matrix as follows:                        
!>                                                                      
!>              UPLO = 'U' or 'u'   A is an upper triangular matrix.    
!>                                                                      
!>              UPLO = 'L' or 'l'   A is a lower triangular matrix.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANSA                                                    
!> \verbatim                                                            
!>          TRANSA is CHARACTER*1                                       
!>           On entry, TRANSA specifies the form of op( A ) to be used i
!>           the matrix multiplication as follows:                      
!>                                                                      
!>              TRANSA = 'N' or 'n'   op( A ) = A.                      
!>                                                                      
!>              TRANSA = 'T' or 't'   op( A ) = A**T.                   
!>                                                                      
!>              TRANSA = 'C' or 'c'   op( A ) = A**T.                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIAG                                                      
!> \verbatim                                                            
!>          DIAG is CHARACTER*1                                         
!>           On entry, DIAG specifies whether or not A is unit triangula
!>           as follows:                                                
!>                                                                      
!>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 
!>                                                                      
!>              DIAG = 'N' or 'n'   A is not assumed to be unit         
!>                                  triangular.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>           On entry, M specifies the number of rows of B. M must be at
!>           least zero.                                                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the number of columns of B.  N must b
!>           at least zero.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ALPHA                                                     
!> \verbatim                                                            
!>          ALPHA is DOUBLE PRECISION.                                  
!>           On entry,  ALPHA specifies the scalar  alpha. When  alpha i
!>           zero then  A is not referenced and  B need not be set befor
!>           entry.                                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>           A is DOUBLE PRECISION array, dimension ( LDA, k ), where k 
!>           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'
!>           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by 
!>           upper triangular part of the array  A must contain the uppe
!>           triangular matrix  and the strictly lower triangular part o
!>           A is not referenced.                                       
!>           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by 
!>           lower triangular part of the array  A must contain the lowe
!>           triangular matrix  and the strictly upper triangular part o
!>           A is not referenced.                                       
!>           Note that when  DIAG = 'U' or 'u',  the diagonal elements o
!>           A  are not referenced either,  but are assumed to be  unity
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program.  When  SIDE = 'L' or 'l'  the
!>           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r
!>           then LDA must be at least max( 1, n ).                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] B                                                     
!> \verbatim                                                            
!>          B is DOUBLE PRECISION array, dimension ( LDB, N )           
!>           Before entry,  the leading  m by n part of the array  B mus
!>           contain the matrix  B,  and  on exit  is overwritten  by th
!>           transformed matrix.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDB                                                       
!> \verbatim                                                            
!>          LDB is INTEGER                                              
!>           On entry, LDB specifies the first dimension of B as declare
!>           in  the  calling  (sub)  program.   LDB  must  be  at  leas
!>           max( 1, m ).                                               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level3                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 3 Blas routine.                                               
!>                                                                      
!>  -- Written on 8-February-1989.                                      
!>     Jack Dongarra, Argonne National Laboratory.                      
!>     Iain Duff, AERE Harwell.                                         
!>     Jeremy Du Croz, Numerical Algorithms Group Ltd.                  
!>     Sven Hammarling, Numerical Algorithms Group Ltd.                 
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB) 
!                                                                       
!  -- Reference BLAS level3 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION ALPHA 
      INTEGER LDA,LDB,M,N 
      CHARACTER DIAG,SIDE,TRANSA,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),B(LDB,*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP 
      INTEGER I,INFO,J,K,NROWA 
      LOGICAL LSIDE,NOUNIT,UPPER 
!     ..                                                                
!     .. Parameters ..                                                  
      DOUBLE PRECISION ONE,ZERO 
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0) 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      LSIDE = LSAME(SIDE,'L') 
      IF (LSIDE) THEN 
      NROWA = M 
      ELSE 
      NROWA = N 
      END IF 
      NOUNIT = LSAME(DIAG,'N') 
      UPPER = LSAME(UPLO,'U') 
!                                                                       
      INFO = 0 
      IF ((.NOT.LSIDE) .AND. (.NOT.LSAME(SIDE,'R'))) THEN 
      INFO = 1 
      ELSE IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN 
      INFO = 2 
      ELSE IF ((.NOT.LSAME(TRANSA,'N')) .AND.                           &
&         (.NOT.LSAME(TRANSA,'T')) .AND.                           &
&         (.NOT.LSAME(TRANSA,'C'))) THEN                           
      INFO = 3 
      ELSE IF ((.NOT.LSAME(DIAG,'U')) .AND. (.NOT.LSAME(DIAG,'N'))) THEN 
      INFO = 4 
      ELSE IF (M.LT.0) THEN 
      INFO = 5 
      ELSE IF (N.LT.0) THEN 
      INFO = 6 
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN 
      INFO = 9 
      ELSE IF (LDB.LT.MAX(1,M)) THEN 
      INFO = 11 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DTRMM ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (M.EQ.0 .OR. N.EQ.0) RETURN 
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
      DO 20 J = 1,N 
            DO 10 I = 1,M 
                  B(I,J) = ZERO 
10         CONTINUE 
20     CONTINUE 
      RETURN 
      END IF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSIDE) THEN 
      IF (LSAME(TRANSA,'N')) THEN 
!                                                                       
!           Form  B := alpha*A*B.                                       
!                                                                       
            IF (UPPER) THEN 
                  DO 50 J = 1,N 
                  DO 40 K = 1,M 
                        IF (B(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*B(K,J) 
                              DO 30 I = 1,K - 1 
                              B(I,J) = B(I,J) + TEMP*A(I,K) 
30                         CONTINUE 
                              IF (NOUNIT) TEMP = TEMP*A(K,K) 
                              B(K,J) = TEMP 
                        END IF 
40                 CONTINUE 
50             CONTINUE 
            ELSE 
                  DO 80 J = 1,N 
                  DO 70 K = M,1,-1 
                        IF (B(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*B(K,J) 
                              B(K,J) = TEMP 
                              IF (NOUNIT) B(K,J) = B(K,J)*A(K,K) 
                              DO 60 I = K + 1,M 
                              B(I,J) = B(I,J) + TEMP*A(I,K) 
60                         CONTINUE 
                        END IF 
70                 CONTINUE 
80             CONTINUE 
            END IF 
      ELSE 
!                                                                       
!           Form  B := alpha*A**T*B.                                    
!                                                                       
            IF (UPPER) THEN 
                  DO 110 J = 1,N 
                  DO 100 I = M,1,-1 
                        TEMP = B(I,J) 
                        IF (NOUNIT) TEMP = TEMP*A(I,I) 
                        DO 90 K = 1,I - 1 
                              TEMP = TEMP + A(K,I)*B(K,J) 
90                     CONTINUE 
                        B(I,J) = ALPHA*TEMP 
100                 CONTINUE 
110             CONTINUE 
            ELSE 
                  DO 140 J = 1,N 
                  DO 130 I = 1,M 
                        TEMP = B(I,J) 
                        IF (NOUNIT) TEMP = TEMP*A(I,I) 
                        DO 120 K = I + 1,M 
                              TEMP = TEMP + A(K,I)*B(K,J) 
120                     CONTINUE 
                        B(I,J) = ALPHA*TEMP 
130                 CONTINUE 
140             CONTINUE 
            END IF 
      END IF 
      ELSE 
      IF (LSAME(TRANSA,'N')) THEN 
!                                                                       
!           Form  B := alpha*B*A.                                       
!                                                                       
            IF (UPPER) THEN 
                  DO 180 J = N,1,-1 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 150 I = 1,M 
                        B(I,J) = TEMP*B(I,J) 
150                 CONTINUE 
                  DO 170 K = 1,J - 1 
                        IF (A(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*A(K,J) 
                              DO 160 I = 1,M 
                              B(I,J) = B(I,J) + TEMP*B(I,K) 
160                         CONTINUE 
                        END IF 
170                 CONTINUE 
180             CONTINUE 
            ELSE 
                  DO 220 J = 1,N 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 190 I = 1,M 
                        B(I,J) = TEMP*B(I,J) 
190                 CONTINUE 
                  DO 210 K = J + 1,N 
                        IF (A(K,J).NE.ZERO) THEN 
                              TEMP = ALPHA*A(K,J) 
                              DO 200 I = 1,M 
                              B(I,J) = B(I,J) + TEMP*B(I,K) 
200                         CONTINUE 
                        END IF 
210                 CONTINUE 
220             CONTINUE 
            END IF 
      ELSE 
!                                                                       
!           Form  B := alpha*B*A**T.                                    
!                                                                       
            IF (UPPER) THEN 
                  DO 260 K = 1,N 
                  DO 240 J = 1,K - 1 
                        IF (A(J,K).NE.ZERO) THEN 
                              TEMP = ALPHA*A(J,K) 
                              DO 230 I = 1,M 
                              B(I,J) = B(I,J) + TEMP*B(I,K) 
230                         CONTINUE 
                        END IF 
240                 CONTINUE 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP*A(K,K) 
                  IF (TEMP.NE.ONE) THEN 
                        DO 250 I = 1,M 
                              B(I,K) = TEMP*B(I,K) 
250                     CONTINUE 
                  END IF 
260             CONTINUE 
            ELSE 
                  DO 300 K = N,1,-1 
                  DO 280 J = K + 1,N 
                        IF (A(J,K).NE.ZERO) THEN 
                              TEMP = ALPHA*A(J,K) 
                              DO 270 I = 1,M 
                              B(I,J) = B(I,J) + TEMP*B(I,K) 
270                         CONTINUE 
                        END IF 
280                 CONTINUE 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP*A(K,K) 
                  IF (TEMP.NE.ONE) THEN 
                        DO 290 I = 1,M 
                              B(I,K) = TEMP*B(I,K) 
290                     CONTINUE 
                  END IF 
300             CONTINUE 
            END IF 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DTRMM .                                                    
!                                                                       
      END                                           
!> \brief \b DTRMV                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)                
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,LDA,N                                              
!       CHARACTER DIAG,TRANS,UPLO                                       
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION A(LDA,*),X(*)                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DTRMV  performs one of the matrix-vector operations                  
!>                                                                      
!>    x := A*x,   or   x := A**T*x,                                     
!>                                                                      
!> where x is an n element vector and  A is an n by n unit, or non-unit,
!> upper or lower triangular matrix.                                    
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] UPLO                                                      
!> \verbatim                                                            
!>          UPLO is CHARACTER*1                                         
!>           On entry, UPLO specifies whether the matrix is an upper or 
!>           lower triangular matrix as follows:                        
!>                                                                      
!>              UPLO = 'U' or 'u'   A is an upper triangular matrix.    
!>                                                                      
!>              UPLO = 'L' or 'l'   A is a lower triangular matrix.     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] TRANS                                                     
!> \verbatim                                                            
!>          TRANS is CHARACTER*1                                        
!>           On entry, TRANS specifies the operation to be performed as 
!>           follows:                                                   
!>                                                                      
!>              TRANS = 'N' or 'n'   x := A*x.                          
!>                                                                      
!>              TRANS = 'T' or 't'   x := A**T*x.                       
!>                                                                      
!>              TRANS = 'C' or 'c'   x := A**T*x.                       
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DIAG                                                      
!> \verbatim                                                            
!>          DIAG is CHARACTER*1                                         
!>           On entry, DIAG specifies whether or not A is unit          
!>           triangular as follows:                                     
!>                                                                      
!>              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 
!>                                                                      
!>              DIAG = 'N' or 'n'   A is not assumed to be unit         
!>                                  triangular.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>           On entry, N specifies the order of the matrix A.           
!>           N must be at least zero.                                   
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension ( LDA, N )           
!>           Before entry with  UPLO = 'U' or 'u', the leading n by n   
!>           upper triangular part of the array A must contain the upper
!>           triangular matrix and the strictly lower triangular part of
!>           A is not referenced.                                       
!>           Before entry with UPLO = 'L' or 'l', the leading n by n    
!>           lower triangular part of the array A must contain the lower
!>           triangular matrix and the strictly upper triangular part of
!>           A is not referenced.                                       
!>           Note that when  DIAG = 'U' or 'u', the diagonal elements of
!>           A are not referenced either, but are assumed to be unity.  
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>           On entry, LDA specifies the first dimension of A as declare
!>           in the calling (sub) program. LDA must be at least         
!>           max( 1, n ).                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in,out] X                                                     
!> \verbatim                                                            
!>          X is DOUBLE PRECISION array, dimension at least             
!>           ( 1 + ( n - 1 )*abs( INCX ) ).                             
!>           Before entry, the incremented array X must contain the n   
!>           element vector x. On exit, X is overwritten with the       
!>           transformed vector x.                                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>           On entry, INCX specifies the increment for the elements of 
!>           X. INCX must not be zero.                                  
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup double_blas_level2                                          
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  Level 2 Blas routine.                                               
!>  The vector and matrix arguments are not referenced when N = 0, or M 
!>                                                                      
!>  -- Written on 22-October-1986.                                      
!>     Jack Dongarra, Argonne National Lab.                             
!>     Jeremy Du Croz, Nag Central Office.                              
!>     Sven Hammarling, Nag Central Office.                             
!>     Richard Hanson, Sandia National Labs.                            
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX) 
!                                                                       
!  -- Reference BLAS level2 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,LDA,N 
      CHARACTER DIAG,TRANS,UPLO 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION A(LDA,*),X(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ZERO 
      PARAMETER (ZERO=0.0D+0) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION TEMP 
      INTEGER I,INFO,IX,J,JX,KX 
      LOGICAL NOUNIT 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL LSAME 
      EXTERNAL LSAME 
!     ..                                                                
!     .. External Subroutines ..                                        
      EXTERNAL XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT.LSAME(UPLO,'U') .AND. .NOT.LSAME(UPLO,'L')) THEN 
      INFO = 1 
      ELSE IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.  &
&         .NOT.LSAME(TRANS,'C')) THEN                              
      INFO = 2 
      ELSE IF (.NOT.LSAME(DIAG,'U') .AND. .NOT.LSAME(DIAG,'N')) THEN 
      INFO = 3 
      ELSE IF (N.LT.0) THEN 
      INFO = 4 
      ELSE IF (LDA.LT.MAX(1,N)) THEN 
      INFO = 6 
      ELSE IF (INCX.EQ.0) THEN 
      INFO = 8 
      END IF 
      IF (INFO.NE.0) THEN 
      CALL XERBLA('DTRMV ',INFO) 
      RETURN 
      END IF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
      NOUNIT = LSAME(DIAG,'N') 
!                                                                       
!     Set up the start point in X if the increment is not unity. This   
!     will be  ( N - 1 )*INCX  too small for descending loops.          
!                                                                       
      IF (INCX.LE.0) THEN 
      KX = 1 - (N-1)*INCX 
      ELSE IF (INCX.NE.1) THEN 
      KX = 1 
      END IF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF (LSAME(TRANS,'N')) THEN 
!                                                                       
!        Form  x := A*x.                                                
!                                                                       
      IF (LSAME(UPLO,'U')) THEN 
            IF (INCX.EQ.1) THEN 
                  DO 20 J = 1,N 
                  IF (X(J).NE.ZERO) THEN 
                        TEMP = X(J) 
                        DO 10 I = 1,J - 1 
                              X(I) = X(I) + TEMP*A(I,J) 
10                     CONTINUE 
                        IF (NOUNIT) X(J) = X(J)*A(J,J) 
                  END IF 
20             CONTINUE 
            ELSE 
                  JX = KX 
                  DO 40 J = 1,N 
                  IF (X(JX).NE.ZERO) THEN 
                        TEMP = X(JX) 
                        IX = KX 
                        DO 30 I = 1,J - 1 
                              X(IX) = X(IX) + TEMP*A(I,J) 
                              IX = IX + INCX 
30                     CONTINUE 
                        IF (NOUNIT) X(JX) = X(JX)*A(J,J) 
                  END IF 
                  JX = JX + INCX 
40             CONTINUE 
            END IF 
      ELSE 
            IF (INCX.EQ.1) THEN 
                  DO 60 J = N,1,-1 
                  IF (X(J).NE.ZERO) THEN 
                        TEMP = X(J) 
                        DO 50 I = N,J + 1,-1 
                              X(I) = X(I) + TEMP*A(I,J) 
50                     CONTINUE 
                        IF (NOUNIT) X(J) = X(J)*A(J,J) 
                  END IF 
60             CONTINUE 
            ELSE 
                  KX = KX + (N-1)*INCX 
                  JX = KX 
                  DO 80 J = N,1,-1 
                  IF (X(JX).NE.ZERO) THEN 
                        TEMP = X(JX) 
                        IX = KX 
                        DO 70 I = N,J + 1,-1 
                              X(IX) = X(IX) + TEMP*A(I,J) 
                              IX = IX - INCX 
70                     CONTINUE 
                        IF (NOUNIT) X(JX) = X(JX)*A(J,J) 
                  END IF 
                  JX = JX - INCX 
80             CONTINUE 
            END IF 
      END IF 
      ELSE 
!                                                                       
!        Form  x := A**T*x.                                             
!                                                                       
      IF (LSAME(UPLO,'U')) THEN 
            IF (INCX.EQ.1) THEN 
                  DO 100 J = N,1,-1 
                  TEMP = X(J) 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 90 I = J - 1,1,-1 
                        TEMP = TEMP + A(I,J)*X(I) 
90                 CONTINUE 
                  X(J) = TEMP 
100             CONTINUE 
            ELSE 
                  JX = KX + (N-1)*INCX 
                  DO 120 J = N,1,-1 
                  TEMP = X(JX) 
                  IX = JX 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 110 I = J - 1,1,-1 
                        IX = IX - INCX 
                        TEMP = TEMP + A(I,J)*X(IX) 
110                 CONTINUE 
                  X(JX) = TEMP 
                  JX = JX - INCX 
120             CONTINUE 
            END IF 
      ELSE 
            IF (INCX.EQ.1) THEN 
                  DO 140 J = 1,N 
                  TEMP = X(J) 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 130 I = J + 1,N 
                        TEMP = TEMP + A(I,J)*X(I) 
130                 CONTINUE 
                  X(J) = TEMP 
140             CONTINUE 
            ELSE 
                  JX = KX 
                  DO 160 J = 1,N 
                  TEMP = X(JX) 
                  IX = JX 
                  IF (NOUNIT) TEMP = TEMP*A(J,J) 
                  DO 150 I = J + 1,N 
                        IX = IX + INCX 
                        TEMP = TEMP + A(I,J)*X(IX) 
150                 CONTINUE 
                  X(JX) = TEMP 
                  JX = JX + INCX 
160             CONTINUE 
            END IF 
      END IF 
      END IF 
!                                                                       
      RETURN 
!                                                                       
!     End of DTRMV .                                                    
!                                                                       
      END                                           
!> \brief \b IDAMAX                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION IDAMAX(N,DX,INCX)                              
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER INCX,N                                                  
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION DX(*)                                          
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>    IDAMAX finds the index of the first element having maximum absolut
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>         number of elements in input vector(s)                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] DX                                                        
!> \verbatim                                                            
!>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs(
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INCX                                                      
!> \verbatim                                                            
!>          INCX is INTEGER                                             
!>         storage spacing between elements of DX                       
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2017                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>     jack dongarra, linpack, 3/11/78.                                 
!>     modified 3/93 to return if incx .le. 0.                          
!>     modified 12/3/93, array(1) declarations changed to array(*)      
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION IDAMAX(N,DX,INCX) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.8.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2017                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX,N 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION DX(*) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLE PRECISION DMAX 
      INTEGER I,IX 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC DABS 
!     ..                                                                
      IDAMAX = 0 
      IF (N.LT.1 .OR. INCX.LE.0) RETURN 
      IDAMAX = 1 
      IF (N.EQ.1) RETURN 
      IF (INCX.EQ.1) THEN 
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
      DMAX = DABS(DX(1)) 
      DO I = 2,N 
            IF (DABS(DX(I)).GT.DMAX) THEN 
            IDAMAX = I 
            DMAX = DABS(DX(I)) 
            END IF 
      END DO 
      ELSE 
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
      IX = 1 
      DMAX = DABS(DX(1)) 
      IX = IX + INCX 
      DO I = 2,N 
            IF (DABS(DX(IX)).GT.DMAX) THEN 
            IDAMAX = I 
            DMAX = DABS(DX(IX)) 
            END IF 
            IX = IX + INCX 
      END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b IEEECK                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download IEEECK + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE )            
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            ISPEC                                        
!       REAL               ONE, ZERO                                    
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> IEEECK is called from the ILAENV to verify that Infinity and         
!> possibly NaN arithmetic is safe (i.e. will not trap).                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>          Specifies whether to test just for inifinity arithmetic     
!>          or whether to test for infinity and NaN arithmetic.         
!>          = 0: Verify infinity arithmetic only.                       
!>          = 1: Verify infinity and NaN arithmetic.                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ZERO                                                      
!> \verbatim                                                            
!>          ZERO is REAL                                                
!>          Must contain the value 0.0                                  
!>          This is passed to prevent the compiler from optimizing      
!>          away this code.                                             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ONE                                                       
!> \verbatim                                                            
!>          ONE is REAL                                                 
!>          Must contain the value 1.0                                  
!>          This is passed to prevent the compiler from optimizing      
!>          away this code.                                             
!>                                                                      
!>  RETURN VALUE:  INTEGER                                              
!>          = 0:  Arithmetic failed to produce the correct answers      
!>          = 1:  Arithmetic produced the correct answers               
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            ISPEC 
      REAL               ONE, ZERO 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL               NAN1, NAN2, NAN3, NAN4, NAN5, NAN6, NEGINF,    &
&                   NEGZRO, NEWZRO, POSINF                         
!     ..                                                                
!     .. Executable Statements ..                                       
      IEEECK = 1 
!                                                                       
      POSINF = ONE / ZERO 
      IF( POSINF.LE.ONE ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      NEGINF = -ONE / ZERO 
      IF( NEGINF.GE.ZERO ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      NEGZRO = ONE / ( NEGINF+ONE ) 
      IF( NEGZRO.NE.ZERO ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      NEGINF = ONE / NEGZRO 
      IF( NEGINF.GE.ZERO ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      NEWZRO = NEGZRO + ZERO 
      IF( NEWZRO.NE.ZERO ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      POSINF = ONE / NEWZRO 
      IF( POSINF.LE.ONE ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      NEGINF = NEGINF*POSINF 
      IF( NEGINF.GE.ZERO ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      POSINF = POSINF*POSINF 
      IF( POSINF.LE.ONE ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
!                                                                       
!                                                                       
!                                                                       
!     Return if we were only asked to check infinity arithmetic         
!                                                                       
      IF( ISPEC.EQ.0 )                                                  &
&   RETURN                                                         
!                                                                       
      NAN1 = POSINF + NEGINF 
!                                                                       
      NAN2 = POSINF / NEGINF 
!                                                                       
      NAN3 = POSINF / POSINF 
!                                                                       
      NAN4 = POSINF*ZERO 
!                                                                       
      NAN5 = NEGINF*NEGZRO 
!                                                                       
      NAN6 = NAN5*ZERO 
!                                                                       
      IF( NAN1.EQ.NAN1 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      IF( NAN2.EQ.NAN2 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      IF( NAN3.EQ.NAN3 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      IF( NAN4.EQ.NAN4 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      IF( NAN5.EQ.NAN5 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      IF( NAN6.EQ.NAN6 ) THEN 
      IEEECK = 0 
      RETURN 
      END IF 
!                                                                       
      RETURN 
      END                                           
!> \brief \b ILADLC scans a matrix for its last non-zero column.        
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILADLC + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILADLC( M, N, A, LDA )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            M, N, LDA                                    
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILADLC scans A for its last non-zero column.                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          The m by n matrix A.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A. LDA >= max(1,M).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      INTEGER FUNCTION ILADLC( M, N, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            M, N, LDA 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ZERO 
      PARAMETER ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER I 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick test for the common case where one corner is non-zero.      
      IF( N.EQ.0 ) THEN 
      ILADLC = N 
      ELSE IF( A(1, N).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN 
      ILADLC = N 
      ELSE 
!     Now scan each column from the end, returning with the first non-ze
      DO ILADLC = N, 1, -1 
            DO I = 1, M 
            IF( A(I, ILADLC).NE.ZERO ) RETURN 
            END DO 
      END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b ILADLR scans a matrix for its last non-zero row.           
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILADLR + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILADLR( M, N, A, LDA )                         
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            M, N, LDA                                    
!       ..                                                              
!       .. Array Arguments ..                                           
!       DOUBLE PRECISION   A( LDA, * )                                  
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILADLR scans A for its last non-zero row.                            
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] M                                                         
!> \verbatim                                                            
!>          M is INTEGER                                                
!>          The number of rows of the matrix A.                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>          The number of columns of the matrix A.                      
!> \endverbatim                                                         
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is DOUBLE PRECISION array, dimension (LDA,N)              
!>          The m by n matrix A.                                        
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LDA                                                       
!> \verbatim                                                            
!>          LDA is INTEGER                                              
!>          The leading dimension of the array A. LDA >= max(1,M).      
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!  =====================================================================
      INTEGER FUNCTION ILADLR( M, N, A, LDA ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            M, N, LDA 
!     ..                                                                
!     .. Array Arguments ..                                             
      DOUBLE PRECISION   A( LDA, * ) 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION ZERO 
      PARAMETER ( ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER I, J 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick test for the common case where one corner is non-zero.      
      IF( M.EQ.0 ) THEN 
      ILADLR = M 
      ELSE IF( A(M, 1).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN 
      ILADLR = M 
      ELSE 
!     Scan up each column tracking the last zero row seen.              
      ILADLR = 0 
      DO J = 1, N 
            I=M 
            DO WHILE((A(MAX(I,1),J).EQ.ZERO).AND.(I.GE.1)) 
            I=I-1 
            ENDDO 
            ILADLR = MAX( ILADLR, I ) 
      END DO 
      END IF 
      RETURN 
      END                                           
!> \brief \b ILAENV                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download ILAENV + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )    
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER*( * )    NAME, OPTS                                   
!       INTEGER            ISPEC, N1, N2, N3, N4                        
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> ILAENV is called from the LAPACK routines to choose problem-dependent
!> parameters for the local environment.  See ISPEC for a description of
!> the parameters.                                                      
!>                                                                      
!> ILAENV returns an INTEGER                                            
!> if ILAENV >= 0: ILAENV returns the value of the parameter specified b
!> if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal valu
!>                                                                      
!> This version provides a set of parameters which should give good,    
!> but not optimal, performance on many of the currently available      
!> computers.  Users are encouraged to modify this subroutine to set    
!> the tuning parameters for their particular machine using the option  
!> and problem size information in the arguments.                       
!>                                                                      
!> This routine will not function correctly if it is converted to all   
!> lower case.  Converting it to all upper case is allowed.             
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>          Specifies the parameter to be returned as the value of      
!>          ILAENV.                                                     
!>          = 1: the optimal blocksize; if this value is 1, an unblocked
!>               algorithm will give the best performance.              
!>          = 2: the minimum block size for which the block routine     
!>               should be used; if the usable block size is less than  
!>               this value, an unblocked routine should be used.       
!>          = 3: the crossover point (in a block routine, for N less    
!>               than this value, an unblocked routine should be used)  
!>          = 4: the number of shifts, used in the nonsymmetric         
!>               eigenvalue routines (DEPRECATED)                       
!>          = 5: the minimum column dimension for blocking to be used;  
!>               rectangular blocks must have dimension at least k by m,
!>               where k is given by ILAENV(2,...) and m by ILAENV(5,...
!>          = 6: the crossover point for the SVD (when reducing an m by 
!>               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
!>               this value, a QR factorization is used first to reduce 
!>               the matrix to a triangular form.)                      
!>          = 7: the number of processors                               
!>          = 8: the crossover point for the multishift QR method       
!>               for nonsymmetric eigenvalue problems (DEPRECATED)      
!>          = 9: maximum size of the subproblems at the bottom of the   
!>               computation tree in the divide-and-conquer algorithm   
!>               (used by xGELSD and xGESDD)                            
!>          =10: ieee NaN arithmetic can be trusted not to trap         
!>          =11: infinity arithmetic can be trusted not to trap         
!>          12 <= ISPEC <= 16:                                          
!>               xHSEQR or related subroutines,                         
!>               see IPARMQ for detailed explanation                    
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NAME                                                      
!> \verbatim                                                            
!>          NAME is CHARACTER*(*)                                       
!>          The name of the calling subroutine, in either upper case or 
!>          lower case.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OPTS                                                      
!> \verbatim                                                            
!>          OPTS is CHARACTER*(*)                                       
!>          The character options to the subroutine NAME, concatenated  
!>          into a single character string.  For example, UPLO = 'U',   
!>          TRANS = 'T', and DIAG = 'N' for a triangular routine would  
!>          be specified as OPTS = 'UTN'.                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N1                                                        
!> \verbatim                                                            
!>          N1 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N2                                                        
!> \verbatim                                                            
!>          N2 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N3                                                        
!> \verbatim                                                            
!>          N3 is INTEGER                                               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N4                                                        
!> \verbatim                                                            
!>          N4 is INTEGER                                               
!>          Problem dimensions for the subroutine NAME; these may not al
!>          be required.                                                
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date November 2019                                                  
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>  The following conventions have been used when calling ILAENV from th
!>  LAPACK routines:                                                    
!>  1)  OPTS is a concatenation of all of the character options to      
!>      subroutine NAME, in the same order that they appear in the      
!>      argument list for NAME, even if they are not used in determining
!>      the value of the parameter specified by ISPEC.                  
!>  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
!>      that they appear in the argument list for NAME.  N1 is used     
!>      first, N2 second, and so on, and unused problem dimensions are  
!>      passed a value of -1.                                           
!>  3)  The parameter value returned by ILAENV is checked for validity i
!>      the calling subroutine.  For example, ILAENV is used to retrieve
!>      the optimal blocksize for STRTRI as follows:                    
!>                                                                      
!>      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )         
!>      IF( NB.LE.1 ) NB = MAX( 1, N )                                  
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.9.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     November 2019                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*( * )    NAME, OPTS 
      INTEGER            ISPEC, N1, N2, N3, N4 
!     ..                                                                
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, IC, IZ, NB, NBMIN, NX 
      LOGICAL            CNAME, SNAME, TWOSTAGE 
      CHARACTER          C1*1, C2*2, C4*2, C3*3, SUBNAM*16 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL 
!     ..                                                                
!     .. External Functions ..                                          
      INTEGER            IEEECK, IPARMQ, IPARAM2STAGE 
      EXTERNAL           IEEECK, IPARMQ, IPARAM2STAGE 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      GO TO ( 10, 10, 10, 80, 90, 100, 110, 120,                        &
&        130, 140, 150, 160, 160, 160, 160, 160)ISPEC              
!                                                                       
!     Invalid value for ISPEC                                           
!                                                                       
      ILAENV = -1 
      RETURN 
!                                                                       
10 CONTINUE 
!                                                                       
!     Convert NAME to upper case if the first character is lower case.  
!                                                                       
      ILAENV = 1 
      SUBNAM = NAME 
      IC = ICHAR( SUBNAM( 1: 1 ) ) 
      IZ = ICHAR( 'Z' ) 
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN 
!                                                                       
!        ASCII character set                                            
!                                                                       
      IF( IC.GE.97 .AND. IC.LE.122 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO 20 I = 2, 6 
            IC = ICHAR( SUBNAM( I: I ) ) 
            IF( IC.GE.97 .AND. IC.LE.122 )                           &
&            SUBNAM( I: I ) = CHAR( IC-32 )                        
20       CONTINUE 
      END IF 
!                                                                       
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN 
!                                                                       
!        EBCDIC character set                                           
!                                                                       
      IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                         &
&       ( IC.GE.145 .AND. IC.LE.153 ) .OR.                         &
&       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN                       
            SUBNAM( 1: 1 ) = CHAR( IC+64 ) 
            DO 30 I = 2, 6 
            IC = ICHAR( SUBNAM( I: I ) ) 
            IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                   &
&             ( IC.GE.145 .AND. IC.LE.153 ) .OR.                   &
&             ( IC.GE.162 .AND. IC.LE.169 ) )SUBNAM( I:            &
&             I ) = CHAR( IC+64 )                                  
30       CONTINUE 
      END IF 
!                                                                       
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN 
!                                                                       
!        Prime machines:  ASCII+128                                     
!                                                                       
      IF( IC.GE.225 .AND. IC.LE.250 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO 40 I = 2, 6 
            IC = ICHAR( SUBNAM( I: I ) ) 
            IF( IC.GE.225 .AND. IC.LE.250 )                          &
&            SUBNAM( I: I ) = CHAR( IC-32 )                        
40       CONTINUE 
      END IF 
      END IF 
!                                                                       
      C1 = SUBNAM( 1: 1 ) 
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D' 
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z' 
      IF( .NOT.( CNAME .OR. SNAME ) )                                   &
&   RETURN                                                         
      C2 = SUBNAM( 2: 3 ) 
      C3 = SUBNAM( 4: 6 ) 
      C4 = C3( 2: 3 ) 
      TWOSTAGE = LEN( SUBNAM ).GE.11                                    &
&           .AND. SUBNAM( 11: 11 ).EQ.'2'                          
!                                                                       
      GO TO ( 50, 60, 70 )ISPEC 
!                                                                       
50 CONTINUE 
!                                                                       
!     ISPEC = 1:  block size                                            
!                                                                       
!     In these examples, separate code is provided for setting NB for   
!     real and complex.  We assume that NB will take the same value in  
!     single or double precision.                                       
!                                                                       
      NB = 1 
!                                                                       
      IF( SUBNAM(2:6).EQ.'LAORH' ) THEN 
!                                                                       
!        This is for *LAORHR_GETRFNP routine                            
!                                                                       
      IF( SNAME ) THEN 
            NB = 32 
      ELSE 
            NB = 32 
      END IF 
      ELSE IF( C2.EQ.'GE' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.    &
&            C3.EQ.'QLF' ) THEN                                    
            IF( SNAME ) THEN 
            NB = 32 
            ELSE 
            NB = 32 
            END IF 
      ELSE IF( C3.EQ.'QR ') THEN 
            IF( N3 .EQ. 1) THEN 
            IF( SNAME ) THEN 
!     M*N                                                               
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                  NB = N1 
                  ELSE 
                  NB = 32768/N2 
                  END IF 
            ELSE 
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                  NB = N1 
                  ELSE 
                  NB = 32768/N2 
                  END IF 
            END IF 
            ELSE 
            IF( SNAME ) THEN 
                  NB = 1 
            ELSE 
                  NB = 1 
            END IF 
            END IF 
      ELSE IF( C3.EQ.'LQ ') THEN 
            IF( N3 .EQ. 2) THEN 
            IF( SNAME ) THEN 
!     M*N                                                               
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                  NB = N1 
                  ELSE 
                  NB = 32768/N2 
                  END IF 
            ELSE 
                  IF ((N1*N2.LE.131072).OR.(N1.LE.8192)) THEN 
                  NB = N1 
                  ELSE 
                  NB = 32768/N2 
                  END IF 
            END IF 
            ELSE 
            IF( SNAME ) THEN 
                  NB = 1 
            ELSE 
                  NB = 1 
            END IF 
            END IF 
      ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
            NB = 32 
            ELSE 
            NB = 32 
            END IF 
      ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
            NB = 32 
            ELSE 
            NB = 32 
            END IF 
      ELSE IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'PO' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            IF( TWOSTAGE ) THEN 
                  NB = 192 
            ELSE 
                  NB = 64 
            END IF 
            ELSE 
            IF( TWOSTAGE ) THEN 
                  NB = 192 
            ELSE 
                  NB = 64 
            END IF 
            END IF 
      ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NB = 32 
      ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN 
            NB = 64 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( TWOSTAGE ) THEN 
            NB = 192 
            ELSE 
            NB = 64 
            END IF 
      ELSE IF( C3.EQ.'TRD' ) THEN 
            NB = 32 
      ELSE IF( C3.EQ.'GST' ) THEN 
            NB = 64 
      END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NB = 32 
            END IF 
      ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NB = 32 
            END IF 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NB = 32 
            END IF 
      ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NB = 32 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'GB' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            IF( N4.LE.64 ) THEN 
                  NB = 1 
            ELSE 
                  NB = 32 
            END IF 
            ELSE 
            IF( N4.LE.64 ) THEN 
                  NB = 1 
            ELSE 
                  NB = 32 
            END IF 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'PB' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            IF( N2.LE.64 ) THEN 
                  NB = 1 
            ELSE 
                  NB = 32 
            END IF 
            ELSE 
            IF( N2.LE.64 ) THEN 
                  NB = 1 
            ELSE 
                  NB = 32 
            END IF 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'TR' ) THEN 
      IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      ELSE IF ( C3.EQ.'EVC' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'LA' ) THEN 
      IF( C3.EQ.'UUM' ) THEN 
            IF( SNAME ) THEN 
            NB = 64 
            ELSE 
            NB = 64 
            END IF 
      END IF 
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN 
      IF( C3.EQ.'EBZ' ) THEN 
            NB = 1 
      END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
      NB = 32 
      IF( C3.EQ.'HD3' ) THEN 
            IF( SNAME ) THEN 
            NB = 32 
            ELSE 
            NB = 32 
            END IF 
      END IF 
      END IF 
      ILAENV = NB 
      RETURN 
!                                                                       
60 CONTINUE 
!                                                                       
!     ISPEC = 2:  minimum block size                                    
!                                                                       
      NBMIN = 2 
      IF( C2.EQ.'GE' ) THEN 
      IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.  &
&       'QLF' ) THEN                                               
            IF( SNAME ) THEN 
            NBMIN = 2 
            ELSE 
            NBMIN = 2 
            END IF 
      ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
            NBMIN = 2 
            ELSE 
            NBMIN = 2 
            END IF 
      ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
            NBMIN = 2 
            ELSE 
            NBMIN = 2 
            END IF 
      ELSE IF( C3.EQ.'TRI' ) THEN 
            IF( SNAME ) THEN 
            NBMIN = 2 
            ELSE 
            NBMIN = 2 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
      IF( C3.EQ.'TRF' ) THEN 
            IF( SNAME ) THEN 
            NBMIN = 8 
            ELSE 
            NBMIN = 8 
            END IF 
      ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NBMIN = 2 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
      IF( C3.EQ.'TRD' ) THEN 
            NBMIN = 2 
      END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NBMIN = 2 
            END IF 
      ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NBMIN = 2 
            END IF 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NBMIN = 2 
            END IF 
      ELSE IF( C3( 1: 1 ).EQ.'M' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NBMIN = 2 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
      NBMIN = 2 
      IF( C3.EQ.'HD3' ) THEN 
            NBMIN = 2 
      END IF 
      END IF 
      ILAENV = NBMIN 
      RETURN 
!                                                                       
70 CONTINUE 
!                                                                       
!     ISPEC = 3:  crossover point                                       
!                                                                       
      NX = 0 
      IF( C2.EQ.'GE' ) THEN 
      IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR. C3.EQ.  &
&       'QLF' ) THEN                                               
            IF( SNAME ) THEN 
            NX = 128 
            ELSE 
            NX = 128 
            END IF 
      ELSE IF( C3.EQ.'HRD' ) THEN 
            IF( SNAME ) THEN 
            NX = 128 
            ELSE 
            NX = 128 
            END IF 
      ELSE IF( C3.EQ.'BRD' ) THEN 
            IF( SNAME ) THEN 
            NX = 128 
            ELSE 
            NX = 128 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'SY' ) THEN 
      IF( SNAME .AND. C3.EQ.'TRD' ) THEN 
            NX = 32 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN 
      IF( C3.EQ.'TRD' ) THEN 
            NX = 32 
      END IF 
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NX = 128 
            END IF 
      END IF 
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN 
      IF( C3( 1: 1 ).EQ.'G' ) THEN 
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR. C4.EQ.  &
&          'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' )  &
&           THEN                                                   
            NX = 128 
            END IF 
      END IF 
      ELSE IF( C2.EQ.'GG' ) THEN 
      NX = 128 
      IF( C3.EQ.'HD3' ) THEN 
            NX = 128 
      END IF 
      END IF 
      ILAENV = NX 
      RETURN 
!                                                                       
80 CONTINUE 
!                                                                       
!     ISPEC = 4:  number of shifts (used by xHSEQR)                     
!                                                                       
      ILAENV = 6 
      RETURN 
!                                                                       
90 CONTINUE 
!                                                                       
!     ISPEC = 5:  minimum column dimension (not used)                   
!                                                                       
      ILAENV = 2 
      RETURN 
!                                                                       
100 CONTINUE 
!                                                                       
!     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)   
!                                                                       
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 ) 
      RETURN 
!                                                                       
110 CONTINUE 
!                                                                       
!     ISPEC = 7:  number of processors (not used)                       
!                                                                       
      ILAENV = 1 
      RETURN 
!                                                                       
120 CONTINUE 
!                                                                       
!     ISPEC = 8:  crossover point for multishift (used by xHSEQR)       
!                                                                       
      ILAENV = 50 
      RETURN 
!                                                                       
130 CONTINUE 
!                                                                       
!     ISPEC = 9:  maximum size of the subproblems at the bottom of the  
!                 computation tree in the divide-and-conquer algorithm  
!                 (used by xGELSD and xGESDD)                           
!                                                                       
      ILAENV = 25 
      RETURN 
!                                                                       
140 CONTINUE 
!                                                                       
!     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap        
!                                                                       
!     ILAENV = 0                                                        
      ILAENV = 1 
      IF( ILAENV.EQ.1 ) THEN 
      ILAENV = IEEECK( 1, 0.0, 1.0 ) 
      END IF 
      RETURN 
!                                                                       
150 CONTINUE 
!                                                                       
!     ISPEC = 11: infinity arithmetic can be trusted not to trap        
!                                                                       
!     ILAENV = 0                                                        
      ILAENV = 1 
      IF( ILAENV.EQ.1 ) THEN 
      ILAENV = IEEECK( 0, 0.0, 1.0 ) 
      END IF 
      RETURN 
!                                                                       
160 CONTINUE 
!                                                                       
!     12 <= ISPEC <= 16: xHSEQR or related subroutines.                 
!                                                                       
      ILAENV = IPARMQ( ISPEC, NAME, OPTS, N1, N2, N3, N4 ) 
      RETURN 
!                                                                       
!     End of ILAENV                                                     
!                                                                       
!> \brief \b IPARMQ                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!> \htmlonly                                                            
!> Download IPARMQ + dependencies                                       
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&fil
!> [TGZ]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&fil
!> [ZIP]</a>                                                            
!> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&fil
!> [TXT]</a>                                                            
!> \endhtmlonly                                                         
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK )
!                                                                       
!       .. Scalar Arguments ..                                          
!       INTEGER            IHI, ILO, ISPEC, LWORK, N                    
!       CHARACTER          NAME*( * ), OPTS*( * )                       
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>      This program sets problem and machine dependent parameters      
!>      useful for xHSEQR and related subroutines for eigenvalue        
!>      problems. It is called whenever                                 
!>      IPARMQ is called with 12 <= ISPEC <= 16                         
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] ISPEC                                                     
!> \verbatim                                                            
!>          ISPEC is INTEGER                                            
!>              ISPEC specifies which tunable parameter IPARMQ should   
!>              return.                                                 
!>                                                                      
!>              ISPEC=12: (INMIN)  Matrices of order nmin or less       
!>                        are sent directly to xLAHQR, the implicit     
!>                        double shift QR algorithm.  NMIN must be      
!>                        at least 11.                                  
!>                                                                      
!>              ISPEC=13: (INWIN)  Size of the deflation window.        
!>                        This is best set greater than or equal to     
!>                        the number of simultaneous shifts NS.         
!>                        Larger matrices benefit from larger deflation 
!>                        windows.                                      
!>                                                                      
!>              ISPEC=14: (INIBL) Determines when to stop nibbling and  
!>                        invest in an (expensive) multi-shift QR sweep.
!>                        If the aggressive early deflation subroutine  
!>                        finds LD converged eigenvalues from an order  
!>                        NW deflation window and LD > (NW*NIBBLE)/100, 
!>                        then the next QR sweep is skipped and early   
!>                        deflation is applied immediately to the       
!>                        remaining active diagonal block.  Setting     
!>                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a   
!>                        multi-shift QR sweep whenever early deflation 
!>                        finds a converged eigenvalue.  Setting        
!>                        IPARMQ(ISPEC=14) greater than or equal to 100 
!>                        prevents TTQRE from skipping a multi-shift    
!>                        QR sweep.                                     
!>                                                                      
!>              ISPEC=15: (NSHFTS) The number of simultaneous shifts in 
!>                        a multi-shift QR iteration.                   
!>                                                                      
!>              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the  
!>                        following meanings.                           
!>                        0:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are not      
!>                            accumulated when updating the             
!>                            far-from-diagonal matrix entries.         
!>                        1:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are          
!>                            accumulated, and matrix-matrix            
!>                            multiplication is used to update the      
!>                            far-from-diagonal matrix entries.         
!>                        2:  During the multi-shift QR/QZ sweep,       
!>                            blocked eigenvalue reordering, blocked    
!>                            Hessenberg-triangular reduction,          
!>                            reflections and/or rotations are          
!>                            accumulated, and 2-by-2 block structure   
!>                            is exploited during matrix-matrix         
!>                            multiplies.                               
!>                        (If xTRMM is slower than xGEMM, then          
!>                        IPARMQ(ISPEC=16)=1 may be more efficient than 
!>                        IPARMQ(ISPEC=16)=2 despite the greater level o
!>                        arithmetic work implied by the latter choice.)
!> \endverbatim                                                         
!>                                                                      
!> \param[in] NAME                                                      
!> \verbatim                                                            
!>          NAME is CHARACTER string                                    
!>               Name of the calling subroutine                         
!> \endverbatim                                                         
!>                                                                      
!> \param[in] OPTS                                                      
!> \verbatim                                                            
!>          OPTS is CHARACTER string                                    
!>               This is a concatenation of the string arguments to     
!>               TTQRE.                                                 
!> \endverbatim                                                         
!>                                                                      
!> \param[in] N                                                         
!> \verbatim                                                            
!>          N is INTEGER                                                
!>               N is the order of the Hessenberg matrix H.             
!> \endverbatim                                                         
!>                                                                      
!> \param[in] ILO                                                       
!> \verbatim                                                            
!>          ILO is INTEGER                                              
!> \endverbatim                                                         
!>                                                                      
!> \param[in] IHI                                                       
!> \verbatim                                                            
!>          IHI is INTEGER                                              
!>               It is assumed that H is already upper triangular       
!>               in rows and columns 1:ILO-1 and IHI+1:N.               
!> \endverbatim                                                         
!>                                                                      
!> \param[in] LWORK                                                     
!> \verbatim                                                            
!>          LWORK is INTEGER                                            
!>               The amount of workspace available.                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date June 2017                                                      
!                                                                       
!> \ingroup OTHERauxiliary                                              
!                                                                       
!> \par Further Details:                                                
!  =====================                                                
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!>       Little is known about how best to choose these parameters.     
!>       It is possible to use different values of the parameters       
!>       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.                 
!>                                                                      
!>       It is probably best to choose different parameters for         
!>       different matrices and different parameters at different       
!>       times during the iteration, but this has not been              
!>       implemented --- yet.                                           
!>                                                                      
!>                                                                      
!>       The best choices of most of the parameters depend              
!>       in an ill-understood way on the relative execution             
!>       rate of xLAQR3 and xLAQR5 and on the nature of each            
!>       particular eigenvalue problem.  Experiment may be the          
!>       only practical way to determine which choices are most         
!>       effective.                                                     
!>                                                                      
!>       Following is a list of default values supplied by IPARMQ.      
!>       These defaults may be adjusted in order to attain better       
!>       performance in any particular computational environment.       
!>                                                                      
!>       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.         
!>                        Default: 75. (Must be at least 11.)           
!>                                                                      
!>       IPARMQ(ISPEC=13) Recommended deflation window size.            
!>                        This depends on ILO, IHI and NS, the          
!>                        number of simultaneous shifts returned        
!>                        by IPARMQ(ISPEC=15).  The default for         
!>                        (IHI-ILO+1) <= 500 is NS.  The default        
!>                        for (IHI-ILO+1) > 500 is 3*NS/2.              
!>                                                                      
!>       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.         
!>                                                                      
!>       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.            
!>                        a multi-shift QR iteration.                   
!>                                                                      
!>                        If IHI-ILO+1 is ...                           
!>                                                                      
!>                        greater than      ...but less    ... the      
!>                        or equal to ...      than        default is   
!>                                                                      
!>                                0               30       NS =   2+    
!>                               30               60       NS =   4+    
      END                                           
!>                               60              150       NS =  10     
!>                              150              590       NS =  **     
!>                              590             3000       NS =  64     
!>                             3000             6000       NS = 128     
!>                             6000             infinity   NS = 256     
!>                                                                      
!>                    (+)  By default matrices of this order are        
!>                         passed to the implicit double shift routine  
!>                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These 
!>                         values of NS are used only in case of a rare 
!>                         xLAHQR failure.                              
!>                                                                      
!>                    (**) The asterisks (**) indicate an ad-hoc        
!>                         function increasing from 10 to 64.           
!>                                                                      
!>       IPARMQ(ISPEC=16) Select structured matrix multiply.            
!>                        (See ISPEC=16 above for details.)             
!>                        Default: 3.                                   
!> \endverbatim                                                         
!>                                                                      
!  =====================================================================
      INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.1) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     June 2017                                                         
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            IHI, ILO, ISPEC, LWORK, N 
      CHARACTER          NAME*( * ), OPTS*( * ) 
!                                                                       
!  ================================================================     
!     .. Parameters ..                                                  
      INTEGER            INMIN, INWIN, INIBL, ISHFTS, IACC22 
      PARAMETER          ( INMIN = 12, INWIN = 13, INIBL = 14,          &
&                   ISHFTS = 15, IACC22 = 16 )                     
      INTEGER            NMIN, K22MIN, KACMIN, NIBBLE, KNWSWP 
      PARAMETER          ( NMIN = 75, K22MIN = 14, KACMIN = 14,         &
&                   NIBBLE = 14, KNWSWP = 500 )                    
      REAL               TWO 
      PARAMETER          ( TWO = 2.0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            NH, NS 
      INTEGER            I, IC, IZ 
      CHARACTER          SUBNAM*6 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          LOG, MAX, MOD, NINT, REAL 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF( ( ISPEC.EQ.ISHFTS ) .OR. ( ISPEC.EQ.INWIN ) .OR.              &
&    ( ISPEC.EQ.IACC22 ) ) THEN                                    
!                                                                       
!        ==== Set the number simultaneous shifts ====                   
!                                                                       
      NH = IHI - ILO + 1 
      NS = 2 
      IF( NH.GE.30 )                                                 &
&      NS = 4                                                      
      IF( NH.GE.60 )                                                 &
&      NS = 10                                                     
      IF( NH.GE.150 )                                                &
&      NS = MAX( 10, NH / NINT( LOG( REAL( NH ) ) / LOG( TWO ) ) ) 
      IF( NH.GE.590 )                                                &
&      NS = 64                                                     
      IF( NH.GE.3000 )                                               &
&      NS = 128                                                    
      IF( NH.GE.6000 )                                               &
&      NS = 256                                                    
      NS = MAX( 2, NS-MOD( NS, 2 ) ) 
      END IF 
!                                                                       
      IF( ISPEC.EQ.INMIN ) THEN 
!                                                                       
!                                                                       
!        ===== Matrices of order smaller than NMIN get sent             
!        .     to xLAHQR, the classic double shift algorithm.           
!        .     This must be at least 11. ====                           
!                                                                       
      IPARMQ = NMIN 
!                                                                       
      ELSE IF( ISPEC.EQ.INIBL ) THEN 
!                                                                       
!        ==== INIBL: skip a multi-shift qr iteration and                
!        .    whenever aggressive early deflation finds                 
!        .    at least (NIBBLE*(window size)/100) deflations. ====      
!                                                                       
      IPARMQ = NIBBLE 
!                                                                       
      ELSE IF( ISPEC.EQ.ISHFTS ) THEN 
!                                                                       
!        ==== NSHFTS: The number of simultaneous shifts =====           
!                                                                       
      IPARMQ = NS 
!                                                                       
      ELSE IF( ISPEC.EQ.INWIN ) THEN 
!                                                                       
!        ==== NW: deflation window size.  ====                          
!                                                                       
      IF( NH.LE.KNWSWP ) THEN 
            IPARMQ = NS 
      ELSE 
            IPARMQ = 3*NS / 2 
      END IF 
!                                                                       
      ELSE IF( ISPEC.EQ.IACC22 ) THEN 
!                                                                       
!        ==== IACC22: Whether to accumulate reflections                 
!        .     before updating the far-from-diagonal elements           
!        .     and whether to use 2-by-2 block structure while          
!        .     doing it.  A small amount of work could be saved         
!        .     by making this choice dependent also upon the            
!        .     NH=IHI-ILO+1.                                            
!                                                                       
!                                                                       
!        Convert NAME to upper case if the first character is lower case
!                                                                       
      IPARMQ = 0 
      SUBNAM = NAME 
      IC = ICHAR( SUBNAM( 1: 1 ) ) 
      IZ = ICHAR( 'Z' ) 
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN 
!                                                                       
!           ASCII character set                                         
!                                                                       
            IF( IC.GE.97 .AND. IC.LE.122 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( IC.GE.97 .AND. IC.LE.122 )                        &
&               SUBNAM( I: I ) = CHAR( IC-32 )                     
            END DO 
            END IF 
!                                                                       
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN 
!                                                                       
!           EBCDIC character set                                        
!                                                                       
            IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                      &
&          ( IC.GE.145 .AND. IC.LE.153 ) .OR.                      &
&          ( IC.GE.162 .AND. IC.LE.169 ) ) THEN                    
            SUBNAM( 1: 1 ) = CHAR( IC+64 ) 
            DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                &
&                ( IC.GE.145 .AND. IC.LE.153 ) .OR.                &
&                ( IC.GE.162 .AND. IC.LE.169 ) )SUBNAM( I:         &
&                I ) = CHAR( IC+64 )                               
            END DO 
            END IF 
!                                                                       
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN 
!                                                                       
!           Prime machines:  ASCII+128                                  
!                                                                       
            IF( IC.GE.225 .AND. IC.LE.250 ) THEN 
            SUBNAM( 1: 1 ) = CHAR( IC-32 ) 
            DO I = 2, 6 
                  IC = ICHAR( SUBNAM( I: I ) ) 
                  IF( IC.GE.225 .AND. IC.LE.250 )                       &
&               SUBNAM( I: I ) = CHAR( IC-32 )                     
            END DO 
            END IF 
      END IF 
!                                                                       
      IF( SUBNAM( 2:6 ).EQ.'GGHRD' .OR.                              &
&       SUBNAM( 2:6 ).EQ.'GGHD3' ) THEN                            
            IPARMQ = 1 
            IF( NH.GE.K22MIN )                                          &
&         IPARMQ = 2                                               
      ELSE IF ( SUBNAM( 4:6 ).EQ.'EXC' ) THEN 
            IF( NH.GE.KACMIN )                                          &
&         IPARMQ = 1                                               
            IF( NH.GE.K22MIN )                                          &
&         IPARMQ = 2                                               
      ELSE IF ( SUBNAM( 2:6 ).EQ.'HSEQR' .OR.                        &
&             SUBNAM( 2:5 ).EQ.'LAQR' ) THEN                       
            IF( NS.GE.KACMIN )                                          &
&         IPARMQ = 1                                               
            IF( NS.GE.K22MIN )                                          &
&         IPARMQ = 2                                               
      END IF 
!                                                                       
      ELSE 
!        ===== invalid value of ispec =====                             
      IPARMQ = -1 
!                                                                       
      END IF 
!                                                                       
!     ==== End of IPARMQ ====                                           
!                                                                       
      END                                           
!> \brief \b LSAME                                                      
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       LOGICAL FUNCTION LSAME(CA,CB)                                   
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER CA,CB                                                 
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> LSAME returns .TRUE. if CA is the same letter as CB regardless of    
!> case.                                                                
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] CA                                                        
!> \verbatim                                                            
!>          CA is CHARACTER*1                                           
!> \endverbatim                                                         
!>                                                                      
!> \param[in] CB                                                        
!> \verbatim                                                            
!>          CB is CHARACTER*1                                           
!>          CA and CB specify the single characters to be compared.     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!  =====================================================================
      LOGICAL FUNCTION LSAME(CA,CB) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.1) --                    
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER CA,CB 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Intrinsic Functions ..                                         
      INTRINSIC ICHAR 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER INTA,INTB,ZCODE 
!     ..                                                                
!                                                                       
!     Test if the characters are equal                                  
!                                                                       
      LSAME = CA .EQ. CB 
      IF (LSAME) RETURN 
!                                                                       
!     Now test for equivalence if both characters are alphabetic.       
!                                                                       
      ZCODE = ICHAR('Z') 
!                                                                       
!     Use 'Z' rather than 'A' so that ASCII can be detected on Prime    
!     machines, on which ICHAR returns a value with bit 8 set.          
!     ICHAR('A') on Prime machines returns 193 which is the same as     
!     ICHAR('A') on an EBCDIC machine.                                  
!                                                                       
      INTA = ICHAR(CA) 
      INTB = ICHAR(CB) 
!                                                                       
      IF (ZCODE.EQ.90 .OR. ZCODE.EQ.122) THEN 
!                                                                       
!        ASCII is assumed - ZCODE is the ASCII code of either lower or  
!        upper case 'Z'.                                                
!                                                                       
      IF (INTA.GE.97 .AND. INTA.LE.122) INTA = INTA - 32 
      IF (INTB.GE.97 .AND. INTB.LE.122) INTB = INTB - 32 
!                                                                       
      ELSE IF (ZCODE.EQ.233 .OR. ZCODE.EQ.169) THEN 
!                                                                       
!        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
!        upper case 'Z'.                                                
!                                                                       
      IF (INTA.GE.129 .AND. INTA.LE.137 .OR.                        &
&        INTA.GE.145 .AND. INTA.LE.153 .OR.                        &
&        INTA.GE.162 .AND. INTA.LE.169) INTA = INTA + 64           
      IF (INTB.GE.129 .AND. INTB.LE.137 .OR.                        &
&        INTB.GE.145 .AND. INTB.LE.153 .OR.                        &
&        INTB.GE.162 .AND. INTB.LE.169) INTB = INTB + 64           
!                                                                       
      ELSE IF (ZCODE.EQ.218 .OR. ZCODE.EQ.250) THEN 
!                                                                       
!        ASCII is assumed, on Prime machines - ZCODE is the ASCII code  
!        plus 128 of either lower or upper case 'Z'.                    
!                                                                       
      IF (INTA.GE.225 .AND. INTA.LE.250) INTA = INTA - 32 
      IF (INTB.GE.225 .AND. INTB.LE.250) INTB = INTB - 32 
      END IF 
      LSAME = INTA .EQ. INTB 
!                                                                       
!     RETURN                                                            
!                                                                       
!     End of LSAME                                                      
!                                                                       
      END                                           
!> \brief \b XERBLA                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!       SUBROUTINE XERBLA( SRNAME, INFO )                               
!                                                                       
!       .. Scalar Arguments ..                                          
!       CHARACTER*(*)      SRNAME                                       
!       INTEGER            INFO                                         
!       ..                                                              
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> XERBLA  is an error handler for the LAPACK routines.                 
!> It is called by an LAPACK routine if an input parameter has an       
!> invalid value.  A message is printed and execution stops.            
!>                                                                      
!> Installers may consider modifying the STOP statement in order to     
!> call system-specific exception-handling facilities.                  
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] SRNAME                                                    
!> \verbatim                                                            
!>          SRNAME is CHARACTER*(*)                                     
!>          The name of the routine which called XERBLA.                
!> \endverbatim                                                         
!>                                                                      
!> \param[in] INFO                                                      
!> \verbatim                                                            
!>          INFO is INTEGER                                             
!>          The position of the invalid parameter in the parameter list 
!>          of the calling routine.                                     
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup aux_blas                                                    
!                                                                       
!  =====================================================================
      SUBROUTINE XERBLA( SRNAME, INFO ) 
!                                                                       
!  -- Reference BLAS level1 routine (version 3.7.0) --                  
!  -- Reference BLAS is a software package provided by Univ. of Tennesse
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*(*)      SRNAME 
      INTEGER            INFO 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Intrinsic Functions ..                                         
      INTRINSIC          LEN_TRIM 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      WRITE( *, FMT = 9999 )SRNAME( 1:LEN_TRIM( SRNAME ) ), INFO 
!                                                                       
      STOP 
!                                                                       
9999 FORMAT( ' ** On entry to ', A, ' parameter number ', I2, ' had ', &
&      'an illegal value' )                                        
!                                                                       
!     End of XERBLA                                                     
!                                                                       
      END                                           
!> \brief \b DLAMCH                                                     
!                                                                       
!  =========== DOCUMENTATION ===========                                
!                                                                       
! Online html documentation available at                                
!            http://www.netlib.org/lapack/explore-html/                 
!                                                                       
!  Definition:                                                          
!  ===========                                                          
!                                                                       
!      DOUBLE PRECISION FUNCTION DLAMCH( CMACH )                        
!                                                                       
!     .. Scalar Arguments ..                                            
!     CHARACTER          CMACH                                          
!     ..                                                                
!                                                                       
!                                                                       
!> \par Purpose:                                                        
!  =============                                                        
!>                                                                      
!> \verbatim                                                            
!>                                                                      
!> DLAMCH determines double precision machine parameters.               
!> \endverbatim                                                         
!                                                                       
!  Arguments:                                                           
!  ==========                                                           
!                                                                       
!> \param[in] CMACH                                                     
!> \verbatim                                                            
!>          CMACH is CHARACTER*1                                        
!>          Specifies the value to be returned by DLAMCH:               
!>          = 'E' or 'e',   DLAMCH := eps                               
!>          = 'S' or 's ,   DLAMCH := sfmin                             
!>          = 'B' or 'b',   DLAMCH := base                              
!>          = 'P' or 'p',   DLAMCH := eps*base                          
!>          = 'N' or 'n',   DLAMCH := t                                 
!>          = 'R' or 'r',   DLAMCH := rnd                               
!>          = 'M' or 'm',   DLAMCH := emin                              
!>          = 'U' or 'u',   DLAMCH := rmin                              
!>          = 'L' or 'l',   DLAMCH := emax                              
!>          = 'O' or 'o',   DLAMCH := rmax                              
!>          where                                                       
!>          eps   = relative machine precision                          
!>          sfmin = safe minimum, such that 1/sfmin does not overflow   
!>          base  = base of the machine                                 
!>          prec  = eps*base                                            
!>          t     = number of (base) digits in the mantissa             
!>          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise 
!>          emin  = minimum exponent before (gradual) underflow         
!>          rmin  = underflow threshold - base**(emin-1)                
!>          emax  = largest exponent before overflow                    
!>          rmax  = overflow threshold  - (base**emax)*(1-eps)          
!> \endverbatim                                                         
!                                                                       
!  Authors:                                                             
!  ========                                                             
!                                                                       
!> \author Univ. of Tennessee                                           
!> \author Univ. of California Berkeley                                 
!> \author Univ. of Colorado Denver                                     
!> \author NAG Ltd.                                                     
!                                                                       
!> \date December 2016                                                  
!                                                                       
!> \ingroup auxOTHERauxiliary                                           
!                                                                       
!  =====================================================================
      DOUBLE PRECISION FUNCTION DLAMCH( CMACH ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
!     December 2016                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          CMACH 
!     ..                                                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLE PRECISION   ONE, ZERO 
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      DOUBLE PRECISION   RND, EPS, SFMIN, SMALL, RMACH 
!     ..                                                                
!     .. External Functions ..                                          
      LOGICAL            LSAME 
      EXTERNAL           LSAME 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          DIGITS, EPSILON, HUGE, MAXEXPONENT,            &
&                   MINEXPONENT, RADIX, TINY                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!                                                                       
!     Assume rounding, not chopping. Always.                            
!                                                                       
      RND = ONE 
!                                                                       
      IF( ONE.EQ.RND ) THEN 
      EPS = EPSILON(ZERO) * 0.5 
      ELSE 
      EPS = EPSILON(ZERO) 
      END IF 
!                                                                       
      IF( LSAME( CMACH, 'E' ) ) THEN 
      RMACH = EPS 
      ELSE IF( LSAME( CMACH, 'S' ) ) THEN 
      SFMIN = TINY(ZERO) 
      SMALL = ONE / HUGE(ZERO) 
      IF( SMALL.GE.SFMIN ) THEN 
!                                                                       
!           Use SMALL plus a bit, to avoid the possibility of rounding  
!           causing overflow when computing  1/sfmin.                   
!                                                                       
            SFMIN = SMALL*( ONE+EPS ) 
      END IF 
      RMACH = SFMIN 
      ELSE IF( LSAME( CMACH, 'B' ) ) THEN 
      RMACH = RADIX(ZERO) 
      ELSE IF( LSAME( CMACH, 'P' ) ) THEN 
      RMACH = EPS * RADIX(ZERO) 
      ELSE IF( LSAME( CMACH, 'N' ) ) THEN 
      RMACH = DIGITS(ZERO) 
      ELSE IF( LSAME( CMACH, 'R' ) ) THEN 
      RMACH = RND 
      ELSE IF( LSAME( CMACH, 'M' ) ) THEN 
      RMACH = MINEXPONENT(ZERO) 
      ELSE IF( LSAME( CMACH, 'U' ) ) THEN 
      RMACH = tiny(zero) 
      ELSE IF( LSAME( CMACH, 'L' ) ) THEN 
      RMACH = MAXEXPONENT(ZERO) 
      ELSE IF( LSAME( CMACH, 'O' ) ) THEN 
      RMACH = HUGE(ZERO) 
      ELSE 
      RMACH = ZERO 
      END IF 
!                                                                       
      DLAMCH = RMACH 
      RETURN 
!                                                                       
!     End of DLAMCH                                                     
!                                                                       
      END                                           
!***********************************************************************
!> \brief \b DLAMC3                                                     
!> \details                                                             
!> \b Purpose:                                                          
!> \verbatim                                                            
!> DLAMC3  is intended to force  A  and  B  to be stored prior to doing 
!> the addition of  A  and  B ,  for use in situations where optimizers 
!> might hold one of these in a register.                               
!> \endverbatim                                                         
!> \author LAPACK is a software package provided by Univ. of Tennessee, 
!> \date December 2016                                                  
!> \ingroup auxOTHERauxiliary                                           
!>                                                                      
!> \param[in] A                                                         
!> \verbatim                                                            
!>          A is a DOUBLE PRECISION                                     
!> \endverbatim                                                         
!>                                                                      
!> \param[in] B                                                         
!> \verbatim                                                            
!>          B is a DOUBLE PRECISION                                     
!>          The values A and B.                                         
!> \endverbatim                                                         
!>                                                                      
      DOUBLE PRECISION FUNCTION DLAMC3( A, B ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.7.0) --                       
!     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..    
!     November 2010                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLE PRECISION   A, B 
!     ..                                                                
! ===================================================================== 
!                                                                       
!     .. Executable Statements ..                                       
!                                                                       
      DLAMC3 = A + B 
!                                                                       
      RETURN 
!                                                                       
!     End of DLAMC3                                                     
!                                                                       
      END                                           